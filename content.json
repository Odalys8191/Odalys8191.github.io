{"meta":{"title":"An Oier From Yali","subtitle":"","description":"","author":"Odalys","url":"http://odalys8191.github.io","root":"/"},"pages":[{"title":"about","date":"2021-10-14T11:03:47.000Z","updated":"2021-10-22T06:34:10.106Z","comments":true,"path":"about/index.html","permalink":"http://odalys8191.github.io/about/index.html","excerpt":"","text":"An Oier From HN-Yali Love literature. Love philosophy, Love thinking"},{"title":"daily","date":"2021-10-22T13:27:43.000Z","updated":"2021-12-26T08:29:49.954Z","comments":true,"path":"daily/index.html","permalink":"http://odalys8191.github.io/daily/index.html","excerpt":"","text":"每天都做了啥？ 属于是要反复拷问这个颓怪了。 过水的题只有一句话题解。 UPD：打 * 的是看了没写的 # 2021-10-14 [APC001C\\color{green}\\texttt{APC001C}APC001C] Links Sol: Learn how to use binary search. [CF1458 (4/6)\\color{purple}\\texttt{CF1458\\ (4/6)}CF1458 (4/6)] Links 大概率是不会改到 F 了 [LGP4748\\color{blue}\\texttt{LGP4748}LGP4748] Links 考虑切 kkk 条边，能得出 k+1k+1k+1 个子树，故 k+1∣nk+1 | nk+1∣n ，还能得出每棵子树大小 nn\\overn​ 然后考虑切 fau→ufa_u\\to ufau​→u 这条边，会拆出一棵 sizusiz_usizu​ 大小的子树，合法的 nk+1n\\over {k+1}k+1n​ 一定是他的因数，而 sizusiz_usizu​ 两两不同，所以对于每个 kkk ，我们只要找倍数符合的 uuu 是否为 k+1k + 1k+1 就行了。 # 2021-10-15 把昨天 EEE 改了。 [CF1427E\\color{blue}\\texttt{CF1427E}CF1427E] Links * 难想的数学题。 被提示后可以想到的数学题。 [CF1527E\\color{green}\\texttt{CF1527E}CF1527E] Links 一眼题。 为啥打绿，因为想撞题然后赢麻 这种分 kkk 段的问题，十分之经典，然后就是 dpdpdp 后转化大胆猜测他有一个决策单调性，然后就四边形不等式优化 dpdpdp 了。 # 2021-10-17 →\\to→ 2021-10-19 考试，改题 # 2021-10-20 [CF1442D\\color{blue}\\texttt{CF1442D}CF1442D] Links 注意到最终答案一定最多只有一个数组没有选完。 因为假如有两个的话由于数组是单调不降的，那你把其中一个前面不选选另一个后面一定不劣。 于是就变成了排除一个物品的背包问题，这是经典问题虽然一天前我还不会，考虑分治解决，假如一个在 l midl~midl mid 中就把 mid+1 rmid+1~rmid+1 r 加入背包，递归做左边，每个物品会被加入分治树–也就是 log⁡\\loglog 次。 # 2021-10-21 →\\to→ 2021-10-23 考试，改题，自闭 # 2021-10-24 [LGP4978\\color{green}\\texttt{LGP4978}LGP4978] sb 题，直接做。 [CF379F\\color{blue}\\texttt{CF379F}CF379F] 就这 [LGP5999\\color{blue}\\texttt{LGP5999}LGP5999] NB Dp! 把挨个经过的元素记做序列 AAA 可以发现： A1=s,An=tA_1 = s, A_n = tA1​=s,An​=t。 Ai−1&lt;Ai&gt;Ai+1 or Ai−1&gt;Ai&lt;Ai+1A_{i-1}&lt;A_{i}&gt;A_{i+1} \\ \\texttt{or}\\ A_{i-1}&gt;A_{i}&lt;A_{i+1}Ai−1​&lt;Ai​&gt;Ai+1​ or Ai−1​&gt;Ai​&lt;Ai+1​。 从小到大的考虑每个元素 xxx 插入序列，放它时，1→x−11\\to x-11→x−1 都已经放完且一定会形成若干个满足上述条件的连续段，那我们只需枚举一下放在哪里插入，对连续段的影响就好。 由于我每次插入时是当前的最大值，所以连续段两边的意义其实就是波谷，我可以决策的是是否要作为波峰来合并两个连续段。 如何证明这样计数不重不漏？ 首先这样计数每个排列都是符合题意的，然后对于每个排列我们都可以从最小的开始依次还原操作。。。。 啊啊啊不是很懂 [CF702F\\color{purple}\\texttt{CF702F}CF702F] * 可以想到的 DS ，大概方向上是对了，但平衡树不太熟了。 大概是，你暴力就是对每个人依次看每个物品，那你考虑每个物品的贡献，按质量从大到小排，它肯定是，能买的下的人造成 111 的贡献，然后问题转换为每次把大于 ccc 的数字减去 ccc ，问每个数字被操作的次数。 这个可以用平衡树做，具体的，你把平衡树分为三个区间 (0,C), [C,2C), [2C, \\infity] ，然后只对第二个区间暴力修改，对第三个区间打 tagtagtag 解决，然后利用势能分析，这玩意是对的 # 2021-10-25 [AGC099C\\color{red}\\texttt{AGC099C}AGC099C] 简单贪心 [CF1602A\\color{red}\\texttt{CF1602A}CF1602A] sb 题 [CF1602B\\color{red}\\texttt{CF1602B}CF1602B] sb 题 [CF1602C\\color{green}\\texttt{CF1602C}CF1602C] 每位 111 个数的 gcdgcdgcd 的因子就是答案 [CF1602D\\color{green}\\texttt{CF1602D}CF1602D] 做个线性 dpdpdp ，用 SGTSGTSGT 优化这个过程 注意转移顺序 # 2021-10-27 [CF521D Shop\\color{blue}\\texttt{CF521D Shop}CF521D Shop] 神奇贪心 [CF734E Anton and Tree\\color{blue}\\texttt{CF734E Anton and Tree}CF734E Anton and Tree] 有趣树论 都是 ZROI 搬的题。 [AGC099H\\color{blue}\\texttt{AGC099H}AGC099H] 这种跟完全图有关的东西可以想想补图。 在这题中，拆分为两个完全子图放在补图上就是选出两个点集，内部无边。 不难发现这是一个二分图染色的要求 然后使用 bitset 优化一个背包，设选出的一个合法点集大小为 xxx ，那答案为 (x2)×(n−x2)\\binom{x}{2}\\times \\binom{n-x}{2}(2x​)×(2n−x​) 。 [AGC099I\\color{blue}\\texttt{AGC099I}AGC099I] * 这个指针移动可以转换成对 hashhashhash 值做一些事情。 然后在 mapmapmap 上搞一下。 [BZOJ4543\\color{blue}\\texttt{BZOJ4543}BZOJ4543] 长链剖分优化 dp 今天考试挂了 60pts ，十分自闭。 感觉晚上效率不够高。 # 2021-10-28 [WC2010 重建计划\\color{purple}\\texttt{WC2010 重建计划}WC2010 重建计划] * 首先这个带除法的形式可以分数规划。 然后我们要求的就是树上边数 ∈[L,U]\\in [L,U]∈[L,U] 的最大路径长 这个可以套路地上淀粉质做 也可以长剖优化 dp 考虑最 naive 的 dp, 设 dpu,jdp_{u,j}dpu,j​ 表示 uuu 子树往下走 jjj 条边的最大权值和 这个暴力 O(n2)\\mathrm O(n^2)O(n2) dp 不难 然后我们优先做长儿子，记录 dfs 序，可以发现每条长链 dfs 序都是连续的，然后我们就可以把 $dp_{x,i} 放到 dfnx+idfn_x + idfnx​+i 这个 SGT 上，就可以快速从长儿子合并了 # 2021-11-8 [ARC120A\\color{red}\\texttt{ARC120A}ARC120A] [ARC120B\\color{red}\\texttt{ARC120B}ARC120B] 可以构造发现斜率为 111 的对角线必须相同，然后就随便做了。 [ARC120C\\color{blue}\\texttt{ARC120C}ARC120C] 有趣的题。 首先和不同直接无解，因为交换并不改变总和。 进一步考虑，可以发现一个精彩的结论，令 ai′=ai+ia&#x27;_i = a_i + iai′​=ai​+i 发现你咋换，这个值都不变 想到了证明还是很简单的，于是你就可以知道那些可以匹配了，要构造最短次数想到那个经典逆序对的结论，然后搞搞就好。 [ARC120D\\color{blue}\\texttt{ARC120D}ARC120D] 若排序后前一半后后一半匹配，这样答案最大。 然后考虑构造成立 使用一个类似括号序列的东西就可以了 [ARC120E,F\\color{black}\\texttt{ARC120E,F}ARC120E,F] 不会 [ARC125A\\color{red}\\texttt{ARC125A}ARC125A] 简单题 [ARC125B\\color{green}\\texttt{ARC125B}ARC125B] 有趣题。 首先可以转成统计 x2−y2=ax^2-y^2=ax2−y2=a 其中 a∈[1,n]a\\in [1,n]a∈[1,n] 。 那把完全平方数序列画出来，就是在其中统计两个数之差满足限制 考虑差，那就差分一下，发现问题转为在一个差分数组上求一段连续区间使得和满足条件。 完全平方数序列的差分序列是个等差数列 然后你把每个长度的区间和写出来，发现也是等差数列，首项还是个完全平方数。 然后你就做完了。 # 2021-11-9 [ZROI2136\\color{blue}\\texttt{ZROI2136}ZROI2136] 感觉这种遇到 npnpnp 问题一定要想想与原问题的区别，毕竟相信出题人与其搞你不如去拿个菲尔兹，有助于想出题。 这题的关联就是 kkk 是 1e61e61e6 级别，直接枚举是可以接受的 于是你考虑从最小团开始每次新增一个点，使用 bitset\\texttt{bitset}bitset 即可快速判断是否还成团，用个优先队列维护一下就好。 注意到这样无用状态过多，空间开不下，于是把权值排序后，每次只拓展两个点，一个是把当前最大的消掉换个更大的，一个是直径加个当前最小的。 [ZROI2137\\color{blue}\\texttt{ZROI2137}ZROI2137] 由于并没有改完题就没有新开一个 testtesttest 了。 可以证明最终答案中出现的序列每个元素只可能是它能影响的 333 个中位数之一。 每个位置只有常数个选择这激起了我们的 dpdpdp 欲望，于是考虑设 dpi,j,k,j∈[1,3],k∈[1,3]dp_{i,j,k}, j\\in [1,3], k\\in [1,3]dpi,j,k​,j∈[1,3],k∈[1,3] 表示当前决策到了第 iii 个位置，第 i−1i-1i−1 个位置选择第 jjj 个数字，第 iii 个位置选择第 kkk 个位置的可行性，记录一个 nxtnxtnxt 方便构造解即可。 [ARC111A\\color{yellow}\\texttt{ARC111A}ARC111A] 由于意识到一起床就听讲题效率不够高，总是需要重播于是在 14:00→16:0014:00\\to 16:0014:00→16:00 来了一场 vpvpvp，感觉自己还是菜的离谱 虽然这题很简单但我第一遍没做出来于是还是推一遍柿子。 10n=⌊10nm⌋+r10^n = \\lfloor{10^n\\over m}\\rfloor + r 10n=⌊m10n​⌋+r 记 k=⌊10nm⌋k=\\lfloor{10^n\\over m}\\rfloork=⌊m10n​⌋， k=a×m+r′k=a\\times m + r&#x27; k=a×m+r′ r′r&#x27;r′ 即为所求，于是代入： 10n=a×m2+r′m+r10^n = a\\times m^2 + r&#x27;m + r 10n=a×m2+r′m+r 注意到 r′m+rr&#x27;m+rr′m+r 相当于是 10n10^n10n 膜 m2m^2m2 的余数，而 r&lt;mr&lt;mr&lt;m 所以有： ⌊r′m+rm⌋=r′\\lfloor {r&#x27;m + r\\over m}\\rfloor = r&#x27; ⌊mr′m+r​⌋=r′ [ARC111B\\color{yellow}\\texttt{ARC111B}ARC111B] 反着考虑每种颜色是否能出现到答案中，可以把一对颜色连条边，每条边表示两端只能取 111 。 对于每个联通块，若为一棵树，贡献为 siz−1siz-1siz−1 ，否则贡献 sizsizsiz. [ARC111C\\color{green}\\texttt{ARC111C}ARC111C] 有一个 tricktricktrick 已多次使用，那就是对于一个排列，i→pii\\to p_ii→pi​ 这样连边，一定能连出若干条环。 这题也是一样，对于每个联通块（一定是一个环），在环中使用 aaa 最大的一个人当工具人用它帮助其他人。 [ARC111D\\color{green}\\texttt{ARC111D}ARC111D] 考虑一条边 x,yx, yx,y ， 一定是 ccc 大的连 ccc 小的，因为若反过来的话 ccc 大的点能到的点小的一定能到，就 GGGGGG 了。 对于 ccc 相同的边，我们建出图来，由于一定有解，这些边构成的每个联通块一定是一个个环，然后任意定向即可。 [51Nod 1598\\color{blue}\\texttt{51Nod 1598}51Nod 1598] * 别被演了！！！ !∑∣kix+bi∣\\sum |k_ix+b_i|∑∣ki​x+bi​∣ 就是坑人的，把你引到二维上，实际上，考虑一对绝对值之和取最小，有个经典初中几何意义是数轴上一堆点取一个点到其它所有点的距离最小。 那这个柿子可以变成 ∑∣ki∣∣x+biki∣\\sum |k_i| |x+{b_i\\over k_i}|∑∣ki​∣∣x+ki​bi​​∣ 是个带权的问题，可以看做在 bikb_i\\over kkbi​​ 出撒了 kkk 个点，离散化一下考虑维护区间中位数和距离和，可以用线段树上二分解决（？） 没写 [大吉大利今晚吃鸡\\color{purple}\\texttt{大吉大利今晚吃鸡}大吉大利今晚吃鸡] 见题解 # 2021-11-10 云了套联考题～ [KT1 NOIP2021\\color{black}\\texttt{KT1 NOIP2021}KT1 NOIP2021] [ZROI Day17\\color{black}\\texttt{ZROI Day17}ZROI Day17] [CF372D\\color{blue}\\texttt{CF372D}CF372D] 二分然后 172E # 2021-11-16 [$\\color{blue}\\texttt{zroi446}] 数独的奇异性质。 对于每种 111 的排列，对应的数独最终局面数是相同的。 枚举多少种合法的放 111 的排列即可得知当前局面数与总局面数之间的比例。 总局面数怎么算？通过样例可以反推。 [zroi447\\color{blue}\\texttt{zroi447}zroi447] 直接最短路即可。 注意处理路的边权时的一些细节。 # 2021-12-25 [\\color{}] # 2021-12-26 [CF109C\\color{red}\\texttt{CF109C}CF109C] 把 lucky edge\\texttt{lucky edge}lucky edge 拆开，然后是个简单计数题。 [CF432C\\color{red}\\texttt{CF432C}CF432C] 哥猜一下。"},{"title":"friends","date":"2021-10-20T13:34:23.000Z","updated":"2022-02-23T03:07:26.144Z","comments":true,"path":"friends/index.html","permalink":"http://odalys8191.github.io/friends/index.html","excerpt":"","text":"iodwad 两个笛笛 Zcus 普信男 ObsidianY 乖宝宝 CXY07 熙叉歪 ycpedef 歪西批"},{"title":"tags","date":"2021-09-19T07:41:54.000Z","updated":"2021-09-19T07:42:21.379Z","comments":true,"path":"tags/index.html","permalink":"http://odalys8191.github.io/tags/index.html","excerpt":"","text":""},{"title":"神必错误","date":"2021-10-21T07:56:45.000Z","updated":"2021-11-17T05:27:42.946Z","comments":true,"path":"神必错误/index.html","permalink":"http://odalys8191.github.io/%E7%A5%9E%E5%BF%85%E9%94%99%E8%AF%AF/index.html","excerpt":"","text":"set 判断相等的方式好像是判断 a 不大于 b 且 b 不大于 a ，所以如果你在新建一个 struct 给他加比较函数的话，不多搞几个判断又没开 multiset 的话有的东西读不进去 set 一生之敌， set 首先不能加入多个相同的数字，就算是 multiset 删除的时候会把一样的都删完，所以一般还是要写个 struct 然后考虑上面的问题。 异或的一些性质： ∀i&lt;j&lt;k,i⊕k≥min⁡{i⊕j,j⊕k}\\forall i &lt; j &lt; k, i\\oplus k\\ge \\min\\{i\\oplus j, j\\oplus k\\}∀i&lt;j&lt;k,i⊕k≥min{i⊕j,j⊕k}. i⊕j≥∣i−j∣i\\oplus j\\ge |i-j|i⊕j≥∣i−j∣. ∃k&lt;2∣i−j∣,(i+k)⊕(j+k)=∣i−j∣\\exists k&lt; 2|i-j|, (i+k)\\oplus(j+k) = |i-j|∃k&lt;2∣i−j∣,(i+k)⊕(j+k)=∣i−j∣. dpdpdp 转移时，一定注意转移的顺序，注意对实际转移意义造成的影响。 打表找规律时，注意表打错的情况。 感觉这方面没什么经验，可能数字见少了 [离线！离线！离线！！！！\\huge\\texttt{离线！离线！离线！！！！}离线！离线！离线！！！！]"}],"posts":[{"title":"高雅大话","slug":"高雅大话","date":"2024-11-08T04:12:01.000Z","updated":"2024-11-08T04:12:59.748Z","comments":true,"path":"Article/高雅大话/cm3881elg0001dntn15jwgsoy/","link":"","permalink":"http://odalys8191.github.io/Article/%E9%AB%98%E9%9B%85%E5%A4%A7%E8%AF%9D/cm3881elg0001dntn15jwgsoy/","excerpt":"","text":"","categories":[{"name":"Article","slug":"Article","permalink":"http://odalys8191.github.io/categories/Article/"}],"tags":[]},{"title":"大门狂摘！","slug":"大门狂摘！","date":"2024-11-08T04:10:18.000Z","updated":"2024-11-08T04:11:48.690Z","comments":true,"path":"Article/大门狂摘！/cm3881elb0000dntn10i09qd5/","link":"","permalink":"http://odalys8191.github.io/Article/%E5%A4%A7%E9%97%A8%E7%8B%82%E6%91%98%EF%BC%81/cm3881elb0000dntn10i09qd5/","excerpt":"","text":"","categories":[{"name":"Article","slug":"Article","permalink":"http://odalys8191.github.io/categories/Article/"}],"tags":[]},{"title":"霓虹国游记","slug":"霓虹国游记","date":"2024-11-05T12:04:58.000Z","updated":"2024-11-08T01:17:07.523Z","comments":true,"path":"Article/霓虹国游记/cm34emcae0001gotnc7xa0ix0/","link":"","permalink":"http://odalys8191.github.io/Article/%E9%9C%93%E8%99%B9%E5%9B%BD%E6%B8%B8%E8%AE%B0/cm34emcae0001gotnc7xa0ix0/","excerpt":"","text":"由于 blog 要 restart 了，所以按照记忆摸鱼的时候写写 # 2024-?-?? 不记得什么时候，iodwad 建议大家暑假出国玩，并钦定 Japan，于是就 Japan 了。 # 2024-7-?? 不记得什么时候，iodwad 发现自己是青海王子难以出国，他建议大家找国内平替，于是除他之外的人准备前往霓虹了！ 然后是出场人物简介：我，猪主席，猿辅导，邓公。 我和我的动物朋友们将以 crychic 之名造访某人未曾谋面的故乡了！ # 2024-7-31 处于环保的角度考虑，本次旅行我全程开启超级省电模式，根本没用脑，于是行程规划完全交给邓公了 由于是 eco 旅行，我们买了去往南京转的机票，猿辅导自北京飞南京参与我们下一程 南京落地，拿了行李，我们准备前往邓公订好的酒店，但逝，出了一点小问题…… 我：md，明天八点的飞机，是不是五点就要起啊，怎么办啊…… 邓公：? 猪主席：？？？ 原来是我订错机票了 /kk 快要旅行了，难免有点兴奋，于是在南京转机的一晚完全没睡，看着猪主席与邓公赤膊角斗～ # 2024-8-1 于是就是孤独大阪行了 /ll 留子猪主席认为出境飞行起码提前 3h，于是我五点就起了，在南京机场等了 2h /tuu 机场排队的时候碰到一对南京大叔大妈，看着十分淳朴（实际也是） 值机到了靠窗位置，然后就可以看海了！ 落地发现了不计其数的湾湾人，他们持绿色的中华民国护照，独特的口音一眼丁真。 日本老龄话肉眼可见的严重，机场引导出入境的工作人员都是 过关要填一个 id card 然后交给入境官猿审查，在我前面排着的依次是之前出现过的南京大叔大妈，湾湾一家子，我后面排着一个京爷。 然后就发生了神秘事情 南京大叔大妈似乎没填 id card，因为语言不通导致我们的队伍滞停了。 京爷给他爆了：“Go back to write your id card，知不知道自己影响了多少人。” 南京大叔尴尬地退了回来，然后是民国一家子。 京爷：“Every one，都要有自己的 qr 码” 成功一穿二，然后是我了 好在一遍过了，没有被京爷拷问。","categories":[{"name":"Article","slug":"Article","permalink":"http://odalys8191.github.io/categories/Article/"}],"tags":[]},{"title":"再见公路","slug":"再见公路","date":"2024-11-05T12:03:53.000Z","updated":"2024-11-08T01:17:41.083Z","comments":true,"path":"Articles/再见公路/cm34emca90000gotnhjkd3mcc/","link":"","permalink":"http://odalys8191.github.io/Articles/%E5%86%8D%E8%A7%81%E5%85%AC%E8%B7%AF/cm34emca90000gotnhjkd3mcc/","excerpt":"","text":"记录一个具有显著公路片特质的传奇夜晚 # 前情提要： 国庆节辣椒油提出十月中旬要来天津玩，刚巧笛笛那几天十九大寿，于是又把北京的 zzm 喊过来进行猪党大会。 hku 国庆仅放一天，而 reading week 却放一周，成分十分明显 辣椒油租了一辆大众车，这是一切神秘故事的起源😓 周五下午我在八里台上完诗经课，溜达了一会听说辣椒油落地了。遂与辣椒油在西南联大纪念碑等笛笛下课。没想到笛笛根本不知道存在这么一块纪念碑！符合人设 晚上我想复刻经典茶颜三人组，于是点了三杯霸王叉积，没想到… # 正文 笛笛翘了一天课和辣椒油在天津鬼混，下午到津南接我时他们已是手机没电，精神萎靡。我找室友借了根线，没想到是华为线，中华有为的能量拒绝为苹果手机充能。然后我的手机就成了唯一能够联络外界的工具了…… 另外两人都睡了，于是方向盘就到了我的手里，导航到高铁站发现仅有 40mins，刚巧 zzm 的高铁还有 30mins 到。于是全速前进，前往高铁站！ 开到一半堵住了，zzm 已然到达，我一看导航怎么还有 40mins，zzm 在 qq 上戳我，我在开车无法双手操作，在某个停车的间隙我建议他先开一把王者荣耀 又开了半小时，显示 one more 30mins，zzm 问我到哪里了，我合理建议他再开一把王者荣耀 又过了半小时，观察手机的震动频率容易注意到 zzm 应该已经确乎红温了，我赶紧摇醒笛笛要求他跟 zzm 打视频电话。没想到一开口我就没绷住： 笛笛睡眼惺忪：老公，你什么时候剃了个韩式中分？？？ zzm：你他妈的，我这是在河边吹了一个半小时风吹出来的。 契诃夫曾经说过，假若作者描写到墙上有一把枪，那它之后一定会响，于是有: “你们快点啰，我的手机因为打了过多的王者荣耀快没电了！” 此刻车厢里发生了如下对话 我有一个提议，要他打个的去吃饭的地方吧！ 如果在一个小时前，这将是一个好提议。 …… 晚高峰的路况的确不太好，天津司机十分喜欢加塞变道，辣椒油在旁边为我略阵” 前面是个比亚迪，放心撞！“” 五菱宏光，考虑一下不一定撞得过”…… 笛笛在身旁一直安抚 zzm，走走停停中，我走神听 qq 电话去了，没踩死刹车。我们的无敌大众亲吻上了前车屁股，我一看，nia，宝马。 “你就站在那里别急…… 诶，czj 撞了一辆宝马” ”？“ 一片兵荒马乱 zzm 报了个点世纪钟，笛笛就带着没电的手机出去找人了，我有点破防，打了个双闪就 45 度仰望天空，思考这得赔多少钱，得 eco 多少天。身经百战的辣椒油留下来陪我应对宝马车主。车主报了警，我们一起开往交警大队。 没想到半路上，宝马车主发现自己的屁股问题不大，于是放过了我们。 我们 check 了一下，我们的车也一点问题没有，win。 唉，生活是苦难的，我又开着我的无敌大众出发了。 现在到了喜闻乐见的找人环节，不过与之前不一样的是，我们要找两个人了…… 不出意料的两人都手机停电关机了，我们导航到了世纪钟，在大圆盘转了若干圈后，在人山人海中，我一眼就认出了 zzm 的韩式中分。 zzm 上车后，我们发现生日宴出了一点小问题 — 寿星不见了！考虑到由 crash 地点到世纪钟不超过 1km，而已经过去了 15min，再怎么走也到了，我们只得在世纪钟一遍遍转圈圈，期待笛笛足够智慧可以找到这个地标。 zzm: md，我有点饿了，车上有什么吃的吗 czj: 有给寿星的生日蛋糕。 或许我们可以…… 如果笛笛足够聪明的话应该会扫个充电宝吧，为什么还不联系我们呢？ …… 等下你帮我扫个充电宝好不，我手机关机了。 我可能知道为什么笛笛联系不上我们了 转了若干圈","categories":[{"name":"Articles","slug":"Articles","permalink":"http://odalys8191.github.io/categories/Articles/"}],"tags":[]},{"title":"高等数学学习笔记","slug":"高等数学学习笔记","date":"2024-11-05T11:44:34.000Z","updated":"2024-11-08T01:22:54.529Z","comments":true,"path":"Notes/高等数学学习笔记/cm34e3w8300g15vtnf46ea8oj/","link":"","permalink":"http://odalys8191.github.io/Notes/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/cm34e3w8300g15vtnf46ea8oj/","excerpt":"","text":"# 2024-11-4 zdp # L’Hospital lim⁡x→x0f(x)=0,lim⁡x→x0g(x)=0\\lim_{x\\to x_0}f(x)=0,\\lim_{x\\to x_0}g(x)=0 x→x0​lim​f(x)=0,x→x0​lim​g(x)=0 lim⁡x→x0f’(x)g’(x)=lim⁡x→x0f(x)g(x)=A{\\lim_{x\\to x_0}{f’(x)\\over g’(x)}=\\lim_{x\\to x_0}{f(x)\\over g(x)}}=A x→x0​lim​g’(x)f’(x)​=x→x0​lim​g(x)f(x)​=A lim⁡x→x0+\\lim_{x\\to x_0^+}limx→x0+​​ 同样可用 可一直洛 lim⁡x→1x2−3x+2x3−x2−x+1=lim⁡x→12x−33x2−2x−1=−10nan?\\lim_{x\\to 1} {x^2-3x + 2\\over x^3-x^2-x+1}=\\lim_{x\\to 1}{2x-3\\over 3x^2 -2x-1}={-1\\over 0} nan? x→1lim​x3−x2−x+1x2−3x+2​=x→1lim​3x2−2x−12x−3​=0−1​nan? lim⁡x→0x−sin⁡xxsin⁡2x=x−sin⁡xx3\\lim_{x\\to 0} {x-\\sin x \\over x\\sin^2x}={x-\\sin x\\over x^3} x→0lim​xsin2xx−sinx​=x3x−sinx​ (先用等价无穷小替换使得形式简单) # 2.1 ∞∞\\infty\\over\\infty∞∞​ 关注有没有导数 （一次可导而第二次不可导） lim⁡x→x0f(x)g(x)\\lim_{x\\to x_0} f(x)^{g(x)} x→x0​lim​f(x)g(x) eg(x)ln⁡f(x)=e^{g(x)\\ln f(x)}= eg(x)lnf(x)= 总之，就是要推柿子为除法形式 # examples lim⁡x→+∞ex(1+1x)x2=1\\lim_{x\\to +\\infty}{e^x\\over {(1+{1\\over x})^{x^2}}}=1 x→+∞lim​(1+x1​)x2ex​=1 lim⁡x→+∞ex−x2ln⁡(1+1x)\\lim_{x\\to +\\infty} e^{x-x^2\\ln(1+{1\\over x})} x→+∞lim​ex−x2ln(1+x1​) 令 t=1xt={1\\over x}t=x1​ ans=e12ans=e^{1\\over 2}ans=e21​ 2. lim⁡x→+∞xln⁡(x+ax−a)=ln⁡(x+ax−a)1x=2a\\lim_{x\\to +\\infty}x\\ln({x+a\\over x-a})={\\ln({x+a\\over x-a})\\over{1\\over x}}=2a x→+∞lim​xln(x−ax+a​)=x1​ln(x−ax+a​)​=2a or 把 x 放进 ln 然后是常用模型 3. lim⁡x→0+(cot⁡x−1x)=xcos⁡x−sin⁡xx2=−xsin⁡x2x=0\\lim_{x\\to 0^+}(\\cot x -{1\\over x})={x\\cos x-\\sin x\\over x^2}= {-x\\sin x\\over 2x}=0 x→0+lim​(cotx−x1​)=x2xcosx−sinx​=2x−xsinx​=0 lim⁡x→0+sin⁡xx=lim⁡x→0exln⁡sin⁡x=1\\lim_{x\\to 0^+} \\sin x^x={\\lim_{x\\to 0}e^{x\\ln\\sin x}}=1 x→0+lim​sinxx=x→0lim​exlnsinx=1 ∀i,ai&gt;0lim⁡x→0(∑aixn)1x\\forall i, a_i &gt; 0 \\lim_{x\\to 0}({\\sum a_i^x\\over n})^{1\\over x} ∀i,ai​&gt;0x→0lim​(n∑aix​​)x1​ 数列极限不可使用洛必达法则，但可利用海涅定理置换为函数然后随便做 lim⁡n→∞(ntan⁡1n)n2\\lim_{n\\to \\infty} (n\\tan {1\\over n})^{n^2} n→∞lim​(ntann1​)n2 =lim⁡n→∞(1+tan⁡tt−1)1t2=\\lim_{n\\to \\infty}(1+{\\tan t\\over t}-1)^{1\\over t^2} =n→∞lim​(1+ttant​−1)t21​ \\color{red}\\texttt lim⁡n→∞n2(arctan⁡an−arctan⁡an+1)(a&gt;0)\\lim_{n\\to \\infty}n^2(\\arctan{a\\over n}-\\arctan{a\\over n+1}) (a&gt;0) n→∞lim​n2(arctanna​−arctann+1a​)(a&gt;0) 只能说要嗯做…\\color{blue}\\texttt{只能说要嗯做…}只能说要嗯做… 妙解？大力算出括号内 比方说 arctan⁡an=x,arctan⁡an+1=y\\arctan {a\\over n} = x,\\arctan {a\\over n+1}=y arctanna​=x,arctann+1a​=y 那么有 $$\\tan x = {a\\over n},\\tan y={a\\over n+1}$$ $$x-y = \\arctan &#123;a\\over a^2+n^2+1&#125;$$ tan(x−y)=tan⁡x−tan⁡y1+tan⁡x×tan⁡y=an−an+11+an×an+1=aa2+n2+1\\color{red} tan (x-y)={\\tan x-\\tan y\\over 1+\\tan x\\times \\tan y}={ {a\\over n} - {a\\over n+1} \\over 1+ {a\\over n} \\times {a\\over n+1} } ={a\\over a^2 + n^2 + 1} tan(x−y)=1+tanx×tanytanx−tany​=1+na​×n+1a​na​−n+1a​​=a2+n2+1a​ lim⁡n→∞n2arctan⁡aa2+n2+1=lim⁡n→∞an2n2+a2+1=a\\lim_{n\\to\\infty}n^2\\arctan {a\\over a^2+n^2+1}=\\lim_{n\\to\\infty}{an^2\\over n^2+a^2+1}=a n→∞lim​n2arctana2+n2+1a​=n→∞lim​n2+a2+1an2​=a f(x)f(x)f(x) 可二阶导，且\\lim_{x\\to 0}{f(x)\\over x}=0,f’(0)=4,\\lim_{x\\to 0}[1+{f(x)\\over x}]^ # 2024-11-6 # Taylor Expansion Δy=f’(x)Δx+o(Δx)\\Delta y= f’(x)\\Delta x + o(\\Delta x) Δy=f’(x)Δx+o(Δx) f(x)=f(x0)+f’(x0)(x−x0)+…+f(n)(x0)n!(x−x0)n+Rn(x)f(x)=f(x_0)+f’(x_0)(x-x_0)+…+{f^{(n)}(x_0)\\over n! }(x-x_0)^n+R_n(x) f(x)=f(x0​)+f’(x0​)(x−x0​)+…+n!f(n)(x0​)​(x−x0​)n+Rn​(x) 其中 Rn(x)=o[(x−x0)n](x→x0)R_n(x)=o[(x-x_0)^n] (x\\to x_0)Rn​(x)=o[(x−x0​)n](x→x0​) Proof 构造 g(x)g(x)g(x) 直接相减，然后大力洛必达，一直洛到发现导数定义 又，nnn 阶 poly 不带余项展开 唯一的！ 可实现求导与间接的代换？ 泰勒中值定理：若函数f(x)f(x)f(x) 在x0x_0x0​ 点某个开区间(a,b)(a,b)(a,b) 内具有直到n+1n+1n+1 阶导数，则对于任意x∈(a,b)x\\in (a,b)x∈(a,b) f(x)=f(x0)+f’(x0)(x−x0)f(x)=f(x_0)+f’(x_0)(x-x_0) f(x)=f(x0​)+f’(x0​)(x−x0​) # example 函数展开为泰勒公式直接与间接法 (1+x)−1=1−x+x2−x3(1+x)^{-1}=1-x+x^2-x^3 (1+x)−1=1−x+x2−x3 Q: 拉格朗日余项和皮亚诺余项有何区别？？？ 精确性 # probs e−x2=1−x2+x42+…+(−1)kx2kk!+o(x2k+2)e ^{-x^2}=1-x^2+{x^4\\over 2}+…+(-1)^{k}{x^{2k}\\over k!}+o(x^{2k+2}) e−x2=1−x2+2x4​+…+(−1)kk!x2k​+o(x2k+2) nia，直接把 exe^xex 展开换成 x2x^2x2 即可 ln⁡(2−3x+x2)=ln⁡(1+(1−3x+x2))=(1−3x+x2)−(1−3x+x2)22\\ln (2-3x+x^2)= \\ln (1 + (1-3x + x^2) )= (1-3x + x^2)-{(1-3x + x^2)^2\\over 2} ln(2−3x+x2)=ln(1+(1−3x+x2))=(1−3x+x2)−2(1−3x+x2)2​ 有点唐了 ln⁡(2−x)(1−x)=ln⁡(2−x)+ln⁡(1−x)=ln⁡2+ln⁡(1−x2)+ln⁡(1−x)\\ln (2-x)(1-x)=\\ln(2-x)+ \\ln (1-x)=\\ln2 + \\ln (1-{x\\over 2})+\\ln (1-x) ln(2−x)(1−x)=ln(2−x)+ln(1−x)=ln2+ln(1−2x​)+ln(1−x) 两项相加即可 Key: 找到基本的形式，即含xxx 的项好幂 # application 极限题直接 tm 展开 注意一般展开到 o(除数)o(除数)o(除数) 即可 误差估计（带精度） 3. 求 tm 的导数 x2ln⁡(1+x)=x2(x−x22+x33−…)x^2\\ln (1+x) = x^2 (x - {x^2\\over 2} + {x^3\\over 3}-…) x2ln(1+x)=x2(x−2x2​+3x3​−…) 注意到，相当于移位，求 100 阶导取 98 项即可 所以是 −198=y’100!{-1\\over 98}={y’\\over 100!} 98−1​=100!y’​ y’=−97!×9900y’=-97!\\times 9900 y’=−97!×9900 就 tm 嗯做即可！！！ 还 tm 有证明题 4.1 若 f(x)f(x)f(x) 在 [a,b][a,b][a,b] 上有二阶导数，f‘(a)=f’(b)=0f‘(a)=f’(b) = 0f‘(a)=f’(b)=0，∃ϵ∈(a,b),\\exists \\epsilon \\in (a,b),∃ϵ∈(a,b), 使得 f’(ϵ)≥4(b−a)2∣f(b)−f(a)∣f’(\\epsilon) \\ge {4\\over (b-a)^2} |f(b)-f(a)| f’(ϵ)≥(b−a)24​∣f(b)−f(a)∣ 注意到，证明题容易注意到，不做了… 4.2 # 利用导数判断函数性质 (sin⁡xxcos⁡x3)({\\sin x \\over x\\sqrt[3]{\\cos x}}) (x3cosx​sinx​) md，波波告诉我们，嗯导就完了。","categories":[{"name":"Notes","slug":"Notes","permalink":"http://odalys8191.github.io/categories/Notes/"}],"tags":[]},{"title":"X501 行话合集","slug":"X501-行话合集","date":"2023-06-14T13:31:30.000Z","updated":"2023-06-14T14:19:02.082Z","comments":true,"path":"Article/X501-行话合集/cm34e3w5z004l5vtn3vw443em/","link":"","permalink":"http://odalys8191.github.io/Article/X501-%E8%A1%8C%E8%AF%9D%E5%90%88%E9%9B%86/cm34e3w5z004l5vtn3vw443em/","excerpt":"","text":"听说班级毕业典礼机房有概率要表演群口相声。 不如总结一下，顺便附上典故！ 黑话 含义 典故 hm how much 的缩写，最早用于考试时查询群友考试得分，后泛化为对所有有关数字问题向群友征集意见 不知道是哪个小天才在一次考试中发明，后广为流传 wrud what are u doing 的缩写，前信息组 whk 期间经常使用 为 退役狗狗窝 之狗窝领主 zcdh 引进并广为流传 8 表强烈反对。影响力极大的信息组糟粕文化！ 由 8er zcdh 发明，饱受诟病 好的 虚词，无实义。魔怔时代的特定产物。 由魔怔人 zzm 发明，魔怔到我与 zzm 只发好的连续一周实现了火花！ qhl 的奇思妙想 小山重叠金明灭，阿瓦达索命一样的绿，很多，但都是信息组糟粕文化（ 多见于 qhl 的草稿纸，由于所含颇多让我们赞叹小山先生的智慧。/yqq qhl /qq 1/0 1 表赞同等肯定含义，0 表反对等否定含义 1=true,0=false 咯 whk 文化课 /yqq /qq 十分厉害的连招 to be continue…","categories":[{"name":"Article","slug":"Article","permalink":"http://odalys8191.github.io/categories/Article/"}],"tags":[]},{"title":"他山之玉","slug":"他山之玉","date":"2022-06-14T13:26:52.000Z","updated":"2023-06-14T13:28:21.259Z","comments":true,"path":"Article/他山之玉/cm34e3w8300g25vtnflot50mn/","link":"","permalink":"http://odalys8191.github.io/Article/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%8E%89/cm34e3w8300g25vtnflot50mn/","excerpt":"","text":"# 他山之玉，可以雕石 # –再读余光中并不逍遥的《逍遥游》有感 在我初读余光中的逍遥游时，我还只是一个初三的小朋友，并无太多文化基础的我，只是深深叹服于先生沉郁悲切的情感中。如今拥有了更多诗词积累的我，再读此篇散文时，对其技法及所带来的语言魅力感到十分震撼，故略整理总结一部分他山之玉用以雕琢我的石头。 化用艺术 我们在写作文时，往往需要化用一些典故诗句，用以达到 “造境” 的效果，即利用一些文化人众所周知的事物，调动读者产生特定的情感。更为高级的，是利用化用语句与当前文段进行对比、双关。但我们往往只会在段首写 “xx 说”，然后直接蒯过来再进行翻译。这种方式生硬、缺乏浑然天成之感，而余光中则采用一系列技巧规避了这些些问题。 1. 引用后对其意象进行重定义，重构逻辑结构以带入自己文章之节奏。 ① “谁谓河广，一苇杭之。招商局的吨位何止一苇，奈何河广如是，浅浅的海峡隔绝如是。” ② “人人尽说江南好，游人只合江南老，今人竟羡古人能老于江南，江南可哀，可哀的江南。” ①引用 “谁谓河广，一苇杭之。”《诗经》中游子思归之情溢于言表，紧接着将 “现如今台湾大陆隔绝” 对应关联诗句，可见对比。②句引用韦庄《菩萨蛮五首》，韦庄因战乱寓居于江南难以自处。余光中顺着感叹，今人羡古人，昔人难以流连的江南却是今人难以回去之处，反映更深层次的悲哀。由此观之，引用后我们使用特征词语与诗句产生逻辑关联，就可使诗句自然地嵌入我们的文章中，更可借古造境，交相呼应。 2. 裁剪特征词语独立造句。 ①“当你的情人已改名玛丽，你怎能送她一首《菩萨蛮》？” ②“摩天三十六层楼，我将在哪一层朗吟《登楼赋》？可想到，及最高的一层，也眺不到长安？” ③ “封闭在其中的，是沦陷区的岁月、抗战的岁月，仓皇南奔的岁月，行路难的记忆，逍遥游的幻想。” ①②句效果类似。①将象征外来文化的 “玛丽” 与象征中国古典文化的 “菩萨蛮” 来形成对比，反映作者对于古典文化式微的悲凉无力。②由现代摩天楼与古人《登楼赋》产生对比，突出历史与现代的矛盾，对于古老文化的神往。③句名词叠用，颇有几分 “枯藤老树昏鸦” 的白描之感，更为精妙的是行路难、逍遥游一语双关，既可讲现实中的 “行路难”，在困境中渴望 “逍遥游”，又可做诗歌名字，讲余光中在离乱中成长，对这两篇古文由小到大的钦慕。 3. 古诗新译。 *①*“桐油灯的昏焰下，背新诵的古文，向鬓犹未斑的父亲，向扎鞋底的母亲，伴着瓦上急骤的秋雨急骤的灌肥巴山的秋池。” *②*“知晦朔的朝菌最可悲！” *③*“长风破浪，云帆可济沧海，沧海的彼岸，是雪封的思乡症。” 明眼人可看出这是将 “巴山夜雨涨秋池”，“朝菌不知晦朔”，“长风破浪会有时，直挂云帆济沧海” 进行了重译。但需要注意的是重译不是简单的翻译，我们得让读者看得出来原诗句是什么。余光中不失原味的秘诀是基本保留名词，对动词使用修辞或删减，我在模仿余光中先生《听听那冷雨》时想用同样的技巧。“碧绿的湖面光滑如镜，延伸到视野的尽头与浅蓝的天空相接，舟中的旅人一时分不清船行水上还是天边，便引着雨点滴落湖面的翠响安然入眠。” 其实很难看出我是想引用 “春水碧于天，画船听雨眠” 的。但严重失真的原因在于本市的原名词并没有原样保留。故我们想要引用一句古诗时，可以摘取其中特征名词对动词、逻辑关联进行修饰或颠覆。 余光中的《逍遥游》，从语言上我认为是一篇漂亮的炫技之作。除了上述的化用艺术，我认为其句式标点，中文历史感与现代生活对比等多个方向存在着更多值得琢磨的的地方，但囿于时间所限，只好将其置于下方，强烈推荐大家阅读！ 附：《逍遥游》余光中 如果你有逸兴作太清的逍遥游行，如果你想在十二宫中缘黄道而散步，如果在蓝石英的幻境中你欲冉冉升起，蝉蜕蝶化，遗忘不快的自己，总而言之，如果你不幸患上，如果你不幸患了 “观星癖” 的话，则今夕，偏偏是今夕，你竟不能与我并观神话之墟，实在是太可惜太可惜了。 我的观星，信目所之，纯然是无为的。两睫交瞬之顷，一瞥往返大千，御风而行，泠然善也，泠然善也。原非古代的太史，若有什么冒失的客星，将毛足加诸皇帝的隆腹，也不用我来烦心。也不是原始的舟子，无须在雾气弥漫的海上，裂眦辨认北极的天蒂。更非现代的天文学家或太空人，无须分析光谱或驾驶卫星。科学向太空看，看人类的未来，看月球的新殖民地，看地球人与火星人不可思议的星际战争。我向太空看，看人类的过去，看占星学与天宫图，祭司的梦，酋长的迷信。 于是大度山从平地涌起，将我举向星际，向万籁之上，霓虹之上。太阳统治了钟表的世界。但此地，夜犹未央，光族在钟表之外闪烁。亿兆部落的光族，在令人目眩的距离，交射如是微渺的清辉。半克拉的孔雀石。七分之一的黄玉扇坠。千分之一克拉的血胎玛瑙。盘古斧下的金刚石矿，天文学采不完万分之一。天河蜿蜒着敏感的神经，首尾相衔，传播高速而精致的触觉，南天穹的星阀热烈而显赫地张着光帜，一等星、二等星、三等星，争相炫耀他们的家谱，从 Alpha 到 Beta 到 Zeta 到 Omega，串起如是的辉煌，迤逦而下，尾扫南方的地平。亘古不散的假面舞会，除倜傥不羁的彗星，除爱放烟火的陨星，除垂下黑面纱的朔月之外，星图上的姓名全部亮起。后羿的逃妻所见如此。自大狂的李白，自虐狂的李贺所见如此。利玛窦和徐光启所见亦莫不如此。星象是一种最晦涩的灿烂。 北天的星貌森严而冷峻，若阳光不及的冰柱。最壮丽的是北斗七星。这局棋下得令人目摇心悸，大惑不解。自有八卦以来，任谁也挪不动一只棋子，从天枢到瑶光，永恒的颜面亿代不移。棋局未终，观棋的人类一代代死去。惟北有斗，不可以挹酒浆。圣人以前，诗人早有这狂想。想你在平旷的北方，巍峨地升起，阔大的斗魁上斜着偌长的斗柄，但不能酌一滴饮早期的诗人。那是天真的时代，圣人未生，青牛未西行。那是青铜时代，云梦的瘴疠未开，鱼龙遵守大禹的秩序，吴市的吹箫客白发未白。那是多神的时代，汉族会唱歌的时代，摽有梅野有蔓草，自由恋爱的时代。快乐的 Pre-Confucian 的时代。 百仞下，台中的灯网交织现代的夜。湿红流碧，林阴道的彼端，霓虹茎连的繁华。脚下是，不快乐的 Post-Confucian 的时代。凤凰不至，麒麟绝迹，龙只是观光事业的商标。八佾在龙山寺凄凉地舞着。圣裔饕餮着国家的俸禄。龙种流落在海外。诗经蟹行成英文。谁谓河广，一苇杭之。招商局的吨位何止一苇，奈何河广如是，浅浅的海峡隔绝如是！人人尽说江南好，游人只合江南老。今人竟羡古人能老于江南。江南可哀，可哀的江南。惟庾信头白在江南之北，我们头白在江南之南。嘉陵江上，听了八年的鹧鸪，想了八年的后湖，后湖的黄鹂。过了十五个台风季，淡水河上，并蜀江的鹧鸪亦不可闻。帝遣巫阳招魂，在海南岛上，招北宋的诗人。“魂兮归来，南方不可以止些！” 这里已是中国的至南，雁阵惊寒，也不越浅浅的海峡。雁阵向衡山南下。逃亡潮冲击着香港。留学女生向东北飞，成群的孔雀向东北飞，向新大陆。有一种候鸟只去不回。 怒而飞，其翼若垂天之云，抟扶摇而上者九万里。喷射机在云上滑雪，多逍遥的游行！曾经，我们也是泱泱的上国，万邦来朝，皓首的苏武典多少属国。长安矗第八世纪的纽约，西来的驼队，风沙的软蹄踏大汉的红尘。曾几何时，五陵少年竟亦洗碟子，端菜盘，背负摩天楼沉重的阴影。而那些长安的丽人，不去长堤，便深陷书城之中，将自己的青春编进洋装书的目录。当你的情人已改名玛丽，你怎能送她一首菩萨蛮？历史健忘，难为情的，是患了历史感的个人。三十六岁，常怀千万的忧愁。千岁前，宋朝第一任天子刚登基，黄袍犹新，一朵芬芳的文化欲绽放。欧洲在深邃的中世纪深处冬眠，拉丁文的祈祷有若梦呓。知晦朔的朝菌最可悲。八股文。裹脚巾。阿 Q 的辫子。鸦片的毒氛。租界流满了惨案流满了租界。大国的青睐翻成了白眼。小国反复着排华运动。朝菌死去，留下更阴湿的朝菌，而晦朔犹长，夜犹未央。东方的大帝国纷纷死去。巴比伦死去。波斯和印度死去。亚洲横陈史前兽的遗骸，考古家的乐园是广墟。南有冥灵，以五百岁为春，五百岁为秋。惠蛄啊惠蛄，我们是阅历春秋的惠蛄。不，我们阅历的，是战国，是军阀，是太阳旗，是弯弯的镰刀如月。 夜凉如浸，虫吟似泣。星子的神经系统上，挣扎着许多折翅的光源，如果你使劲拧天蝎的毒尾，所有的星子都会呼痛。但那只是一瞬间的幻觉罢了。天苍苍何高也，绝望的手臂岂得而扪之？永恒仍然在拍打密码，不可改不可解的密码，自补天自屠日以来，就写在那上面，那种磷质的形象！似乎在说：就是这个意思。不周山倾时天柱倾时是这个意思。长城下，运河边是这个意思。扬州和嘉定的大屠城是这个意思。卢沟桥上，重庆的山洞里，莫非是这个意思。然则御风飞行，泠然善乎，泠然善乎？然则孔雀东北飞，是逍遥游乎，是行路难乎？曾经，也在密西西比的岸边，一座典型的大学城里，面对无欢的西餐，停杯投叉，不能卒食。曾经，立在密歇根湖岸的风中，看冷冷的日色下，钢铁的芝城森寒而黛青。日近，长安远。迷失的五陵少年，鼻酸如四川的泡菜。曾经啊，无寐的冬夕，立在雪霁的星空下，流泪想刚死的母亲，想初出世的孩子。但不曾想到，死去的不是母亲，是古中国，初生的不是女婴，是五四。喷射机两日的航程，感情上飞越半个世纪。总是这样。松山之后是东京之后是阿拉斯加是西雅图。上有青冥之长天，下有渌水之波澜。长风破浪，云帆可济沧海，行路难。行路难。沧海的彼岸，是雪封的思乡症，是冷冷清清的圣诞，空空洞洞的信箱和更空洞的学位。 是的，这是行路难的时代。逍遥游，只是范蠡的传说。东行不易，北归更加艰难。兵燹过后，江南东北，可以想见有多荒凉。第二度去国的前夕，曾去佛寺的塔影下祭告先人的骨灰。锈铜钟敲醒的记忆里，二百根骨骼重历六年前的痛楚。六年了！前半生的我陪葬在这小木匣里。我生在王国维投水的次年。封闭在此中的，是沦陷区的岁月，抗战的岁月，仓皇南奔的岁月，行路难的记忆，逍遥游的幻想。十岁的男孩，已经咽下了国破的苦涩。高淳古刹的香案下，听一夜妇孺的惊呼和悲啼。太阳旗和游击队拉锯战的地区，白昼匿太湖的芦苇丛中，日落后才摇橹归岸，始免于锯齿之噬。舟沉太湖，母与子抱宝丹桥础始免于溺死。然后是上海的法租界。然后是香港海上的新年。滇越路的火车，览富良江岸的桃花。高亢的昆明。险峻的山路。母子颠簸成两条黄鱼。然后是海棠溪的渡船，重庆的团圆。月圆时的空袭，迫人疏散。于是六年的中学生活开始，草鞋磨穿，在悦来场的青石板路。令人涕下的抗战歌谣。令人近视的教科书和油灯。桐油灯的昏焰下，背新诵的古文，向鬓犹未斑的父亲，向扎鞋底的母亲，伴着瓦上急骤的秋雨急骤地灌肥巴山的秋池…… 钟声的余音里，黄昏已到寺，黑僧衣的蝙蝠从逝去的日子里神经质地飞来。这是台北的郊外，观音山已经卧下来休憩。 栩栩然梦蝶。蘧蘧然庄周。巴山雨，台北钟。巴山夜雨。拭目再看时，已经有三个小女孩喊我父亲。熟悉的陌生，陌生的变成熟悉。千级的云梯下，未完的出国手续待我去完成。将有远游。将经历更多的关山难越，在异域。又是松山机场的挥别，东京御河的天鹅，太平洋的云层，芝加哥的黄叶。六年后，北太平洋的卷云，犹卷着六年前乳色的轻罗。初秋的天一天比一天高。初秋的云，一片比一片白净比一片轻。裁下来，宜绘唐寅的扇面，题杜牧的七绝。且任它飞去，且任它羽化飞去。想这已是秋天了，内陆的蓝空把地平线都牧得很辽很远。北方的黄土平野上，正是驰马射雕的季节。雕落下。萧萧的红叶红叶啊落下，自枫林。于是下面是冷碧零丁的吴江。于是上面，只剩下白寥寥的无限长的楚天。怎么又是九月又是九月了呢？木兰舟中，该有楚客扣舷而歌，“悲哉秋之为气也，栗兮若在远行！” 远行。远行。念此际，另一个大陆的秋天，成熟得多美丽。碧云天。黄叶地。爱荷华的黑土沃原上，所有的瓜该又重又肥了。印第安人的落日熟透时，自摩天楼的窗前滚下。当暝色登高楼的电梯，必有人在楼上忧愁。摩天三十六层楼，我将在哪一层朗吟登楼赋？可想到，即最高的一层，也眺不到长安？当我怀乡，我怀的是大陆的母体，啊，诗经中的北国，楚辞中的南方！当我死时，愿江南的春泥覆盖在我的身上，当我死时。 当我死时。当我生时。当我在东南的天地间漂泊。战争正在海峡里焚烧。饿殍和冻死骨陈尸在中原。黄巾之后有董卓的鱼肚白有安禄山的鱼肚白后有赤眉有黄巢有白莲。始皇帝的赤焰们在高呼，战神万岁！战争燃烧着我们，燃烧着你们的髯发我们的眉睫。当我死时，老人星该垂下白髯，战火烧不掉的白髯，为我守坟。吾所以有大患者，为吾有身。当我物化，当我归彼大荒，我必归彼芥子归彼须弥归彼地下之水空中之云。但在那之前，我必须塑历史，塑自己的花岗石面，当时间在我的呼吸中燃烧。当我的三十六岁在此刻燃烧在笔尖燃烧在创造创造里燃烧。当我狂吟，黑暗应匍匐静听，黑暗应见我髯发奋张，为了痛苦地欢欣地热烈而又冷寂地迎接且抗拒时间的巨火，火焰向上，挟我的长发挟我如翼的长发而飞腾。敢在时间里自焚。必在永恒里结晶。 惟北有斗，不可以挹酒浆。有一种疯狂的历史感在我体内燃烧，倾北斗之酒亦无法浇熄。有一种时间的乡愁无药可医。台中的夜市在山麓奇幻地闪烁，紫水晶的盘中眨着玛瑙的眼睛。相思林和凤凰木外，长途巴士沉沉地自远方来，向远方去，一若公路起伏的鼾息。空中弥漫着露滴的凉意，和新割过的草根的清香。当它沛沛然注入肺叶，我的感觉遂透彻而无碍，若火山脚下，一块纯白多孔的浮石。清醒是幸福的。未来的大劫中，惟清醒可保自由。星空的气候是清醒的秩序。星空无限，大罗盘的星空啊，创宇宙的抽象大壁画，玄妙而又奥秘，百思不解而又百读不厌，而又美丽得令人绝望地赞叹。天河的巨瀑喷洒而下，蒸起螺旋的星云和星云，但水声渺永不可闻。光在卵形的空间无休止地飞啊飞，在天河的漩涡里作星际航行，无所谓现代，无所谓古典，无所谓寒武纪或冰河时期。美丽的卵形里诞生了光，千轮太阳，千只硕大的蛋黄。美丽的卵形诞生了我，亦诞生后稷和海伦。七夕已过，织女的机杼犹纺织多纤细的青白色的光丝。五千年外，指环星云犹谜样在旋转。这婚礼永远在准备，织云锦的新娘永远年轻。五千年前，我的五立方的祖先正在昆仑山下正在黄河源濯足。然则我是谁呢？我是谁呢？呼声落在无回音的，岛宇宙的边陲。我是谁呢？我 —— 是 —— 谁？一瞬间，所有的光都息羽回顾，猬集在我的睫下。你不是谁，光说，你是一切。你是侏儒中的侏儒，至小中的至小。但你是一切。你的魂魄烙着北京人全部的梦魇和恐惧。只要你愿意，你便立在历史的中流。在战争之上，你应举起自己的笔，在饥馑在黑死病之上。星裔罗列，虚悬于永恒的一顶皇冠，多少克拉多少克拉的荣耀，可以为智者为勇者加冕，为你加冕。如果你保持清醒，而且屹立得够久。你是空无。你是一切。无回音的大真空中，光，如是说。","categories":[{"name":"Article","slug":"Article","permalink":"http://odalys8191.github.io/categories/Article/"}],"tags":[{"name":"奇怪周记","slug":"奇怪周记","permalink":"http://odalys8191.github.io/tags/%E5%A5%87%E6%80%AA%E5%91%A8%E8%AE%B0/"}]},{"title":"生与梦","slug":"生与梦","date":"2022-04-17T03:36:35.000Z","updated":"2023-06-14T13:19:46.722Z","comments":true,"path":"Article/生与梦/cm34e3w6800575vtn8xg4em59/","link":"","permalink":"http://odalys8191.github.io/Article/%E7%94%9F%E4%B8%8E%E6%A2%A6/cm34e3w6800575vtn8xg4em59/","excerpt":"","text":"# 生与梦 ​ 再读张岱的小品文《陶庵梦忆》，透过浸润着墨香与真情的纸面，我仿佛来到一方矮矮的小坟前，轻轻抚摸那满是记忆灰尘的石碑，古雅轻灵的《自为墓志铭》小字清晰可见。“少为纨绔子弟，极爱繁华，好精舍，好美婢，好…… 劳碌半生，皆成梦幻。” 他的一生，以花团锦簇起笔，又以寒烟碧草修笔。他生于世家大族，显赫的家世使他可以不拘泥于功名利禄；良好的家学，又使他在斗鸡跑马之余，多了几分雅趣与风骨。所以当张岱行至半生，清军入关，鞑虏的铁蹄踏碎他的绮丽奢靡之时，他选择走入山林，行沮溺故事，在破床旧几之间将前半生的繁盛娓娓道来。 ​ 他的故事令我唏嘘感慨不已，人生变幻无常，仿佛不经意间便会跃起又落下。而倘若停下片刻屏息敛神朝着过往生命进行观照，过往那些或对或错或悔或憾的决策，那些欢笑与泪水都仿佛昨日刚刚发生，过往看似漫长或晦暗的岁月，就好像飞鸿踏过皑皑的白雪，只留一些细小的爪印，却不见飞鸿的踪影。而现在或将来，则好似一片镜花水月，飘渺而不可及…… 让人不由思索，如何度过这如梦般光影纵横的一生。 ​ 不妨放眼不同的时空，看看不同的心灵是如何捱过着同样的困惑的：魏晋名士们放纵情感与欲望，浪漫的追逐着生命的欢愉，体验着无意义的茫然：穷途而哭，痛饮狂歌，发泄着绚烂的悲恸与奔涌的真情；希腊悲剧中迷狂的酒神精神，对生命的肯定也大抵如是；不同宗教的信仰者们，将怀疑与茫然凝练为信仰，封闭内心感官，遁世苦思。 ​ 而在现在，形形色色的社会新闻刷新着各个行业的底线，有人说，这是礼崩乐坏的新春秋；接连不断的局部热战，波光诡谲的国际政局，有人说，这是蠢蠢欲动的新战国…… 身立于兹，当一日的太阳落下，第二天冉冉升起的是一个新太阳，还是三体人的飞船，似乎都不让人感到意外。而如何在这似生似梦的远方行走，十分遗憾的是笔者囿于自身水平，并不能给出一个普适的答案，那便循着加缪所言，假定西西福斯是幸福的，勇敢地建构着人生的意义，感受肌肉在向上推动石块中暴起的青筋与蓬勃而生的力量，即使石块坠落仍能淡笑着从容往下走，去正视，去嘲弄，那如果存在的话，高高在上的织梦人吧。","categories":[{"name":"Article","slug":"Article","permalink":"http://odalys8191.github.io/categories/Article/"}],"tags":[]},{"title":"联考好题集锦","slug":"联考好题集锦","date":"2022-03-06T05:20:16.000Z","updated":"2022-03-06T05:21:26.161Z","comments":true,"path":"Test/联考好题集锦/cm34e3w6a005h5vtn3fgy0lsl/","link":"","permalink":"http://odalys8191.github.io/Test/%E8%81%94%E8%80%83%E5%A5%BD%E9%A2%98%E9%9B%86%E9%94%A6/cm34e3w6a005h5vtn3fgy0lsl/","excerpt":"","text":"# 考试题 # 2022-0221 yyl 考虑带权重心的条件，其子树和一定要大于等于 ⌊sum2⌋\\lfloor {sum\\over 2} \\rfloor⌊2sum​⌋ ，这是因为要考虑其父亲的那棵树。 然后要求深度最小的重心，也就是严格大于⌊sum2⌋\\lfloor {sum\\over 2} \\rfloor⌊2sum​⌋ 考虑把树拍平到 dfn 上，则 dfn 序列上的带权中点一定在重心的子树内。 于是直接倍增即可。 # 2022-0221 dfs 十分有意思的做法完全忘记了… 考虑 nnn 个点至多 n2n\\over 22n​ 个匹配，且每个点度数不超过 111 ，考虑在所有 2i,2i+12i,2i+12i,2i+1 之间连上一条边，这样每个点度数就不超过 222 了，形成了若干环和链。 考虑我们已知信息中 2i,2i+12i,2i+12i,2i+1 是一定连在一起的，于是把他们看成一个点，dpdpdp 统计连成的环和链的个数。 dpdpdp 大概是，两个状压，然后因为要保证不算重，所以要钦定此时链 / 环内最大的元素，合并答案就做个枚举子集就好了。 因为合并了点，所以复杂度是 O(2n2)\\mathrm O(2^{n\\over2})O(22n​) 乘上一些东西的。 # 2022-0222 game 每个人希望自己走的比另一个人多走几步 预处理从每个点出发，能比别人多走几步 预处理十分玄妙，也可以看做一个 dp 123foR (u, n, 1) for (auto v : to[u]) if (col[u] == col[v]) ckmax(res[u], res[v] + 1); else ckmax(res[u], (!res[v]) ? 1 : 0); 背包合并即可 # 2022-0222 perm nb 题 先转换一步限制，任意区间内，不能存在 (a,b),(a,c)(a,b),(a,c)(a,b),(a,c) 而不存在 (b,c)(b,c)(b,c) 。 你看这个二元组的排列，十分不好看，于是你看做一条条边。 限制就相当于是任意区间内的边拿出来具有传递性。 任意区间内限制不好满足，但发现区间 [l,r][l,r][l,r] 满足传递性其实只要保证 [1,r],[l,n][1,r],[l,n][1,r],[l,n] 满足就好，也就是只要保证每个前缀满足，每个后缀满足就好。 也就是对于一个前缀建图，它的补图也满足具有传递性就好。 一个 DAG ，本身与补图都具有传递性，这样的图是不多的，只有 n!n!n! 个，原因是你可以把每个排列与一张这样的图做一个双射关系，大概是你拿出一个排列来，对于每个逆序对连边，因为两两偏序关系唯一，发现这样的图就是满足本身与补图都具有传递性的， 然后你就可以对于每个排列 dp 了，使用康拓展开给排列编号，从逆序对小的转移到逆序对大的，每次转移新加一条边，也就是找到一个 pi&lt;pi+1p_i&lt;p_{i+1}pi​&lt;pi+1​ 将其交换，根据逆序对的性质我们知道这恰好变化 111 。 复杂度 O(n!n)\\mathrm O(n!n)O(n!n) 。 # 2022-0224 藏弓待用 。。。套路题不想讲 记下来是因为这是我搬过的一道题，但赛时转换错了一个 “经典模型” 自闭了一场。。。最后 10min 才冲出来 分块优化 ddp # 2022-0224 山泽麟迹 先考虑一个柿子： E(u)=P×E(las)+(1−P)1∣s∣∑E(v)+1E(u)=P\\times E(las) +(1-P){1\\over |s|}\\sum E(v) +1 E(u)=P×E(las)+(1−P)∣s∣1​∑E(v)+1 暴力高消可以获得？分 由于这是棵树，在树上有明显的序，考虑 uuu 时，vvv 已经算出，把 E(u)E(u)E(u) 看做 y=kE(fa)+by=kE(fa)+by=kE(fa)+b 的形式，原柿化为： E(u)=P×E(fa)+(1−P)1∣s∣∑(kE(u)+b)E(u)=P\\times E(fa) +(1-P){1\\over|s|}\\sum (kE(u)+b) E(u)=P×E(fa)+(1−P)∣s∣1​∑(kE(u)+b) 手玩一下即可。 # 2022-0224 降众天华 随便选个点，每个点到他得到若干向量 把向量看成高斯整数 gcd 后，发现可以构造一个方阵是的两边的基底是 gcd,igcdgcd,igcdgcd,igcd ，于是每组向量除 gcd 得到最大最小值，得到长宽 # 2022-0225 给国与地震 发现一个显然正确的贪心，每次找一条满足条件的字典序最小的合法边加入 发现这样会 T，发现一条边若还差 sss 合法，而两边增加量 &lt;s2&lt; {s\\over 2}&lt;2s​ 他不会合法，于是给每条边设一个阈值 s2s\\over 22s​ ，搞个 setsetset 记录每个联通块出边，每次启发式合并时找到增加量达到阈值的边进行 check ，若不满足则更新阈值 # 2022-0228 排列 厉害题！ 首先期望是个假期望，乘个 n!n!n! 这个 kkk 次方不好处理，于是考虑它的组合意义，相当于是，对于所有的谷，我们在其中选择 kkk 个的方案数，可以重复选。 注意这里我们把对于每个排列贡献求和转换为了对于谷选 k 个排列方案数的求和，于是接下来的讨论我们不需要考虑没被选择的谷对于原柿子的贡献，这里笔者产生过误区 我们把被选中的谷拿出来组成一个集合，由于可以重复选，这个集合的大小是小于等于 kkk 的，我们可以 dfs 这个集合的大小，除去这个集合的用个组合数可以简单解决，dfs 时，我们每次要 dfs 一个连续谷段的大小，它的贡献是给 2q+12q+12q+1 个数字填入 2q+12q+12q+1 的序列中且满足谷性质方案数，因为 k≤5k\\le 5k≤5 ，简单爆搜可得一个表 1234562q+1:Ans3:25:167:2729:793611:353792 # 2022-03-01 寄 dp 技术不够高超所以寄了 设 fi,jf_{i,j}fi,j​ 表示 iii 节点子树内 jjj 个节点未匹配都汇聚到 iii 的最小代价，设 gi,jg_{i,j}gi,j​ 表示 iii 节点内所有节点都已匹配，从外部来的点都会在 jjj 这个中转站被解决的最小代价，fff 的转移就是 naive 的背包，ggg 的转移则考虑新加入一棵子树时，在原子树枚举一些点在新子树内被解决，在新子树枚举一些点在原子树被解决… 注意最后要用 ggg 来转移 f_ 每对点会在其 lca 被枚举到，正确性可以保证，复杂度 O(n2)\\mathrm O(n^2)O(n2) # 2022-03-01 摆 由于没什么线代基础所以摆了 考虑这个矩阵 aaa a={1 i=j0 i&lt;j∧i∣jC otherwisea=\\begin{cases}1\\ \\ {i=j}\\\\0 \\ \\ i&lt;j ∧ i|j\\\\C \\ \\ otherwise\\end{cases} a=⎩⎪⎪⎨⎪⎪⎧​1 i=j0 i&lt;j∧i∣jC otherwise​ 考虑拆成两个矩阵 b,cb,cb,c b={1−C i=j−C i&lt;j∧i∣j0 otherwiseb=\\begin{cases}1-C\\ \\ i=j\\\\-C\\ \\ i&lt;j∧i|j\\\\0\\ \\ otherwise\\end{cases} b=⎩⎪⎪⎨⎪⎪⎧​1−C i=j−C i&lt;j∧i∣j0 otherwise​ c=Cc=C c=C bbb 就是一个上三角矩阵了 然后： det(a)=det(b+c)=∑p(−1)∣p∣∏(bi,pi+ci,pi)det(a)=det(b+c)=\\sum_{p} (-1)^{|p|} \\prod(b_{i,p_i}+c_{i,p_i}) det(a)=det(b+c)=p∑​(−1)∣p∣∏(bi,pi​​+ci,pi​​) 发现 ∏(bi,pi+ci,pi)\\prod(b_{i,p_i}+c_{i,p_i})∏(bi,pi​​+ci,pi​​) 这个其实拆成每个 iii 行选择一个 b\\or v 乘在一起，其实可以理解为一些矩阵的行列式，考虑把枚举排列转换为枚举矩阵，然后原式变为： ∑Adet(A)\\sum_{A} det(A) A∑​det(A) AAA 矩阵的每一行要么是 bbb 中的一行，要么是 ccc 中的一行，发现若两行全是 ccc 的一行，det(A)=0det(A)=0det(A)=0 ，于是： Ans=(1−c)n+∑i=1n(1−c)n−1Fi,iAns=(1-c)^n+\\sum_{i=1}^n (1-c)^{n-1} F_{i,i} Ans=(1−c)n+i=1∑n​(1−c)n−1Fi,i​ 枚举哪行变成了 CCC ，则对此行高斯消元后得到的 Fi,iF_{i,i}Fi,i​ 乘上其余就是答案。 考虑如何计算 Fi,iF_{i,i}Fi,i​ ，这里我只会感性理解，大概是算 FiF_iFi​ 一行，利用 j&lt;i,j∣ij&lt;i,j|ij&lt;i,j∣i 的 FjF_jFj​ 递推，可得递推式： Fi=−C(1−C)Fj+[C,C,....C]F_i={-C \\over(1-C)} F_j +[C,C,....C] Fi​=(1−C)−C​Fj​+[C,C,....C] 设 fi=Fi,if_i = F_{i,i}fi​=Fi,i​ ，然后 fi=∑j≠i,j∣iC1−Cfj+Cf_i=\\sum_{j\\not=i,j|i} {C\\over 1-C}f_j+Cfi​=∑j=i,j∣i​1−CC​fj​+C 现在我们希望求 fif_ifi​ 的前缀和 sis_isi​ 使用杜教筛构造一个 g(g1=1,gn=CC−1)g(g_1=1,g_n={C\\over{C-1}})g(g1​=1,gn​=C−1C​) ，于是： g(1)S(n)=∑i=1n(f∗g)(i)−∑i=2ng(i)S(⌊ni⌋)g(1)S(n)=\\sum_{i=1}^n (f*g)(i)-\\sum_{i=2}^ng(i)S(\\lfloor{n\\over i}\\rfloor) g(1)S(n)=i=1∑n​(f∗g)(i)−i=2∑n​g(i)S(⌊in​⌋) 这个 ggg 构造得很好，于是： S(n)=nC−∑i=2ng(i)S(⌊ni⌋)S(n)=nC-\\sum_{i=2}^ng(i)S(\\lfloor{n\\over i}\\rfloor) S(n)=nC−i=2∑n​g(i)S(⌊in​⌋) 后面需要一个整除分块，我们还要快速预处理出一些 SSS fi=∑j≠i,j∣iC1−Cfj+Cf_i=\\sum_{j\\not=i,j|i} {C\\over 1-C}f_j+C fi​=j=i,j∣i∑​1−CC​fj​+C 观察这个柿子，发现 fif_ifi​ 只与本质不同质因子出现次数集合有关 ，比方说 6=2131,9797=97110116=2^13^1,9797=97^1101^16=2131,9797=9711011 他们的 fff 值是一样的。 于是我们为每个数字找到一个最小的 ididid ，这个线性筛时可以递推解决 然后对于更大的 SSS ，我们使用记忆化搜索递归解决。 # 2022-03-01 润 打表找规律发现奇怪的结论然后大力 ds # 2022-03-03 A 题意容易转换为选出最少的集合使得内部 gcd=1gcd = 1gcd=1 ，发现答案最多为 777 ，枚举一个集合大小 kkk 考虑容斥，设 fif_ifi​ 表示选了 kkk 个元素，其中 iii 为所有数字因数的方案数，显然等于 (cntk)\\binom{cnt}{k}(kcnt​) 其中 cntcntcnt 为 iii 的倍数在集合中的数字。 设 gig_igi​ 表示 iii 为 gcd 方案数，有容斥: gi=fi−∑i∣jgjg_i=f_i-\\sum_{i|j} g_jgi​=fi​−∑i∣j​gj​ 。 cnt,gicnt,g_icnt,gi​ 的处理都可以使用 dirclet 后缀和。 # 2022-03-04 打麻将 对于一个 lenlenlen ，将所有满足子树直径 ≥len\\ge len≥len ，而所有儿子的子树直径小于 lenlenlen 的点丢进队列，显然两两之间不会有祖先关系，每次选出一个最深的点，加入答案，删除这个点的子树，再倍增跳到第一个满足条件的位置加入队列。 这样贪心是显然对的，而删除一个点的子树，维护子树内的直径，可以使用线段树 + O1lca # 2022-03-04 线性代数 诈骗题 不要想到什么矩阵的无穷次幂是否收敛 矩阵看做邻接矩阵，无环就行","categories":[{"name":"Test","slug":"Test","permalink":"http://odalys8191.github.io/categories/Test/"}],"tags":[]},{"title":"高斯整数","slug":"高斯整数","date":"2022-02-24T13:07:00.000Z","updated":"2022-02-24T13:22:11.819Z","comments":true,"path":"Notes/高斯整数/cm34e3w6e005x5vtn6bi6a2fe/","link":"","permalink":"http://odalys8191.github.io/Notes/%E9%AB%98%E6%96%AF%E6%95%B4%E6%95%B0/cm34e3w6e005x5vtn6bi6a2fe/","excerpt":"","text":"由于完全不懂什么 # 1.Define 通俗理解，高斯整数就是实部虚部都为整数的虚数。 然后对于乘法加法满足交换律，形成一个交换环 它的模就是虚数那一套，由于完全平方数的性质，它不能表示为 4k+14k+14k+1 。 高斯整环也是欧几里得环，具有很多与整数相同的性质，于是可以辗转相除，裴蜀定理，中国剩余定理，唯一分解定理… 可以类似定义高斯素数，性质什么的就不学了 唯一分解 类似整数拉 最大公约数 两个高斯整数的 gcd 并不唯一，而是，d,−d,di,−did,-d,di,-did,−d,di,−di 1234567891011Complex div(Complex a, Complex b) &#123; long double mo = b.norm(); Complex c = a * b.conj(); long double r = 1. * c.r / mo, i = 1. * c.i / mo; return Complex(round(r), round(i));&#125;Complex gcd(Complex a, Complex b) &#123; if (b.r == 0 &amp;&amp; b.i == 0) return a; Complex c = div(a, b); return gcd(b, a - b * c);&#125; 同余和剩余系 两个高斯整数，若差是另一个高斯整数的整数倍，就称模意义下同余 这也是一种等价关系，可据此将高斯整数分为若干等价类。 鸽了，不知道有啥用。","categories":[{"name":"Notes","slug":"Notes","permalink":"http://odalys8191.github.io/categories/Notes/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://odalys8191.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"高斯整数","slug":"高斯整数","permalink":"http://odalys8191.github.io/tags/%E9%AB%98%E6%96%AF%E6%95%B4%E6%95%B0/"}]},{"title":"群论学习笔记","slug":"群论学习笔记","date":"2022-02-23T06:52:54.000Z","updated":"2022-02-23T10:15:41.106Z","comments":true,"path":"uncategorized/群论学习笔记/cm34e3w69005e5vtnbh4f9vpw/","link":"","permalink":"http://odalys8191.github.io/uncategorized/%E7%BE%A4%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/cm34e3w69005e5vtnbh4f9vpw/","excerpt":"","text":"鸽","categories":[],"tags":[]},{"title":"2022-02-15 Test","slug":"2022-2-15-Test","date":"2022-02-16T06:08:53.000Z","updated":"2022-02-16T06:41:45.751Z","comments":true,"path":"Tests/2022-2-15-Test/cm34e3w5400235vtnebf62lpw/","link":"","permalink":"http://odalys8191.github.io/Tests/2022-2-15-Test/cm34e3w5400235vtnebf62lpw/","excerpt":"","text":"# 2022-2-15 Test link sol # A 如果你注意到题面中写明的 ∣s∣≤20|s|\\le 20∣s∣≤20 你会得到直接爆 trie 的 20∑∣t∣20\\sum|t|20∑∣t∣ 做法，然后你以为你通过了此题 如果你注意到数据中写明的 ∑∣s∣≤1e5\\sum|s|\\le 1e5∑∣s∣≤1e5 你会得到一个二进制分组 + ACAM/SAM 的做法 ，然后你真的通过了此题 具体的，你维护 log\\mathrm loglog 个 ACAM ，假如此时是第 kkk 个修改后，你就把 kkk 二进制分组后每 2x2^x2x 个串插一个 ACAM 就好 由于 fail 树的奇异性质，你匹配一个模式串时，在 trie 上匹配到的 uuu 点的 fail 子树和就是它的子串权值和 合并直接重构 # B 设 G(m)G(m)G(m) 表示行两两不同，至多有 mmm 个列等价类的方案数，显然有个简洁的表达 G(m)=(cm)n‾G(m)=(c^m)^{\\underline n}G(m)=(cm)n​ 。 设 F(m)F(m)F(m) 表示恰好有 mmm 个列等价类的方案数 F(m)=∑i=0m{mi}G(i)→G(m)=∑i=0m(−1)m−i[mi]F(i)F(m)=\\sum_{i=0}^m \\begin{Bmatrix}m\\\\i\\end{Bmatrix} G(i) \\to\\\\ G(m)=\\sum_{i=0}^m (-1)^{m-i}\\begin{bmatrix}m\\\\i\\end{bmatrix}F(i) F(m)=i=0∑m​{mi​}G(i)→G(m)=i=0∑m​(−1)m−i[mi​]F(i) # C 每个数字 ≤500\\le 500≤500 ，所以大于 500\\sqrt{500}500​ 只有一个，而小于 500\\sqrt{500}500​ 只有 888 个，于是使用 dfsdfsdfs 算出前八个质数在答案中的分布，然后贪心即可。","categories":[{"name":"Tests","slug":"Tests","permalink":"http://odalys8191.github.io/categories/Tests/"}],"tags":[{"name":"trie","slug":"trie","permalink":"http://odalys8191.github.io/tags/trie/"},{"name":"AC自动机","slug":"AC自动机","permalink":"http://odalys8191.github.io/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"字符串","slug":"字符串","permalink":"http://odalys8191.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"斯特林反演","slug":"斯特林反演","permalink":"http://odalys8191.github.io/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E5%8F%8D%E6%BC%94/"},{"name":"dfs","slug":"dfs","permalink":"http://odalys8191.github.io/tags/dfs/"},{"name":"根号分治","slug":"根号分治","permalink":"http://odalys8191.github.io/tags/%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/"}]},{"title":"","slug":"反演公式","date":"2022-02-15T12:14:13.209Z","updated":"2022-02-15T12:46:11.055Z","comments":true,"path":"uncategorized/反演公式/cm34e3w65004z5vtn1d1g48ab/","link":"","permalink":"http://odalys8191.github.io/uncategorized/%E5%8F%8D%E6%BC%94%E5%85%AC%E5%BC%8F/cm34e3w65004z5vtn1d1g48ab/","excerpt":"","text":"# 反演公式不全 证个球球 还缺 min-max 容斥，单位根反演 好像莫比乌斯反演可以看做子集反演系统在因子多重集上的特例 所以莫反的技巧在子集反演上也可以用 诶我不会莫反技巧啊，那没事了 反演 ： 我们知道 f(x)f(x)f(x) 关于 g(x)g(x)g(x) 一个表达式，使用 f(x)f(x)f(x) 反推出 g(x)g(x)g(x) 的一个过程 二项式反演： f(n)=∑k=0n(nk)g(k)→g(n)=∑k=0n(−1)n−k(nk)f(k)f(n)=\\sum_{k=0}^n\\binom{n}{k}g(k)\\\\\\to g(n)=\\sum_{k=0}^n (-1)^{n-k}\\binom{n}{k} f(k) f(n)=k=0∑n​(kn​)g(k)→g(n)=k=0∑n​(−1)n−k(kn​)f(k) 莫比乌斯反演： 1.f(n)=∑d∣ng(d)→g(n)=∑d∣nμ(nd)f(d)1.f(n)=\\sum_{d|n} g(d)\\\\ \\to g(n)=\\sum_{d|n} \\mu({n\\over d}) f(d) 1.f(n)=d∣n∑​g(d)→g(n)=d∣n∑​μ(dn​)f(d) 2.f(n)=∑n∣dg(d)→∑n∣dμ(dn)f(d)2.f(n)=\\sum_{n|d} g(d)\\\\ \\to \\sum_{n|d}\\mu({d\\over n})f(d) 2.f(n)=n∣d∑​g(d)→n∣d∑​μ(nd​)f(d) 斯特林反演 F(n)=∑i=0n{ni}G(i)⟺G(n)=∑i=0n(−1)n−i[ni]F(i)F(n)=∑i=0n(−1)n−i{ni}G(i)⟺G(n)=∑i=0n[ni]F(i)F(n)=\\sum_{i=0}^n\\begin{Bmatrix}n\\\\i\\end{Bmatrix}G(i)⟺G(n)=\\sum_{i=0}^{n}(-1)^{n-i}\\begin{bmatrix}n\\\\i\\\\\\end{bmatrix}F(i)\\\\ F(n)=\\sum_{i=0}^n(-1)^{n-i}\\begin{Bmatrix}n\\\\i\\end{Bmatrix}G(i)⟺G(n)=\\sum_{i=0}^n\\begin{bmatrix}n\\\\i\\end{bmatrix}F(i) F(n)=i=0∑n​{ni​}G(i)⟺G(n)=i=0∑n​(−1)n−i[ni​]F(i)F(n)=i=0∑n​(−1)n−i{ni​}G(i)⟺G(n)=i=0∑n​[ni​]F(i) 子集反演 f(S)=∑T∈Sg(T)→g(S)=∑T∈S(−1)∣S∣−∣T∣f(T)f(S)=\\sum_{T\\in S} g(T)\\\\\\to g(S)=\\sum_{T\\in S}(-1)^{|S|-|T|}f(T) f(S)=T∈S∑​g(T)→g(S)=T∈S∑​(−1)∣S∣−∣T∣f(T)","categories":[],"tags":[]},{"title":"线代学习笔记","slug":"线性代数","date":"2022-02-14T02:19:45.000Z","updated":"2022-02-14T11:08:21.057Z","comments":true,"path":"Notes/线性代数/cm34e3w68005a5vtn6kgfgjkw/","link":"","permalink":"http://odalys8191.github.io/Notes/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/cm34e3w68005a5vtn6kgfgjkw/","excerpt":"","text":"# 线代学习笔记 # 亿些知识 同济大学《线性代数》前四章部分内容 # 0. 行列式 # 0.1. 定义： D=det(a)=∣a1,1...a1,m....an,1...an,m∣=∑(−1)t∏i=1nai,piD=det(a)=\\begin{vmatrix}a_{1,1}&amp;...&amp;a_{1,m}\\\\.&amp;.\\\\.&amp;&amp;.\\\\a_{n,1}&amp;...&amp;a_{n,m}\\\\\\end{vmatrix}\\\\=\\sum (-1)^t \\prod_{i=1}^n a_{i,p_i} D=det(a)=∣∣∣∣∣∣∣∣∣​a1,1​..an,1​​.......​a1,m​.an,m​​∣∣∣∣∣∣∣∣∣​=∑(−1)ti=1∏n​ai,pi​​ 其中，ppp 是一个 1→m1\\to m1→m 的排列，ttt 是其逆序对数。 # 0.2. 性质： Lemma 0.2.1. 行列式与其转置行列式相同 Lemma 0.2.2. 上三角矩阵行列式等于其主对角线之积 Lemma 0.2.3. 行列式交换两行（列），行列式变号 Lemma 0.2.4. 行列式可提某行（列）公因子 由上述两条得 行列式任意两行（列）成比例，行列式为零 Lemma 0.2.5. 把行列式某一行每个元拆为两个之和，可据此将行列式裂为两个 Lemma 0.2.6. 行列式某行乘个系数，加到另一行，行列式不变 # 0.3. 按行展开 定义余子式 Mi,jM_{i,j}Mi,j​ 为行列式把 iii 行 jjj 列删掉后的行列式乘上 ai,ja_{i,j}ai,j​，定义代数余子式 A_{i,j}=(-1)^{i+j} M_ # 0.4. 定理 Lemma 0.3.1. 若第 iii 行除 ai,ja_{i,j}ai,j​ 外都为 000 ，则 D=ai,j×Ai,jD=a_{i,j}\\times A_{i,j}D=ai,j​×Ai,j​ Lemma 0.3.2. 行列式等于某一行每个元素乘上它的代数余子式，这就是行列式按行展开 某行所有元素的代数余子式挨个乘上另一个行所有元素，结果为 000 # 1. 矩阵 # 1.1. 定义 就是个数表 单位矩阵 记做 EEE 主对角线全 111 其余为 000 的矩阵 纯量阵 λE\\lambda EλE 伴随矩阵 记做 A∗A^*A∗ 由 AAA 每个元素的代数余子式构成 系数矩阵 线性方程组的系数 常数矩阵 线性方程组隔壁的常数 增广矩阵 系数矩阵 + 常数矩阵 # 1.2. 运算 乘法 C=A∗Bci,j=∑k=1aai,k×bk,jC=A*B\\\\ c_{i,j}=\\sum_{k=1}^a a_{i,k}\\times b_{k,j} C=A∗Bci,j​=k=1∑a​ai,k​×bk,j​ 转置 AT=aj,i(AT)T=A(AB)T=BTATA^T=a_{j,i} \\\\ (A^T)^T=A \\\\ (AB)^T=B^TA^T AT=aj,i​(AT)T=A(AB)T=BTAT 逆 若 det(A)≠0det(A)\\not= 0det(A)=0 则叫 AAA 非奇异矩阵，此时它有逆 定义是 AA−1=EAA^{-1}=EAA−1=E 一个矩阵的逆唯一 A−1=1∣A∣A∗A^{-1}={1\\over |A|}A^*A−1=∣A∣1​A∗ (AB)^{-1}=B^{-1}A^ 秩 定义 kkk 阶子式为在矩阵中任取 kkk 行 kkk 列，所得出的 k2k^2k2 个元素按原来位置组成的数表 定义 R(A)R(A)R(A) 表示矩阵 AAA 的秩，即最大的满足 R(A)R(A)R(A) 阶子式不为 000 可逆矩阵秩是满的，叫满秩 用秩可以判断线性方程组解的情况 AAA 系数矩阵，BBB 增广矩阵 R(A)&lt;R(B) noneR(A)=R(B)=n 1R(A)=R(B)&lt;n infR(A)&lt;R(B) \\ \\ \\ none\\\\ R(A)=R(B)=n \\ \\ \\ 1\\\\ R(A)=R(B)&lt;n \\ \\ \\ inf R(A)&lt;R(B) noneR(A)=R(B)=n 1R(A)=R(B)&lt;n inf","categories":[{"name":"Notes","slug":"Notes","permalink":"http://odalys8191.github.io/categories/Notes/"}],"tags":[{"name":"线性代数","slug":"线性代数","permalink":"http://odalys8191.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}]},{"title":"2022-02-13-Test&USACO22Jan P","slug":"2022-02-13-Test-USACO22Jan-P","date":"2022-02-13T08:15:28.000Z","updated":"2022-02-13T08:50:14.597Z","comments":true,"path":"Tests/2022-02-13-Test-USACO22Jan-P/cm34e3w5200205vtn6d5g9z52/","link":"","permalink":"http://odalys8191.github.io/Tests/2022-02-13-Test-USACO22Jan-P/cm34e3w5200205vtn6d5g9z52/","excerpt":"","text":"# A 由 [AGC001F] Wide Swap 可知一个结论，若 i&lt;j,∣hi−hj∣&gt;ki &lt; j,|h_i-h_j|&gt; ki&lt;j,∣hi​−hj​∣&gt;k 则无论怎么交换，hi,hjh_i,h_jhi​,hj​ 的相对位置不会改变。 据此，我们暴力连边，每条边表示 hih_ihi​ 必须得在 hjh_jhj​，然后用一个堆拓扑一遍即可得出最小字典序 考虑使用数据结构优化这个建图方式 考虑使用建一棵权值主席树，上面全是虚点，每次加入新的 hih_ihi​ 我们在叶子上将 iii 连上这个权值，再一路向祖先连；每次连所有满足 i&lt;j,∣hi−hj∣&gt;ki &lt; j,|h_i-h_j|&gt; ki&lt;j,∣hi​−hj​∣&gt;k 的边只需在权值主席树上将对应的区间连一下即可。 最后还是用一个堆来拓扑，有一个细节是，优先将堆（即当前入度为 000 的点）中虚点拿出来处理。 # B 和上面一样，可以转换为 DAG 上拓扑序的种类数。 然后发现所有的从前往后所有奇数，偶数的拓扑序是固定的，然后就可以 dpdpdp 了。 # C 发现答案在凸包上 闵克夫斯基和板子","categories":[{"name":"Tests","slug":"Tests","permalink":"http://odalys8191.github.io/categories/Tests/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://odalys8191.github.io/tags/dp/"},{"name":"计算几何","slug":"计算几何","permalink":"http://odalys8191.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"datastructure","slug":"datastructure","permalink":"http://odalys8191.github.io/tags/datastructure/"},{"name":"拓扑","slug":"拓扑","permalink":"http://odalys8191.github.io/tags/%E6%8B%93%E6%89%91/"},{"name":"奇偶性","slug":"奇偶性","permalink":"http://odalys8191.github.io/tags/%E5%A5%87%E5%81%B6%E6%80%A7/"},{"name":"经典结论","slug":"经典结论","permalink":"http://odalys8191.github.io/tags/%E7%BB%8F%E5%85%B8%E7%BB%93%E8%AE%BA/"},{"name":"闵克夫斯基和","slug":"闵克夫斯基和","permalink":"http://odalys8191.github.io/tags/%E9%97%B5%E5%85%8B%E5%A4%AB%E6%96%AF%E5%9F%BA%E5%92%8C/"},{"name":"凸包","slug":"凸包","permalink":"http://odalys8191.github.io/tags/%E5%87%B8%E5%8C%85/"}]},{"title":"吉吉学习笔记","slug":"吉吉学习笔记","date":"2022-02-13T03:17:10.000Z","updated":"2022-02-13T13:07:35.545Z","comments":true,"path":"Notes/吉吉学习笔记/cm34e3w6600515vtn1a4o1wdr/","link":"","permalink":"http://odalys8191.github.io/Notes/%E5%90%89%E5%90%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/cm34e3w6600515vtn1a4o1wdr/","excerpt":"","text":"打牛牛题不会吉吉！","categories":[{"name":"Notes","slug":"Notes","permalink":"http://odalys8191.github.io/categories/Notes/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"http://odalys8191.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"}]},{"title":"2022-02-12 Test","slug":"2022-02-12","date":"2022-02-12T06:28:09.000Z","updated":"2022-02-12T14:14:18.729Z","comments":true,"path":"Tests/2022-02-12/cm34e3w51001w5vtn7njd7j8d/","link":"","permalink":"http://odalys8191.github.io/Tests/2022-02-12/cm34e3w51001w5vtn7njd7j8d/","excerpt":"","text":"# 2022-02-12 Test real: 40 + 20 + 0 expect: 40 + 20 + 0 need: 100 + 20 + 0 links sol # 简 从大到小排序 设 dpi,j,kdp_{i,j,k}dpi,j,k​ 表示选到第 iii 个元素，前面还有 jjj 个元素未匹配，当前总和为 kkk 的方案数 aia_iai​ 第 iii 位权值 转移 dpi,j,k=a×dpi−1,j−1,k−ai+b×dpi−1,j+1,k+ai+c×dpi−1,j,k+dpi−1,j,kdp_{i,j,k} = a\\times dp_{i-1,j-1,k-a_i} + b\\times dp_{i-1,j+1,k+a_i}+c\\times dp_{i-1,j,k} + dp_{i-1,j,k} dpi,j,k​=a×dpi−1,j−1,k−ai​​+b×dpi−1,j+1,k+ai​​+c×dpi−1,j,k​+dpi−1,j,k​ 分别表示这一位匹配与否，还有一个只由当前一个元素组成的集合。 考虑系数 a=1 直接插一个坑b=j+1 选一个坑填c=j 可以放进任意一个坑中a=1 \\ \\ \\ \\ 直接插一个坑 \\\\ b=j+1 \\ \\ \\ \\ 选一个坑填 \\\\ c=j \\ \\ \\ \\ 可以放进任意一个坑中 a=1 直接插一个坑b=j+1 选一个坑填c=j 可以放进任意一个坑中 O(n3v)\\mathrm O(n^3 v) O(n3v) 我是大傻逼 加个差分后，我们就不用管减法了，然后最大值就变成了 kkk ，即可 Accepted\\color{green}\\texttt{Accepted}Accepted 。 当然还有一些小细节，比如说差分数组每个坑都要连续变化，所以会有一个 j×aij\\times a_ij×ai​ 之类的东西出现 然后 zxyhymzg\\color{red}\\texttt{z}\\color{black}\\texttt{xyhymzg}zxyhymzg 就 O(n3v)\\mathrm O(n^3 v)O(n3v) 卡过去了 orz # 单 考虑一张无向图，任意定向后最多的入度不为 000 的点，它是等于无向图点数 nnn 减去形成的树的个数 vvv ，考虑对于一棵树，我们可将其定向为外向树，这样就只有一个入度为 000 的点，而对于一个联通块，我们可以取出一棵基环生成树，将其定向即可实现没有一个入度为 000 的点，这个定理得证。 然后我们要求最小的树的个数，可以转化为 nnn 减去最多的定向后入度不为 000 的点，然后对于一个集合内连边，我们可以看成给这个集合某一个点入度加 111 ，那把 mmm 集合放一边，nnn 个点放一边，从集合到属于它的每个点连边，这个二分图的最大匹配就是我们最多的定向后入度不为 000 的点。 # 题 把平面图转成对偶图，相邻面之间从左向右连边，其最长链就是答案。 为什么，我也不知道 怎么写，我也不知道","categories":[{"name":"Tests","slug":"Tests","permalink":"http://odalys8191.github.io/categories/Tests/"}],"tags":[]},{"title":"2022-02-10 Test","slug":"2022-02-10-Test","date":"2022-02-11T03:28:09.000Z","updated":"2022-02-11T06:21:21.623Z","comments":true,"path":"Tests/2022-02-10-Test/cm34e3w50001s5vtn6zxrg3m0/","link":"","permalink":"http://odalys8191.github.io/Tests/2022-02-10-Test/cm34e3w50001s5vtn6zxrg3m0/","excerpt":"","text":"real: 68 + 0 + 0 expect: 100 + 40 + 0 T1 被卡常了，T2 被输入埋了 links sol # 简单最优化问题 ​ 枚举个gcdgcdgcd ，使用 DirichletDirichletDirichlet 前缀和优化。 # 简单数学题 ​ 一种题解做法是枚举第 iii 个位置有贡献然后使用积分。 ​ 实际上可以下一步转换不必使用积分，而是考虑每个位置，他们的可取值域要每次相对来说会乘一个阶乘，而给他们任意取值后每个位置成为最大值的机会均等，然后就可以推出柿子： Ans=∑i=1n(i−1)!iiAns= \\sum_{i=1}^n {(i-1)!\\over i^i} Ans=i=1∑n​ii(i−1)!​ 上面那个 (i−1)!(i-1)!(i−1)! 就是乘了一个 1n1\\over nn1​ 后的剩余结果。 这个柿子直接 O(nlogn)\\mathrm O(n\\mathrm log n)O(nlogn) 即可做到 40pts ，我们考虑线性做法，就是要快速算出 iii^iii 。利用原根，我们知道 ii=gi×loggii^i=g^{i\\times \\mathrm{log_gi}}ii=gi×logg​i 然后 loggi\\mathrm {log}_gilogg​i 扫一遍就好 这题 tm 卡常，奇技淫巧我也不会。 # 简单数据结构题 考虑如果我们知道一个点子树内所有数字权值的 bitset\\texttt{bitset}bitset ，如果是手写的，我们很容易求出答案即 val(sd)&amp;val(sd+k)val(sd)\\&amp;val(sd+k)val(sd)&amp;val(sd+k) ，val(x)val(x)val(x) 表示取 xxx 后 646464 位。 考虑优化，显然可以按 dfndfndfn 序分块，我们可以预处理两两块之间的 bitset\\texttt{bitset}bitset ，然后这题卡空间，于是利用 dfndfndfn 的性质，两两子树区间只可能包含或不交，于是我们要处理的相当于是一棵 二叉树上的所有节点，叶子有 BBB 个，也就是 2B2B2B 个区间，之间预处理就好。 题解的分块方式是在树上选一些点为关键点，处理他们子树中的 bitset\\texttt{bitset}bitset ，若一个点 uuu 内子树最大一个被处理过的关键点 mxmxmx 使得 sizu−sizmx≥Bsiz_u-siz_{mx} \\ge Bsizu​−sizmx​≥B ，你就把这个点也给染黑。 由于这题 tmd 卡空间，所以需要调参卡一下块长。 出题人诚实谦卑。","categories":[{"name":"Tests","slug":"Tests","permalink":"http://odalys8191.github.io/categories/Tests/"}],"tags":[{"name":"bitset","slug":"bitset","permalink":"http://odalys8191.github.io/tags/bitset/"},{"name":"分块","slug":"分块","permalink":"http://odalys8191.github.io/tags/%E5%88%86%E5%9D%97/"},{"name":"卡常","slug":"卡常","permalink":"http://odalys8191.github.io/tags/%E5%8D%A1%E5%B8%B8/"},{"name":"Dirichlet前缀和","slug":"Dirichlet前缀和","permalink":"http://odalys8191.github.io/tags/Dirichlet%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"推柿子","slug":"推柿子","permalink":"http://odalys8191.github.io/tags/%E6%8E%A8%E6%9F%BF%E5%AD%90/"},{"name":"原根应用","slug":"原根应用","permalink":"http://odalys8191.github.io/tags/%E5%8E%9F%E6%A0%B9%E5%BA%94%E7%94%A8/"},{"name":"离散对数","slug":"离散对数","permalink":"http://odalys8191.github.io/tags/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/"},{"name":"datastructure","slug":"datastructure","permalink":"http://odalys8191.github.io/tags/datastructure/"},{"name":"dfn的性质","slug":"dfn的性质","permalink":"http://odalys8191.github.io/tags/dfn%E7%9A%84%E6%80%A7%E8%B4%A8/"}]},{"title":"WBLT小鸡","slug":"WBLT小鸡","date":"2022-02-10T08:53:49.000Z","updated":"2023-06-14T13:13:06.663Z","comments":true,"path":"Notes/WBLT小鸡/cm34e3w5y004h5vtn3epx5shb/","link":"","permalink":"http://odalys8191.github.io/Notes/WBLT%E5%B0%8F%E9%B8%A1/cm34e3w5y004h5vtn3epx5shb/","excerpt":"","text":"# WBLT 小鸡 # Tips: 信息存在叶子上，即 Leafty 性质，每个点维护一个权值 vvv ，一个信息大小 sizsizsiz ，叶子 siz=1,val=vsiz = 1,val=vsiz=1,val=v ，其他点 sizsizsiz 直接合并，val=val_ 这样，点数是 2n2n2n 的，中序遍历是单调递增的，利用 valvalval 可实现查值查 rk。 利用单旋和双旋来维护重量平衡 重量平衡大概是搞一个常数 α\\alphaα ，若左右子树有一个比另一个 α\\alphaα 还大就不平衡，经论文分析，这样复杂度正确！ 写一个内存池来回收删除节点 由于复杂度不是均摊的，容易可持久化 # Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657namespace WBLT &#123; int ch[N][2], siz[N], val[N]; int pool[N], tot, poolc; int Id () &#123; return poolc ? pool[poolc--] : ++tot; &#125; int Recycle (int x) &#123; pool[++poolc] = x; &#125; int Pushup (int x) &#123; siz[x] = siz[ch[x][0]] + siz[ch[x][1]]; val[x] = siz[ch[x][1]]; &#125; int New (int &amp;x, int v) &#123; x = Id(); ch[x][0] = ch[x][1] = 0, siz[x] = 1, val[x] = v; &#125; int Merge (int x, int y) &#123; int k = Id(); ch[k][0] = x, ch[k][1] = y; Pushup(k); return k; &#125; void Rotate (int x, int op) &#123; int temp = ch[x][op ^ 1]; ch[x][op ^ 1] = ch[x][op]; ch[x][op] = ch[ch[op ^ 1]][op]; ch[ch[x][op ^ 1]][op] = ch[ch[x][op ^ 1]][op ^ 1]; ch[ch[x][op ^ 1]][op ^ 1] = temp; Pushup(ch[x][op ^ 1]); &#125; const double alpha = 2.; void Maintain (int x) &#123; if (siz[ch[x][0]] &gt; siz[ch[x][1]] * alpha) Rotate (x, 0); else if (siz[ch[x][1]] &gt; siz[ch[x][0]] * alpha) Rotate (x, 1); if (siz[ch[x][0]] &gt; siz[ch[x][1]] * alpha) Rotate (ch[x][0], 1), Rotate(x, 0); else if (siz[ch[x][1]] &gt; siz[ch[x][0]] * alpha) Rotate (ch[x][1], 0), Rotate (x, 1); &#125; void Insert (int &amp;x, int v) &#123; if (!x) return New(x, v), void(); if (siz[x] == 1) return (x = v &gt; val[x] ? Merge(val[x], v) : Merge(v, val[x])), void(); else Insert(ch[x][v &gt; val[ch[x][0]]], v); Pushup(x), Maintain(x); &#125; void Delete (int &amp;x, int v) &#123; if ( siz[x] == 1 ) return (Recycle(x), x = 0), void(); int to = v &gt; val[ch[x][0]]; if ( siz[ch[x][to]] == 1 ) Recycle(x), Recycle(ch[x][to]), x = ch[x][to ^ 1]; else Delete (ch[x][to], v), Pushup(x), Maintain(x); &#125; int Rank (int x, int v) &#123; if (siz[x] == 1) return 1; if (v &gt; val[ch[x][0]]) return siz[ch[x][0]] + Rank(ch[x][1], v); return Rank(ch[x][0], v); &#125; int Find (int x, int v) &#123; if (siz[x] == v) return val[x]; if (v &gt; siz[ch[x][0]]) return Find(ch[x][1], v - siz[ch[x][0]]); return Find(ch[x][0], v); &#125;&#125;","categories":[{"name":"Notes","slug":"Notes","permalink":"http://odalys8191.github.io/categories/Notes/"}],"tags":[{"name":"平衡树","slug":"平衡树","permalink":"http://odalys8191.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"}]},{"title":"CF700E Cool Slogans","slug":"CF700E-Cool-Slogans","date":"2022-01-16T00:37:28.000Z","updated":"2022-01-16T00:54:43.864Z","comments":true,"path":"Solutions/CF700E-Cool-Slogans/cm34e3w5j003f5vtnd3nk6cci/","link":"","permalink":"http://odalys8191.github.io/Solutions/CF700E-Cool-Slogans/cm34e3w5j003f5vtnd3nk6cci/","excerpt":"","text":"首先可以发现满足条件的 si−1s_{i-1}si−1​ 一定会是 sis_{i}si​ 的后缀，考虑反证，若存在不是后缀，那一定是中间一段，把后面切掉不会使得答案更劣。 然后就考虑在 SAM 的 parents-tree\\texttt{parents-tree}parents-tree 上做一些事情，我们已经知道满足条件的 si−1s_{i-1}si−1​ 一定是 sis_{i}si​ 的一个祖先，但这并没有考虑到满足出现两次这样一个限制，我们来观察满足限制的 endposendposendpos 之间的关系。 容易发现，设 sis_isi​ 的 endposendposendpos 中有一组满足题意的 xxx ，则 si−1s_{i-1}si−1​ 比 sis_{i}si​ 多的 endposendposendpos 一定要 \\in \\[x-len_{s_i} + len_{s_{i-1}}, pos_{x}-1\\] 。 那么考虑在 \\texttt{parents_tree} 上 dpdpdp ，若满足上述条件则可以转移，上述条件的判断可以直接使用线段树合并维护出 endposendposendpos 集合然后直接判断，若符合条件则 dpu=dpv+1dp_{u} =dp_{v} +1dpu​=dpv​+1 。还值得关注的一点是该从哪里转移，由于每次转移都只会加一，我们可以记录 faufa_ufau​ 表示最浅的与 uuu dp 值相同的位置，然后直接从 fafaufa_{fa_u}fafau​​ 转移。 代码上的细节： 1. 线段树维护 endposendposendpos 集合时可以搞出一个 toputoputopu 序，避免了麻烦的处理。 2. 线段树合并时如果 rtxrt_xrtx​ 没给它设初值，要设置，避免混淆。 3. 线段树维护 endposendposendpos 时可以不给他加东西表示，直接看存不存在这个点就能判断 [l,r][l,r][l,r] 中有没有 endposendposendpos。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/* ============================== * Author : Odalys * * Blog : Odalys.xyz * * Mail : minyuenu@gmail.com * =============================== */#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w = 1; a = 0; char ch = getchar(); for(; ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;; ch = getchar()) if(ch == &#x27;-&#x27;) w = -1; for(; ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;; ch = getchar()) a = (a * 10) + (ch - &#x27;0&#x27;); a *= w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define fi first#define se second#define pb push_back#define mp make_pair#define mii map&lt;int, int&gt; #define pii pair&lt;int, int&gt; #define vi vector&lt;int&gt;#define si set&lt;int&gt; #define ins insert#define era erase#define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)const int N = 2e5 + 10;const int M = 1e7 + 10;struct state &#123; int len, nxt[26], link, pos;&#125; st[N &lt;&lt; 1];int siz = 1, las = 1; int id[N];inline void extend (int c, int i) &#123; int cur = ++siz, p = las; las = cur; id[i] = siz; st[cur].len = st[p].len + 1; st[cur].pos = i; while (p &amp;&amp; !st[p].nxt[c]) st[p].nxt[c] = cur, p = st[p].link; if (p == 0) st[cur].link = 1; else &#123; int q = st[p].nxt[c]; if (st[p].len + 1 == st[q].len) st[cur].link = q; else &#123; int clone = ++siz; st[clone].len = st[p].len + 1, st[clone].link = st[q].link; st[clone].pos = st[q].pos; For (i, 0, 25) st[clone].nxt[i] = st[q].nxt[i]; st[q].link = st[cur].link = clone; while (p &amp;&amp; st[p].nxt[c] == q) st[p].nxt[c] = clone, p = st[p].link; &#125; &#125;&#125;int rt[N &lt;&lt; 1]; #define ls tr[x].l#define rs tr[x].rint total;struct seg &#123; int l, r, sum; &#125; tr[M];inline void pushup (int x) &#123; tr[x].sum = tr[ls].sum + tr[rs].sum; &#125;int merge (int x, int y, int l, int r) &#123; if (!x || !y) return x + y; if (l == r) return (tr[x].sum += tr[y].sum), x; int mid = l + r &gt;&gt; 1, k = ++total; tr[k].l = merge(ls, tr[y].l, l, mid), tr[k].r = merge(rs, tr[y].r, mid + 1, r); pushup(k); return k;&#125;void upd (int &amp;x, int l, int r, int p) &#123; if (!x) x = ++total; if (l == r) return (tr[x].sum++), void(); int mid = l + r &gt;&gt; 1; if (p &lt;= mid) upd (ls, l, mid, p); else upd (rs, mid + 1, r, p); pushup(x); &#125;int que (int x, int l, int r, int ll, int rr) &#123; if (!x) return 0; if (ll &lt;= l &amp;&amp; r &lt;= rr) return tr[x].sum; int ans = 0, mid = l + r &gt;&gt; 1; if (ll &lt;= mid) ans += que(ls, l, mid, ll, rr); if (rr &gt; mid) ans += que(rs, mid + 1, r, ll, rr); return ans;&#125;int n;char z[N];int you[N], se[N &lt;&lt; 1];inline void SORT() &#123; For (i, 1, siz) you[st[i].len]++; For (i, 1, n) you[i] += you[i - 1]; For (i, 1, siz) se[you[st[i].len]--] = i; &#125;int dp[N &lt;&lt; 1];int main() &#123; read(n); scanf (&quot;%s&quot;, z + 1); id[0] = 1; For (i, 1, n) extend(z[i] - &#x27;a&#x27;, i), upd(rt[id[i]], 1, n, i); SORT(); //For (i, 1, siz) cout &lt;&lt; se[i] &lt;&lt; &quot; &quot;; foR (i, siz, 2) rt[st[se[i]].link] = merge(rt[st[se[i]].link], rt[se[i]], 1, n); // cout &lt;&lt; siz &lt;&lt; endl;// For (i, 1, siz) cout &lt;&lt; rt[se[i]] &lt;&lt; endl; int ans = 1; For (i, 2, siz) &#123; int u = se[i], v = st[u].link; if (v == 1) dp[u] = 1, st[u].link = u; else &#123; if (que(rt[st[v].link], 1, n, st[u].pos - st[u].len + st[st[v].link].len, st[u].pos - 1) ) dp[u] = dp[v] + 1, st[u].link = u; else dp[u] = dp[v], st[u].link = st[v].link; ckmax(ans, dp[u]); &#125; &#125; printf (&quot;%d\\n&quot;, ans);&#125;","categories":[{"name":"Solutions","slug":"Solutions","permalink":"http://odalys8191.github.io/categories/Solutions/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://odalys8191.github.io/tags/dp/"},{"name":"SAM","slug":"SAM","permalink":"http://odalys8191.github.io/tags/SAM/"},{"name":"线段树合并","slug":"线段树合并","permalink":"http://odalys8191.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"},{"name":"endpos性质","slug":"endpos性质","permalink":"http://odalys8191.github.io/tags/endpos%E6%80%A7%E8%B4%A8/"}]},{"title":"Foreign OI Lists","slug":"Foreign-OI-Lists","date":"2021-12-28T13:38:52.000Z","updated":"2024-11-08T04:02:47.484Z","comments":true,"path":"Solutions/Foreign-OI-Lists/cm34e3w5n003t5vtn43ro47y0/","link":"","permalink":"http://odalys8191.github.io/Solutions/Foreign-OI-Lists/cm34e3w5n003t5vtn43ro47y0/","excerpt":"","text":"一些国外OI的Lists CEOI2017 JOISC COCI","categories":[{"name":"Solutions","slug":"Solutions","permalink":"http://odalys8191.github.io/categories/Solutions/"}],"tags":[{"name":"Foregin","slug":"Foregin","permalink":"http://odalys8191.github.io/tags/Foregin/"}]},{"title":"从一桩悬案看一个孤独的家族","slug":"从一桩悬案看一个孤独的家族","date":"2021-12-24T14:07:09.000Z","updated":"2021-12-24T14:08:55.164Z","comments":true,"path":"Article/从一桩悬案看一个孤独的家族/cm34e3w63004u5vtn8zlbafnq/","link":"","permalink":"http://odalys8191.github.io/Article/%E4%BB%8E%E4%B8%80%E6%A1%A9%E6%82%AC%E6%A1%88%E7%9C%8B%E4%B8%80%E4%B8%AA%E5%AD%A4%E7%8B%AC%E7%9A%84%E5%AE%B6%E6%97%8F/cm34e3w63004u5vtn8zlbafnq/","excerpt":"","text":"# 从一桩悬案看一个孤独的家族 ​ 在我初读《百年孤独》时，曾被一桩 “悬案” 所困扰，那就是小美人蕾梅黛丝在婚期前一周意外身亡。当时的我将死因归结于下一页中阿玛兰妲向上帝祈求导致鸦片酊误落于蕾梅黛丝的咖啡中这样一个魔幻的事情，我既因为一个美丽纯洁的女孩子这样莫名其妙的死去而感到不解，又抱着对 “文学家无闲笔” 这样一种感觉而始终保持着一种警觉。在接下来的阅读中，我找到了一个可以说服我的答案，并从中对这样一个孤独家族有了一些自己的理解。 ​ 我认为凶手是小独裁者阿尔卡蒂奥，于文中的佐证是当阿尔卡蒂奥被枪决时，脑中走马灯般闪过的人生记忆中，我看到了蕾梅黛丝的影子–确切来说，是他在蕾梅黛丝尸体鼻腔中发觉的感觉。一个人在临死前，想到的竟然是另一位女子的尸体？！并且在此之后阿尔卡蒂奥当即便想给自己未出世的女儿取名叫蕾梅黛丝。这无疑说明阿尔卡蒂奥与蕾梅黛丝之间有着不浅的渊源，同时也可以解释为阿尔卡蒂奥对蕾梅黛丝有着一种或是怀念或是愧疚的情感–所以他才想将自己的女儿取名为蕾梅黛丝。所以我据此认为，是阿尔卡蒂奥杀害了她。 ​ 有了前面的分析，再找到动机是并不难的。阿尔卡蒂奥是何塞・阿尔卡蒂奥与占星师庇拉尔・特尔内拉所生的私生子，在乌尔苏拉这个守旧的祖母所统领的家族内，他注定从出生起就是不受关注，甚至更进一步，是受轻视的。而反观蕾梅黛丝，自从被奥雷里亚诺上校领进家门以来，就受尽布尔迪亚家族的宠爱与关注，在这样一种现实下，幼小的阿尔卡蒂奥产生羡慕与孤独的情绪在所难免，而当有一天，积累的，羡慕与孤独被时间与盛大的婚礼压抑成了嫉恨，愤怒的魔鬼驱使着他将毒药投入蕾梅黛丝的咖啡，惨案就此发生… 所以阿尔卡蒂奥以后的行为也就不难理解。在上校将马孔多的军政大权移交给他时，他变成了一个独裁者。他肆意妄为，欺压人民，或许是想通过这样的方式唤起从前被人们亏欠过的关注与正视吧。在他死去前，记忆流过的那一刻，他才意识到自己其实一直热爱着曾经痛恨的那些布尔迪亚们。他在人间的最后一刻，高喊着 “自由党万岁！P107” 他只是远离文明边陲之地马孔多的一个年轻人，没有了解过系统的政治概念，他对自由党的理解是什么？我想，就是村中里正所描述的，自由党 “承认私生子与婚生子享有同等权利。P85” 吧。所以，在生命的最后一刻，他哪里是在高喊什么可以为之付出生命的政治诉求，分明是在呼唤家人们不分血统的爱与关注！这就是我所理解的阿尔卡蒂奥的孤独。 ​ 我想，在书中，乌尔苏拉也是了解这桩案子的。阿尔卡蒂奥想为女儿更换取名的遗言是并没有传达出去的，而在家人们跟她取名时，乌尔苏拉却执意用蕾梅黛丝给女孩命了名，她还知道 “这是阿尔卡蒂奥的意思。P117” 同时，在日后奥雷里亚诺上校放弃政变，决定将他存在的证明通通销毁时，她还拒绝毁掉蕾梅黛丝的银质相片，因为这是 “给全家的遗物 P154”。所以我认为，乌尔苏拉应该是知道这件事情的。同时，乌尔苏拉在全书中的形象是一个关爱自己家族的每一个人的老祖母形象，尽管她总是抱怨自己生在一个疯子之家，同时可能也不太明白如何关系族人的成长。所以她留下蕾梅黛丝的照片，我想是出于一种喜爱与愧疚吧。一方面，她十分喜爱蕾梅黛丝这个美丽纯真的女子，另一方面，她十分愧疚于对阿尔卡蒂奥成长过程中的忽视。这种类似 “作孽” 的感情使得她将这张照片保存到家族的消亡。 ​ 萦绕在这个家族的孤独到底源于什么，我认为其中一个重要的原因是缺乏包容与理解。这个家族的每一个人都不被彼此理解，也不去尝试理解彼此，只按照自己的世界来要求与塑造他人。像乌尔苏拉对孩子们的教诲，她以自己那些守旧的、未经开化的世界加入从前教育失败的案例作为模具，来塑造每个孩子的灵魂，然后由于个体之间的差异性以及时代潮流的变化，她往往教育出一个她所认为的 “疯子”。这种不尊重人与人之间差异性的教育方式直接导致了第五代何塞・阿尔卡蒂奥的童年阴影。 ​ 而所谓拉丁美洲的孤独，我想也与这些包容与理解的缺乏有关。当我在阅读《百年孤独》或是其他的一些拉美文学作品时，巫医的玄方，奇妙的炼金术，占星师的塔罗牌曾让我对这些如梦似幻的东西心驰神往，但也曾有过那么一个瞬间，我也会认为这些东西十分荒谬与可笑–的确，与我们博大精深的中华文化相比，拉美的文明可能并没有那么浪漫且富有逻辑。但文明存在的意义，并不只由科技，文教之类的东西来衡量。文明存在的本身，就是值得敬畏且有意义的。而西方的殖民者来到马孔多，以自己的文明刻画马孔多的形状，他们的行动内核之中蕴含了深深的傲慢与不包容。所以当失眠症开始蔓延，当开拓者被遗忘，当那如同腐烂的香蕉般被投入大海的三千人再也无法掀起一丝涟漪。这些后来的人们再也无法知道从前悠长的时光中这片土地上的人们创造的灿烂文明，这种跨越时空的阻隔，这种无力感，便是拉丁美洲的孤独。","categories":[{"name":"Article","slug":"Article","permalink":"http://odalys8191.github.io/categories/Article/"}],"tags":[]},{"title":"CF1479","slug":"CF1479","date":"2021-11-16T11:48:08.000Z","updated":"2021-11-16T12:03:48.447Z","comments":true,"path":"Vps/CF1479/cm34e3w5c002v5vtn5cekfdud/","link":"","permalink":"http://odalys8191.github.io/Vps/CF1479/cm34e3w5c002v5vtn5cekfdud/","excerpt":"","text":"# Solutions # A 人类智慧 考虑 a0=an+1=INFa_0=a_{n+1}=\\texttt{INF}a0​=an+1​=INF 。 那可以二分中间一个端点，若他是下降的由于最后一项是上升故后面一定有个合法答案，反之亦然。 # B 贪心。 考虑两个栈，若与栈顶有一个不同则直接放更优，否则。。。。讨论一下 # C 看到就会想到二进制分拆 考虑 [1,2n−1][1,2^n-1][1,2n−1] 如何构造，大概是每个点表示一个二进制位，向外连的边都是 222 的整次幂… 这样子。 考虑如何构造 [1,2n][1,2^n][1,2n] 则新建一个点，朝上面那张图每个点连条为 111 的边即可。 考虑如何构造 [1,a][1,a][1,a] ，把 aaa 二进制分拆一下，对于一个不为最高位的 111 ，形如 100....1000100....1000100....1000 此类的，我们新建一个点，把上面那张图的代表这一位的点，向他连一条 1000...1000...1000... 的边，即可连出 100..0000→100...1000100..0000 \\to 100...1000100..0000→100...1000 之间的边，由于最后可能会出现长度为 000 的点，不妨把 aaa 先减去 111 ，最后连接终点时再加上。 考虑构造 [l,r][l,r][l,r] 就直接起点连一条 l−1l-1l−1 边，构造一张 [1,r−l+1][1,r-l+1][1,r−l+1] 的图即可。 # D 考虑模拟赛云的一个神奇东西，把颜色异或起来，剩下的不为 000 就合法，这个玩意很假，随便就可以卡掉。 考虑给相同颜色赋一个一样的随机数，这就不假了。 考虑用主席树维护这个东西，在主席树上二分，每次若左边异或值不为 000 则左边一定存在一组合法解，往那里递归即可。 离散化有小锅，不知为何。","categories":[{"name":"Vps","slug":"Vps","permalink":"http://odalys8191.github.io/categories/Vps/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://odalys8191.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"随机化","slug":"随机化","permalink":"http://odalys8191.github.io/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96/"},{"name":"主席树","slug":"主席树","permalink":"http://odalys8191.github.io/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"name":"数据结构","slug":"数据结构","permalink":"http://odalys8191.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二分","slug":"二分","permalink":"http://odalys8191.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"人类智慧","slug":"人类智慧","permalink":"http://odalys8191.github.io/tags/%E4%BA%BA%E7%B1%BB%E6%99%BA%E6%85%A7/"},{"name":"二进制分拆","slug":"二进制分拆","permalink":"http://odalys8191.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%8B%86/"}]},{"title":"2021-11-15 Test","slug":"2021-11-15-Test","date":"2021-11-15T11:29:36.000Z","updated":"2021-11-15T11:43:26.021Z","comments":true,"path":"Tests/2021-11-15-Test/cm34e3w4t00155vtn4daq2epb/","link":"","permalink":"http://odalys8191.github.io/Tests/2021-11-15-Test/cm34e3w4t00155vtn4daq2epb/","excerpt":"","text":"雀氏码农场，一道构造后的大模拟，一道恶心的数据结构，相形见绌的网络流。 # Solutions: # A 感觉对期望的理解始终不强。 这题又利用了期望的线性性。考虑每个点被删除的概率。总期望就是每个点被删除的期望之和，不难发现就是每个点被删除的概率之和。 每个点何时会被删除？设他的度数为 did_idi​ ，那他会被删除的概率就是 1−1di+11- {1\\over d_i + 1}1−di​+11​。 # B 不会的 DS 题 # C 大模拟题。 # D 咕","categories":[{"name":"Tests","slug":"Tests","permalink":"http://odalys8191.github.io/categories/Tests/"}],"tags":[{"name":"构造","slug":"构造","permalink":"http://odalys8191.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"模拟","slug":"模拟","permalink":"http://odalys8191.github.io/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"数据结构","slug":"数据结构","permalink":"http://odalys8191.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二分图","slug":"二分图","permalink":"http://odalys8191.github.io/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"概率与期望","slug":"概率与期望","permalink":"http://odalys8191.github.io/tags/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/"},{"name":"网络流","slug":"网络流","permalink":"http://odalys8191.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"排列","slug":"排列","permalink":"http://odalys8191.github.io/tags/%E6%8E%92%E5%88%97/"},{"name":"莫队","slug":"莫队","permalink":"http://odalys8191.github.io/tags/%E8%8E%AB%E9%98%9F/"}]},{"title":"CF916E-Jamie and Tree","slug":"CF916E-Jamie-and-Tree","date":"2021-11-14T11:58:46.000Z","updated":"2021-11-14T12:07:15.182Z","comments":true,"path":"Solutions/CF916E-Jamie-and-Tree/cm34e3w5l003n5vtnb9b0fbf7/","link":"","permalink":"http://odalys8191.github.io/Solutions/CF916E-Jamie-and-Tree/cm34e3w5l003n5vtnb9b0fbf7/","excerpt":"","text":"有个换根的操作十分麻烦，于是考虑并不真正地换根。 考虑以 111 为根建树，如果你目前被换成的根为 rtrtrt ，那对于点对 (u,v)(u,v)(u,v) 的 lcalcalca 是什么。 手玩一下不难发现是 lca(u,rt),lca(u,v),lca(v,rt)lca(u, rt), lca(u, v), lca(v, rt)lca(u,rt),lca(u,v),lca(v,rt) 中深度较为深的那个。 那么现在我们要处理的问题就变成了维护 lcalcalca 的子树和。 维护子树和，是 dfndfndfn 的一个经典运用，考虑这题，发现大力讨论就可以做了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w = 1; a = 0; char ch = getchar(); for(; ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;; ch = getchar()) if(ch == &#x27;-&#x27;) w = -1; for(; ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;; ch = getchar()) a = (a * 10) + (ch - &#x27;0&#x27;); a *= w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define fi first#define se second#define pb push_back#define mp make_pair#define mii map&lt;int, int&gt; #define pii pair&lt;int, int&gt; #define vi vector&lt;int&gt;#define si set&lt;int&gt; #define ins insert#define era erase#define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)#define int long longconst int N = 1e5 + 10;int n, m;int val[N];vi to[N];int dep[N], dp[N][32];int dfn[N], dfntot, rnk[N];int low[N];void dfs (int u, int fa) &#123; rnk[dfn[u] = ++dfntot] = u; dep[u] = dep[fa] + 1; dp[u][0] = fa; for (int i = 1; (1 &lt;&lt; i) &lt;= dep[u]; ++i) dp[u][i] = dp[dp[u][i - 1]][i - 1]; for (auto v : to[u]) &#123; if (v == fa) continue; dfs(v, u); &#125; low[u] = dfntot;&#125;int LCA (int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); foR (i, 20, 0) if (dep[x] - (1 &lt;&lt; i) &gt;= dep[y]) x = dp[x][i]; if (x == y) return x; foR (i, 20, 0) if (dp[x][i] != dp[y][i]) x = dp[x][i], y = dp[y][i]; return dp[x][0]; &#125;int LCA_son (int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); foR (i, 20, 0) if (dep[x] - (1 &lt;&lt; i) &gt; dep[y]) x = dp[x][i]; if (dp[x][0] == y) return x; foR (i, 20, 0) if (dp[x][i] != dp[y][i]) x = dp[x][i], y = dp[y][i]; return x; &#125; #define ls x &lt;&lt; 1#define rs x &lt;&lt; 1 | 1 int tag[N &lt;&lt; 2], sum[N &lt;&lt; 2];inline void pushup (int x) &#123; sum[x] = sum[ls] + sum[rs]; &#125;inline void push (int x, int l, int r, int v) &#123; tag[x] += v, sum[x] += (r - l + 1) * v;&#125;inline void pushdown (int x, int l, int r) &#123; if (tag[x]) &#123; int mid = l + r &gt;&gt; 1; push(ls, l, mid, tag[x]), push(rs, mid + 1, r, tag[x]); tag[x] = 0; &#125;&#125;void build (int x, int l, int r) &#123; if (l == r) return (sum[x] = val[rnk[l]]), void(); int mid = l + r &gt;&gt; 1; build (ls, l, mid), build (rs, mid + 1, r); pushup(x);&#125; void update (int x, int l, int r, int ll, int rr, int v) &#123; if (ll &lt;= l &amp;&amp; r &lt;= rr) return push(x, l, r, v), void(); int mid = l + r &gt;&gt; 1; pushdown(x, l, r); if (ll &lt;= mid) update (ls, l, mid, ll, rr, v); if (rr &gt; mid) update(rs, mid + 1, r, ll, rr, v); pushup(x); &#125; int query (int x, int l, int r, int ll, int rr) &#123; if (ll &lt;= l &amp;&amp; r &lt;= rr) return sum[x]; int ans = 0, mid = l + r &gt;&gt; 1; pushdown(x, l, r); if (ll &lt;= mid) ans += query (ls, l, mid, ll, rr); if (rr &gt; mid) ans += query (rs, mid + 1, r, ll, rr); return ans;&#125;int rt, Mck;signed main() &#123; read(n), read(m); For (i, 1, n) read(val[i]); For (i, 2, n) &#123; int u, v; read(u), read(v); to[u].pb(v), to[v].pb(u); &#125; dfs(1, 0); build (1, 1, n); rt = 1; For (i, 1, m) &#123; int op; read(op); if (op == 1) read(rt); if (op == 2) &#123; int u, v, det; read(u), read(v); read(det); int lca = LCA(u, v); int tmp = LCA(u, rt); (dep[tmp] &gt; dep[lca]) ? lca = tmp : Mck = 1; tmp = LCA(v, rt); (dep[tmp] &gt; dep[lca]) ? lca = tmp : Mck = 1; int llccaa = LCA(lca, rt); if (llccaa != lca &amp;&amp; llccaa != rt) &#123; update(1, 1, n, dfn[lca], low[lca], det); continue; &#125; if (lca == rt) push(1, 1, n, det); else if (llccaa == rt) &#123; update (1, 1, n, dfn[lca], low[lca], det); &#125; else &#123; Mck = LCA_son(lca, rt); push(1, 1, n, det); update(1, 1, n, dfn[Mck], low[Mck], -det); &#125; &#125; if (op == 3) &#123; int u; read(u); if (u == rt) &#123; printf (&quot;%lld\\n&quot;, query(1, 1, n, 1, n)); continue; &#125; int lca = LCA(u, rt); if (lca != u &amp;&amp; lca != rt) &#123; printf (&quot;%lld\\n&quot;, query(1, 1, n, dfn[u], low[u])); continue; &#125; if (u == rt) printf (&quot;%lld\\n&quot;, query (1, 1, n, 1, n)); else if ( lca == rt ) printf (&quot;%lld\\n&quot;, query(1, 1, n, dfn[u], low[u])); else &#123; Mck = LCA_son(u, rt); printf (&quot;%lld\\n&quot;, query (1, 1, n, 1, n) - query (1, 1, n, dfn[Mck], low[Mck])); &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"Solutions","slug":"Solutions","permalink":"http://odalys8191.github.io/categories/Solutions/"}],"tags":[{"name":"分类讨论","slug":"分类讨论","permalink":"http://odalys8191.github.io/tags/%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA/"},{"name":"线段树","slug":"线段树","permalink":"http://odalys8191.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"每天一道DS题","slug":"每天一道DS题","permalink":"http://odalys8191.github.io/tags/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93DS%E9%A2%98/"},{"name":"dfn妙用","slug":"dfn妙用","permalink":"http://odalys8191.github.io/tags/dfn%E5%A6%99%E7%94%A8/"}]},{"title":"2021-11-13 Test","slug":"2021-11-13-Test","date":"2021-11-13T14:15:05.000Z","updated":"2021-11-15T11:29:42.856Z","comments":true,"path":"Tests/2021-11-13-Test/cm34e3w4s00135vtndeokbije/","link":"","permalink":"http://odalys8191.github.io/Tests/2021-11-13-Test/cm34e3w4s00135vtndeokbije/","excerpt":"","text":"感觉这场比赛还是存在很多问题的，比如说 T2，T3 完全没有认真思考而是武断地将其规约到我不会的知识点然后摆烂，并且死磕人类智慧的 T4 # Solutions: # A 考试的时候想到的两条结论： 选择多的放在统一生产线上并不优秀，所以贪心地把大区间独立为生产线。 若要选择一些在同一生产线上一定会选择按左端点排序后相邻的一段。 然后结合一些这些结论，假如说有一个区间 AAA 完全包含了区间 BBB ，那对答案贡献 / 限制的部分都是 BBB ，而 AAA 是不会限制的（要求选择的方案与 BBB 有交一定与 AAA 有交，且交的部分一定是 BBB）。所以你可以直接把 AAA 区间删掉，现在你留下了一些两两互不包含的区间，而我们又知道选择的状况一定是连续段，于是直接 O(n3)DpO(n^3)DpO(n3)Dp 计算出把这些区间分为任意个生产线上的答案，再把多的区间贪心分配给包含区间中长度最长的若干个即可。 # B 考虑正难则反，既然满足题意的方案数是个复杂的计数问题我们就可以把问题转化为长度为 mmm 的 010101 串总数减去不符合题意的 010101 串数。 考虑计算不符合题意的 010101 串长什么样，也就是这些串中不包含把符合题意要求的子串–也就是那与给出文本串差距小于一个字符的 n+1n+1n+1 个串。 这是一个多模匹配的问题，我们把这 n+1n+1n+1 个串放在 ACACAC 自动机上，要求就是不能匹配到终止节点，我们设 dpi,jdp_{i,j}dpi,j​ 表示构造到了第 iii 个字符，在自动姬上匹配到了 jjj 的 不合题意的子串数 ，转移为： dpi,j=∑dpi−1,kdp_{i,j}=\\sum dp_{i - 1, k} dpi,j​=∑dpi−1,k​ 其中 kkk 为能转移到 jjj 的一个状态且不为终止状态。 # C 首先是看错题了，以为是区间本质不同回文子串，然后自然想到什么 SAM 上的奇怪东西，然后就 GG 了。 区间本质不同回文子序列，看着没有什么思路吗，为什么会想到区间 dpdpdp ? 信息可以合并，比方说你知道一个子序列是回文的，那在它两边加上一个相同的字符仍为回文串。 是个计数问题，并不关心具体是那些子序列，故信息的合并较为便捷。 那考虑区间 dpdpdp ，经过以上分析，我们最朴素的 dpdpdp 方程不难得出： 主体思想是枚举最外侧两个相同字符，设 Li,jL_{i,j}Li,j​ 表示在 iii 位置左侧第一个颜色为 jjj 的位置 kkk , 类似地设 Ri,jR_{i,j}Ri,j​. 方程即为： dpl,r=[Rl,col≤Lr,col]+[Rl,col&lt;Lr,col]+∑coldpRl,col+1,Lr,col−1dp_{l,r} = [ R_{l,col}\\le L_{r,col} ] + [ R_{l,col}&lt; L_{r,col} ] + \\sum_{col} dp_{R_{l, col} + 1, L_{r, col} - 1} dpl,r​=[Rl,col​≤Lr,col​]+[Rl,col​&lt;Lr,col​]+col∑​dpRl,col​+1,Lr,col​−1​ 前面两个括号表示枚举的最终字符组成长度为 1,21,21,2 的回文子序列。 这样无法通过，考虑优化。 考虑到从 dpl,r−1dp_{l,r-1}dpl,r−1​ 推到 dpl,rdp_{l,r}dpl,r​ 需要多算什么信息，显然只有 rrr 处一个地方会多出一个字符的贡献，设这个地方字符为 ccc ，同时记 uuu 为 Rl,cR_{l,c}Rl,c​ ，vvv 为 Lr,cL_{r,c}Lr,c​ ，我们还要加上的贡献是 dpu+1,r−1dp_{u + 1, r - 1}dpu+1,r−1​ ，同时在 dpu+1,v−1dp_{u+1,v-1}dpu+1,v−1​ 处贡献被记了两次，于是需要减去。 在讨论一波 u,v,ru,v,ru,v,r 的关系即可判断长度为 1,21,21,2 的回文子序列的增量。 于是复杂度就符合要求了。 # D bdfs Thue-Morse sequence","categories":[{"name":"Tests","slug":"Tests","permalink":"http://odalys8191.github.io/categories/Tests/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://odalys8191.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"dp","slug":"dp","permalink":"http://odalys8191.github.io/tags/dp/"},{"name":"AC自动机","slug":"AC自动机","permalink":"http://odalys8191.github.io/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"神奇数学","slug":"神奇数学","permalink":"http://odalys8191.github.io/tags/%E7%A5%9E%E5%A5%87%E6%95%B0%E5%AD%A6/"}]},{"title":"『Code+#1』 大吉大利，今晚吃鸡","slug":"『Code-1』-大吉大利，今晚吃鸡","date":"2021-11-11T13:13:30.000Z","updated":"2021-11-11T13:24:15.240Z","comments":true,"path":"Solutions/『Code-1』-大吉大利，今晚吃鸡/cm34e3w61004r5vtn7pce7kie/","link":"","permalink":"http://odalys8191.github.io/Solutions/%E3%80%8ECode-1%E3%80%8F-%E5%A4%A7%E5%90%89%E5%A4%A7%E5%88%A9%EF%BC%8C%E4%BB%8A%E6%99%9A%E5%90%83%E9%B8%A1/cm34e3w61004r5vtn7pce7kie/","excerpt":"","text":"Links 考虑两种限制： 对于第一种限制，我们设 F(u)F(u)F(u) 为 uuu 点在 SSS 到 TTT 的最短路径上出现的次数，那第一个限制就是要满足 F(a)+F(b)=F(t)F(a) + F(b) = F(t)F(a)+F(b)=F(t) 这个 FFF 可以用两次最短路求出。 对于第二种限制，我们可以考虑枚举每个 uuu 算答案时来满足，即，你枚举一个 uuu ，那 vvv 的 FFF 值你可以算出来，那你用一个桶装 bitset 即可找出满足第一个限制的 vvv ，对于第二个限制，你再分别做两遍拓扑求出与每个点 uuu 在同一条最短路上的点用 bitset 存下来，与一下即可解决。 感觉思维难度并不大，关键是要对限制的合理转化，思维瓶颈在把第一个限制换个形式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w = 1; a = 0; char ch = getchar(); for(; ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;; ch = getchar()) if(ch == &#x27;-&#x27;) w = -1; for(; ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;; ch = getchar()) a = (a * 10) + (ch - &#x27;0&#x27;); a *= w;&#125;#define int long longtemplate &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define fi first#define se second#define pb push_back#define mp make_pair#define mii map&lt;int, int&gt; #define pii pair&lt;int, int&gt; #define vi vector&lt;int&gt;#define si set&lt;int&gt; #define ins insert#define LL long long #define era erase#define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)const int N = 5e4 + 10;struct edge &#123; int to, nxt; LL dis;&#125; e[N &lt;&lt; 1];int head[N], cnt;inline void add (int u, int v, LL w) &#123; e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt; e[cnt].dis = w;&#125;int n, m, S, T;struct Node &#123; int id; LL dis; Node (int Id = 0, LL Dis = 0) &#123; id = Id, dis = Dis; &#125; bool operator &lt; (const Node &amp;a) const &#123; return dis &gt; a.dis; &#125;&#125;;LL dis[2][N], f[2][N];bool vis[N];inline void Dij (int op) &#123; priority_queue &lt;Node&gt; q; memset (dis[op], 0x3f, sizeof dis[op]); memset (vis, 0, sizeof vis); if (op == 0) q.push(Node(S, 0)), dis[op][S] = 0, f[op][S] = 1; else q.push(Node(T, 0)), dis[op][T] = 0, f[op][T] = 1; while (!q.empty()) &#123; Node tmp = q.top(); q.pop(); if (vis[tmp.id]) continue; vis[tmp.id] = 1; int u = tmp.id; for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if (dis[op][v] == dis[op][u] + e[i].dis) f[op][v] += f[op][u]; if (dis[op][v] &gt; dis[op][u] + e[i].dis) &#123; dis[op][v] = dis[op][u] + e[i].dis; f[op][v] = f[op][u]; q.push(Node(v, dis[op][v])); &#125; &#125; &#125;&#125;int shortest, F[N];map&lt;LL, bitset &lt;N&gt;&gt; t;bitset &lt;N&gt; g[2][N];bool InShort (int u) &#123; return (dis[0][u] + dis[1][u] == shortest); &#125;int du[N];void Topu (int op) &#123; static queue &lt;int&gt; q; while (!q.empty()) q.pop(); For (u, 1, n) for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if (dis[op][u] + e[i].dis + dis[op ^ 1][v] == shortest) du[v]++; &#125; For (i, 1, n) &#123; g[op][i].set(), g[op][i][0] = g[op][i][i] = 0; if (!du[i]) q.push(i); &#125;// For (i, 1, n) cout &lt;&lt; g[op][i] &lt;&lt; endl; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if (dis[op][u] + e[i].dis + dis[op ^ 1][v] == shortest) &#123; du[v]--; g[op][v] &amp;= g[op][u]; if (!du[v]) q.push(v); &#125; &#125; &#125;&#125;signed main() &#123; read(n), read(m), read(S), read(T); For (i, 1, m) &#123; int u, v; LL w; read(u), read(v), read(w); add(u, v, w), add(v, u, w); &#125; Dij(0), Dij(1); shortest = dis[0][T]; if (!f[0][T]) return printf (&quot;%lld\\n&quot;, 1ll * n * (n - 1) / 2), 0; For (i, 1, n) &#123;if (InShort(i)) &#123; F[i] = f[0][i] * f[1][i]; &#125; t[F[i]].set(i); &#125; Topu(0), Topu(1); LL Ans = 0; For (i, 1, n) Ans += (t[F[T] - F[i]] &amp; g[0][i] &amp; g[1][i]).count(); printf (&quot;%lld\\n&quot;, Ans &gt;&gt; 1); &#125;","categories":[{"name":"Solutions","slug":"Solutions","permalink":"http://odalys8191.github.io/categories/Solutions/"}],"tags":[{"name":"数数","slug":"数数","permalink":"http://odalys8191.github.io/tags/%E6%95%B0%E6%95%B0/"},{"name":"最短路","slug":"最短路","permalink":"http://odalys8191.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"图论","slug":"图论","permalink":"http://odalys8191.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"拓扑","slug":"拓扑","permalink":"http://odalys8191.github.io/tags/%E6%8B%93%E6%89%91/"}]},{"title":"2021-11-10 KT1","slug":"2021-11-10-KT1","date":"2021-11-11T11:53:09.000Z","updated":"2021-11-11T13:01:39.110Z","comments":true,"path":"uncategorized/2021-11-10-KT1/cm34e3w4r00105vtn5x7wfh1y/","link":"","permalink":"http://odalys8191.github.io/uncategorized/2021-11-10-KT1/cm34e3w4r00105vtn5x7wfh1y/","excerpt":"","text":"这一部分的总结先鸽一会。 # 莓良心 * 莓在执行任务时，收集到了 nnn 份岩浆能源，其中第 iii 份的能量值是 wiw_iwi​ ，她 决定将它们分成恰好 kkk 组带回基地，每一组都要有至少 111 份能源。 每一组能源会对运输设备产生负荷值，若该组有 xxx 份能源，这 xxx 能源能量值之和为 yyy, 则产生的负荷值为 x×yx\\times yx×y 。 每种分组方案产生的负荷是每一组能源产生的负荷值总和，莓想知道所有可能的分组方案产生的负荷之和对 998244353998244353998244353 取模的结果 。 1≤n≤1e61\\le n\\le 1e6 1≤n≤1e6 由于涉及一点二项式反演内容故这里不全。 md 补考试总结去了先不写了。 # 团不过 * 由比滨结衣和雪之下雪乃在玩 NimNimNim 游戏。 共有 nnn 堆石子，双方轮流操作，每次可以从一堆非空石子堆中取走任意个石子，取走最后一个石子的人胜利。 她们决定让由比滨结衣先手，但忘记了每堆初始时含有石子的数目，只知道 每堆至少有 111 个石子，但数目小于 2n2^n2n ，且每堆石子的数目互不相同。 一共有多少种可能的情况使得由比滨结衣能够取胜呢？ 两种情况不同当且仅当存在一堆石子在两种情况中含有的石子数目不同。 由于答案可能很大，你只需要输出答案对 109+710^9 + 7109+7 取模的结果。 友情提示：在 NimNimNim 游戏中，先手必胜等价于各堆石子数目异或之和不为 000 。 n≤1e7n\\le 1e7 n≤1e7 我看的时候完全没有思路 然后，这个每堆石子数量互不相同是个极其有用的结论。 先做一步补集转换，先手必胜的方案数等价于总方案数减去先手 LOST 的方案数 记一个 gig_igi​ 表示到第 iii 堆的石子状况的总方案数，递推式容易得到： gi=∏i=1i(2n−i)g_i = \\prod\\limits_{i=1}^i (2^n - i) gi​=i=1∏i​(2n−i) 记一个 fif_ifi​ 表示到第 iii 堆先手必败石子状态的方案数，做一下讨论： 若前 i−1i-1i−1 堆是先手必败，则说明其前缀异或和为 000 ，那这一堆也要是 000 ，而我们发现每堆石头得大于 111 所以这不合法，于是我们要减去 f_ 若前 i−2i-2i−2 堆是先手必败，则此时的前缀异或和为第 i−1i - 1i−1 堆的堆数，那这一堆也得是，不难发现不合法，也得减去。 所以可以得到递推式： fi=gi−fi−1−fi−2×(i−11)×(2n−1−(i−2))f_i=g_i - f_{i-1} - f_{i-2}\\times \\binom{i-1}{1} \\times (2^n - 1 - (i - 2) ) fi​=gi​−fi−1​−fi−2​×(1i−1​)×(2n−1−(i−2)) # 尽梨了 * 丰之崎学园附近共有 nnn 个商店，在时刻 000 时，英梨梨从学园出发开始购物。 从学园走到任意一个商店，或从一个商店走到另一个商店需要 111 单位时间。 如果英梨梨在时刻 ttt 到达了商店 iii，她需要先花费 ai×t+bia_i\\times t + b_iai​×t+bi​ 的时间排队 然后才能购买这家商店的物品。 英梨梨想知道，在时刻 T+0.5T+ 0.5T+0.5 之前她最多能在多少个不同商店买到物品呢？ 这里假定只会在走路和排队上消耗时间，购买物品不消耗时间。 n≤2e5,T≤1e9n\\le 2e5,T\\le 1e9 n≤2e5,T≤1e9 这是一道感觉比较套路的题，首先直觉上感觉到若我们确定了一些选东西，那拿出来的顺序是一定的，于是我们想到先按一个东西排序。 那么我们考虑在 ttt 时刻选到 iii 然后立刻选 jjj 的消耗是什么，这样通过交换邻项解一个不等式可得出排序的关键字。 然后就可以 dpdpdp 了，设 dpi,jdp_{i,j}dpi,j​ 表示到第 iii 个店上一个走到 jjj 的最小时间，转移显然。 然后我们考虑这个只要 ai&gt;0a_i &gt; 0ai​&gt;0 时间增长速率极快，于是我们把 ai=0a_i=0ai​=0 的拿出了先不管，跑一遍 dpdpdp ，大概 log⁡\\loglog 层就会跑满时间上界，再对 ai=0a_i=0ai​=0 的做一遍贪心。 # 七负我 * 有一个 nnn 个点 mmm 条边的图。给一些点分配一些点权（可以是任意非负实数）使得所有点点权和为 xxx（点权可以为 000）。一条边 ⟨u,v⟩\\langle u,v \\rangle⟨u,v⟩ 的贡献为 uuu 的点权与 vvv 的点权的乘积。问所有边贡献和最大是多少。 1≤n≤40,1≤x≤1001\\le n\\le 40,1\\le x\\le 100 1≤n≤40,1≤x≤100 nb 贪心题！ 直觉上可以推出的结论是一定是把点权和平均分配到点上，然后贡献尽量多的边是更优秀的。 然后你可能会想到放在一张完全图上我是不敢想到 考虑证明这个 nb 结论。 对于点对 (u,v)(u,v)(u,v) 设他们无边，设当前最优的答案给 uuu 分配了 fuf_ufu​ 权值，给 vvv 分配 fvf_vfv​ ，连接他们的点权和不妨记做 su,svs_u, s_vsu​,sv​ ，那这一部分对于答案的贡献就是 fu×su+fv×svf_u\\times s_u + f_v\\times s_vfu​×su​+fv​×sv​ 不妨设 su≥svs_u\\ge s_vsu​≥sv​ 可以发现，把分配给 vvv 的权全给 uuu 一点不劣。 然后就是一个最大团的问题了， meet in mid\\texttt{meet in mid}meet in mid 一下即可解决。 感觉这种看着就很贪心结论的题还是要凭着直觉大胆猜测结论，再小心求证。 而贪心结论的证明则考虑交换邻项来反证或者从一些局部情况来归纳 这里就是要观察一对无边的点对对答案的贡献来归纳了。 感觉比较玄妙。","categories":[],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://odalys8191.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"数数","slug":"数数","permalink":"http://odalys8191.github.io/tags/%E6%95%B0%E6%95%B0/"},{"name":"dp","slug":"dp","permalink":"http://odalys8191.github.io/tags/dp/"},{"name":"第二类斯特林数","slug":"第二类斯特林数","permalink":"http://odalys8191.github.io/tags/%E7%AC%AC%E4%BA%8C%E7%B1%BB%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"},{"name":"二项式反演","slug":"二项式反演","permalink":"http://odalys8191.github.io/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/"}]},{"title":"2021-11-8-Test","slug":"2021-11-8-Test","date":"2021-11-08T12:52:41.000Z","updated":"2021-11-08T13:11:40.839Z","comments":true,"path":"Tests/2021-11-8-Test/cm34e3w4v001d5vtnbkl74dc3/","link":"","permalink":"http://odalys8191.github.io/Tests/2021-11-8-Test/cm34e3w4v001d5vtnbkl74dc3/","excerpt":"","text":"实际：100 + 70 + 0 + 0 能做：100 + 100 + 0 + 0 这场的 T1 比较简单但花了 2h 才写出来，导致浪费了很多时间 # Solutions: # a 考虑两个点之间的连边只有出现奇数次的才会再最后被算到 于是使用 ll 模拟 bitset 即可。 # b 这种题为啥我会开始认为没有单调性呢？ 于是二分一个答案 xxx ，现在要求每个段平均值大于等于 xxx 要能分到 kkk 块，于是我们使用一个 dpdpdp 求最多能分几块。 于是我们就得到一个 O(n2log⁡a)\\mathrm O(n^2 \\log a)O(n2loga) 的做法 考虑优化，就是一个线性规划一样的东西，于是用 BIT 简单维护即可。 # c 神仙题，感觉有铲雪那味。 大概是，你在每条树边上放两条边，于是把原问题映射为在两条树边在每个点上做匹配的新问题。 考虑这个新问题，这两条边在匹配过程中有区别的，所以我们会算重，一个原问题中构造管道的方案对应着 2n−c−12^{n-c-1}2n−c−1 种方案，因为你可以先任意构造一种然后交换每对边的匹配，而相同管道的时候你交换就算重了，所以你要减去相同管道 ccc 的方案，于是你发现就是题目那个奇怪的 2−c2^{-c}2−c 权值，那对于新问题求解后除以 2n2^n2n 就好了。 对于新问题，每个点是独立的，于是分别处理。对于每个点，可以看做 nnn 个颜色的球，每个颜色有两个球，取两个不同颜色球匹配的方案数。设 dpi,0/1/2dp_{i,0/1/2}dpi,0/1/2​ 表示已经取了 iii 对，还有 0/1/20/1/20/1/2 个空余球，然后凭直觉 dpdpdp 即可。 # d 鸽","categories":[{"name":"Tests","slug":"Tests","permalink":"http://odalys8191.github.io/categories/Tests/"}],"tags":[{"name":"暴力","slug":"暴力","permalink":"http://odalys8191.github.io/tags/%E6%9A%B4%E5%8A%9B/"},{"name":"dp","slug":"dp","permalink":"http://odalys8191.github.io/tags/dp/"},{"name":"数据结构","slug":"数据结构","permalink":"http://odalys8191.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"CDQ","slug":"CDQ","permalink":"http://odalys8191.github.io/tags/CDQ/"}]},{"title":"2021-11-4-Test","slug":"2021-11-4-Test","date":"2021-11-05T11:57:03.000Z","updated":"2021-11-05T12:23:34.385Z","comments":true,"path":"Tests/2021-11-4-Test/cm34e3w4u00185vtnca1kdvdc/","link":"","permalink":"http://odalys8191.github.io/Tests/2021-11-4-Test/cm34e3w4u00185vtnca1kdvdc/","excerpt":"","text":"# Solutions # A 设 EiE_iEi​ 为 iii 到 i+1i + 1i+1 期望步数","categories":[{"name":"Tests","slug":"Tests","permalink":"http://odalys8191.github.io/categories/Tests/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://odalys8191.github.io/tags/dp/"},{"name":"期望","slug":"期望","permalink":"http://odalys8191.github.io/tags/%E6%9C%9F%E6%9C%9B/"},{"name":"分治","slug":"分治","permalink":"http://odalys8191.github.io/tags/%E5%88%86%E6%B2%BB/"},{"name":"原根","slug":"原根","permalink":"http://odalys8191.github.io/tags/%E5%8E%9F%E6%A0%B9/"},{"name":"min25","slug":"min25","permalink":"http://odalys8191.github.io/tags/min25/"}]},{"title":"2021-11-5-Test","slug":"2021-11-5-Test","date":"2021-11-05T11:29:52.000Z","updated":"2021-11-05T11:56:02.766Z","comments":true,"path":"Tests/2021-11-5-Test/cm34e3w4u001a5vtn8s5fcwpp/","link":"","permalink":"http://odalys8191.github.io/Tests/2021-11-5-Test/cm34e3w4u001a5vtn8s5fcwpp/","excerpt":"","text":"期望：100 + 0 + 0 实际： 0 + 0 + 0 又 boom 0 了 T1 没调出来 + 暴力写挂 传世经典 # Solutions: # A 考虑合并两棵树 x,yx,yx,y 对答案的影响，设第一棵树的大小为 sizusiz_usizu​ ，原答案为 ansuans_uansu​ 。 设合并点为 a,ba,ba,b 路径长度为 vvv. 那合并后的答案就是： ans_x+ans_y+v\\times siz_x\\times siz_y + sum(x, a) \\times siz_y+ sum(y, b)\\times siz_x$$。 现在我们有两个急需解决的问题，一是如何开下空间，二是计算一棵树内所有点到一个点的距离。 有一个比较聪明的办法是，像线段树一样记录每条边两边连着的子树等信息，然后分治计算距离，这样可以把空间压到边数级别。 为了更快，我们使用一个记忆化。 有一个比较麻烦的地方是，点数是 $2^{64}$ 级别的，如果你直接记录的话一乘就爆，模的话大小关系就丢失了，所以你可以开两个 $siz$ or 使用 `__int128` 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w=1; a=0; char ch=getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;;ch=getchar()) if(ch == &#x27;-&#x27;) w=-1; for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar()) a=(a&lt;&lt;3)+(a&lt;&lt;1)+(ch^48); a*=w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define fi first#define se second#define pb push_back#define mp make_pair#define mii map&lt;int, int&gt; #define pii pair&lt;int, int&gt; #define vi vector&lt;int&gt; #define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)const int M = 66;const int Mod = 1e9 + 7;#define int __int128inline int Add (int x, int y) &#123; return (x + y) &gt;= Mod ? (x + y - Mod) : (x + y);&#125;inline int Mul (int x, int y) &#123; return (1ll * x * y &gt;= Mod) ? (1ll * x * y % Mod) : (x * y);&#125;#define ll long longstruct Tree &#123; ll a, b, v; ll ans, lid, rid; ll siz;&#125; tr[100];#define lsiz tr[tr[id].lid].sizmap &lt; pair&lt;ll, pii&gt; , ll&gt; mckc;int Dis (int id, int u, int v) &#123; if (u == v) return 0; if (id == 0) return 0; if (u &gt; v) swap(u, v); if (mckc[mp(id, mp(u, v))]) return mckc[mp(id, mp(u, v))]; if (v &lt;= lsiz) return mckc[mp(id, mp(u, v))] = Dis(tr[id].lid, u, v); if (u &gt; lsiz) return mckc[mp(id, mp(u, v))] = Dis(tr[id].rid, u - lsiz, v - lsiz); return mckc[mp(id, mp(u, v))] = Add(Add(Dis(tr[id].lid, tr[id].a, u), tr[id].v), Dis(tr[id].rid, tr[id].b - lsiz, v - lsiz)); &#125; map &lt; pii, ll &gt; mck;int sum (int id, int x) &#123; if (mck[mp(id, x)]) return mck[mp(id, x)] ; if (id == 0) return 0; if (x &lt;= lsiz) &#123; int res = sum(tr[id].rid, tr[id].b - lsiz); res = Add(res, Mul(tr[tr[id].rid].siz, tr[id].v)); res = Add(res, Mul(tr[tr[id].rid].siz, Dis(tr[id].lid, tr[id].a, x))); return mck[mp(id, x)] = Add(res, sum(tr[id].lid, x)); &#125; else &#123; int res = sum(tr[id].lid, tr[id].a); res = Add(res, Mul(tr[tr[id].lid].siz, tr[id].v)); res = Add(res, Mul(tr[tr[id].lid].siz, Dis(tr[id].rid, tr[id].b - lsiz, x - lsiz))); return mck[mp(id, x)] = Add(res, sum(tr[id].rid, x - lsiz)); &#125;&#125;inline void write(int x)&#123; if (x &lt; 0) x = ~x + 1, putchar(&#x27;-&#x27;); if (x &gt; 9) write(x / 10); putchar(x % 10 + &#x27;0&#x27;);&#125;inline void merge (int id, int id1, int a, int id2, int b, int v) &#123; tr[id].ans = Add(tr[id1].ans, tr[id2].ans); tr[id].ans = Add(tr[id].ans, Mul(tr[id1].siz, sum(id2, b))); tr[id].ans = Add(tr[id].ans, Mul(tr[id2].siz, sum(id1, a))); tr[id].ans = Add(tr[id].ans, Mul(tr[id1].siz, Mul(tr[id2].siz, v))); tr[id].siz = tr[id1].siz + tr[id2].siz; tr[id].a = a, tr[id].b = b + tr[id1].siz; tr[id].v = v; tr[id].lid = id1, tr[id].rid = id2; write(tr[id].ans); putchar(&#x27;\\n&#x27;); &#125;signed main() &#123; int cases; read(cases); while (cases--) &#123; int m; read(m); tr[0].siz = 1; For (i, 1, m) &#123; int a, b, c, d, v; read(a); read(b); read(c); read(d); read(v); c++, d++; merge(i, a, c, b, d, v); &#125; mck.clear(); mckc.clear(); For (i, 0, m) tr[i].siz = tr[i].a = tr[i].b = tr[i].lid = tr[i].rid = tr[i].v = 0; &#125;&#125; ### B 考虑一个排列，把原问题转化为第 $i$ 次可删掉第 $i$ 个点，然后把 $i+1\\~ n$ 用 $p$ 的概率鲨掉。 可以发现这两个问题等价 于是设 $dp_{i,j}$ 为当前正在决策第 $i$ 个点删不删，然后 $i\\to n$ 面临被鲨掉的风险了 $j$ 次。 于是有转移方程： $$dp_{i,j}=dp_{i-1,j-1}\\times (1-p)^{j-1} + dp_{i-1,j}\\times (1-(1-p)^j)$$. 前一半的意思是 $i-1$ 个决策把 $i-1$ 删掉了，后面承受了一次被鲨掉的风险；后面是第 $i-1$ 个是被鲨掉的。。 123456789101112131415161718192021222324252627282930313233343536373839404142const int Mod = 258280327;inline int Mul (int x, int y) &#123; return (1ll * x * y) &gt;= Mod ? (1ll * x * y % Mod) : (x * y);&#125;inline int Add (int x, int y) &#123; return (x + y) &gt;= Mod ? (x + y - Mod) : (x + y);&#125;int qpow (int a, int b) &#123; int base = a, ans = 1; while (b) &#123; if (b &amp; 1) ans = Mul(base, ans); base = Mul(base, base); b &gt;&gt;= 1; &#125; return ans;&#125;const int N = 3010;int Inv (int a) &#123; return qpow(a, Mod - 2); &#125;int n, x, y, pw[N];int dp[N][N], Ans[N];int main() &#123; int cases; read(cases); while (cases--) &#123; read(n); read(x); read(y); int p = Mul(x, Inv(y)); pw[0] = 1; For (i, 1, n) pw[i] = Mul(pw[i - 1], (1 - p + Mod)); memset (dp, 0, sizeof dp); memset (Ans, 0, sizeof Ans); dp[0][0] = 1; int invn = Inv(n); For (i, 1, n) For (j, 1, i) dp[i][j] = Add(Mul(dp[i - 1][j - 1], pw[j - 1]), Mul(dp[i - 1][j], (1 - pw[j] + Mod))); For (i, 0, n - 1) &#123; For (j, i, n - 1) Ans[i] = Add(Ans[i], Mul(dp[j][i], pw[i])); &#125; For (i, 0, n - 1) printf (&quot;%d &quot;, Mul(Ans[i], invn)); puts(&quot;&quot;); &#125;&#125; ### C 结论题 可用 kmp 打表找到 然后高精","categories":[{"name":"Tests","slug":"Tests","permalink":"http://odalys8191.github.io/categories/Tests/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://odalys8191.github.io/tags/dp/"},{"name":"概率","slug":"概率","permalink":"http://odalys8191.github.io/tags/%E6%A6%82%E7%8E%87/"},{"name":"分治","slug":"分治","permalink":"http://odalys8191.github.io/tags/%E5%88%86%E6%B2%BB/"},{"name":"记忆化","slug":"记忆化","permalink":"http://odalys8191.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96/"},{"name":"高精","slug":"高精","permalink":"http://odalys8191.github.io/tags/%E9%AB%98%E7%B2%BE/"}]},{"title":"2021-11-1-Test","slug":"2021-11-1-Test","date":"2021-11-01T10:46:55.000Z","updated":"2021-11-01T11:35:42.929Z","comments":true,"path":"Tests/2021-11-1-Test/cm34e3w4q000y5vtn9abxdguf/","link":"","permalink":"http://odalys8191.github.io/Tests/2021-11-1-Test/cm34e3w4q000y5vtn9abxdguf/","excerpt":"","text":"预期: 100 + 100 + 100 + 60 = 360 实际: 100 + 50 + 100 + 60 + 310 最高: 100 + 100 + 100 + 60 = 360 挂分挂在了 cout 上 /sad T1 考场上 1min 就猜到了结论，没开 ll 吃了 1min 罚时，于 9min AC 如果是正式比赛可能会花个 20 分钟打个表验证一下 T2 大概知道了答案的上界，构造的下一步就是找到上界何时取到了，然后被摆王秒切了 T3 开始走进了 dp 的死胡同，总感觉如果二分 + 贪心就是傻逼题了… 事实证明的确是傻逼题。 T4 不会啊，一边摆一边写了 60 跑路 # Solutions # a 考虑四个因数的话，111 和本身肯定算两个，然后你上两个与 111 相差 nnn 以上的素数。 大胆猜想这是对的，打表验证发现确实是对的。 # b 完全图每个点度数为 nnn ，每消去一棵生成树至少也会在一个点上消去 222 的度数，于是猜想答案上界是 n2n\\over 22n​ 然后考虑如何构造，可以直接用一个折线连边的构造法，一定能删掉一半。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w=1; a=0; char ch=getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;;ch=getchar()) if(ch == &#x27;-&#x27;) w=-1; for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar()) a=(a&lt;&lt;3)+(a&lt;&lt;1)+(ch^48); a*=w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define fi first#define se second#define pb push_back#define mp make_pair#define mii map&lt;int, int&gt; #define pii pair&lt;int, int&gt; #define vi vector&lt;int&gt; #define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)const int N = 1e6 + 10;pii Ans[N];int id[N]; int cnt;int l, r, n;inline void solve () &#123; int cur = 0; For (i, 1, n - 1) &#123; if (i &amp; 1) Ans[++cnt] = mp(id[l - cur], id[l + cur + 1]); else &#123; Ans[++cnt] = mp(id[l + cur + 1], id[l - cur - 1]), cur++; &#125; &#125;&#125;int main() &#123; int cases, cas = 0; read(cases); while (cases--) &#123; read(n); int ret = n / 2; printf (&quot;Case #%d: %d\\n&quot;, ++cas, ret); cnt = 0; For (i, 1, n) id[i] = i; For (i, 1, n) id[i + n] = id[i]; For (i, 1, n) id[i + 2 * n] = id[i]; l = n + 1, r = 2 * n; For (i, 1, ret) &#123; solve(); l++, r++; &#125; For (i, 1, cnt) cout &lt;&lt; Ans[i].fi &lt;&lt; &quot; &quot; &lt;&lt; Ans[i].se &lt;&lt; endl; &#125;&#125; 因为 cout ，我挂掉了 50pts # c 二分一个答案，然后贪心即可 # d 考虑转换一步题意，使用一个 preipre_iprei​ 数组表示与第 iii 个位置相同的字符上一个出现的位置，那若两个子串拿出来 preprepre 数组相等则表示这两个子串同构。 然后我们考虑到每次从前 / 后加入一个字符， 只有一个地方的 preprepre 值会变化，又它要统计不同的子串数，于是我们可以想到利用 SA 统计本质不同子串的思想，从后往前每次加一个字符，记录每次的后缀 preprepre ，然后后缀排序一下求出相邻 LCPLCPLCP 从而得出答案。 然后考虑每次的后缀 preprepre 咋求，主席树是 2log⁡2\\log2log 的，考虑使用 YSH 超级可持久化数组可持久化块状数组，即正常的主席树是一个二叉树的结构新加一个点就共产共妻继承一连串的儿子关系，于是伟大的 YSH 就想到放在分块上，普通的分块相当于是一个 n\\sqrt nn​ 叉树，你可以类似的编出一个做法。 然后相邻的 LCPLCPLCP 咋算，就用把后缀 preprepre 在放在 hash 上，二分一个 LCPLCPLCP 若 hash 值相同就挪个端点之类的 然后后缀数字咋比较大小，你就把 LCPLCPLCP 后一位比较一下就好了 还是个挺有意思的题目 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w=1; a=0; char ch=getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;;ch=getchar()) if(ch == &#x27;-&#x27;) w=-1; for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar()) a=(a&lt;&lt;3)+(a&lt;&lt;1)+(ch^48); a*=w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define int long long#define fi first#define se second#define pb push_back#define mp make_pair#define mii map&lt;int, int&gt; #define pii pair&lt;int, int&gt; #define vi vector&lt;int&gt; #define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)#define ll long longconst int N = 5e4 + 10, Blo = 256, Base = 1e6 + 3, Mod = 1e9 + 7;//int pw[N];struct Block &#123; int h[Blo + 10], v[Blo + 10]; void upd (int x, int y) &#123; v[x] = y; For (i, 1, Blo) h[i] = (1ll * h[i - 1] * Base + v[i]) % Mod; &#125;&#125; c[N &lt;&lt; 1];int tot, n, m; struct CanStill &#123; int id[Blo + 10], s[Blo + 10]; void Init() &#123; memset (id, 0, sizeof id); memset (s, 0, sizeof s); &#125; void upd (int u, int y) &#123; int p = (u - 1) / Blo + 1, x = u - (p - 1) * Blo; c[++tot] = c[id[p]]; c[tot].upd(x, y), id[p] = tot; For (i, 1, Blo) s[i] = (1ll * s[i - 1] * pw[Blo] + c[id[i]].h[Blo]) % Mod; &#125; int ask (int u) &#123; int p = (u - 1) / Blo + 1, x = u - (p - 1) * Blo; return (1ll * s[p - 1] * pw[x] + c[id[p]].h[x]) % Mod; &#125; // Get the pre hash int get (int u) &#123; if (u &gt; n) return -1; int p = (u - 1) / Blo + 1, x = u - (p - 1) * Blo; return c[id[p]].v[x]; &#125;&#125; a[N];int b[N];int LCP (int x, int y) &#123; if (x == y) return n - x + 1; if (x &gt; y) swap(x, y); int l = 0, r = n - y + 1; while ( l &lt; r ) &#123; int mid = (l + r + 1) &gt;&gt; 1; if (a[x].ask(x + mid - 1) == a[y].ask(y + mid - 1)) l = mid; else r = mid - 1; &#125; return l;&#125;int sa[N];int las[N]; bool cmp (int x, int y) &#123; int w = LCP(x, y); return a[x].get(x + w) &lt; a[y].get(y + w); &#125;signed main() &#123; while ( ~scanf (&quot;%lld&quot;, &amp;n) ) &#123; pw[0] = 1, tot = 0; ll Ans = 0; For (i, 1, n) &#123; read(b[i]); pw[i] = 1ll * pw[i - 1] * Base % Mod; las[i] = 0; &#125; a[n + 1].Init(); foR (i, n, 1) &#123; Ans += i; a[i] = a[i + 1], sa[i] = i; if (las[b[i]]) a[i].upd(las[b[i]], las[b[i]] - i); las[b[i]] = i; &#125; sort (sa + 1, sa + n + 1, cmp); For (i, 1, n - 1) Ans -= LCP(sa[i], sa[i + 1]); printf (&quot;%lld\\n&quot;, Ans); &#125;&#125;","categories":[{"name":"Tests","slug":"Tests","permalink":"http://odalys8191.github.io/categories/Tests/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://odalys8191.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"构造","slug":"构造","permalink":"http://odalys8191.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"可持久化块状数组","slug":"可持久化块状数组","permalink":"http://odalys8191.github.io/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%9D%97%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"后缀数组","slug":"后缀数组","permalink":"http://odalys8191.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"图论","slug":"图论","permalink":"http://odalys8191.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"素数","slug":"素数","permalink":"http://odalys8191.github.io/tags/%E7%B4%A0%E6%95%B0/"},{"name":"二分","slug":"二分","permalink":"http://odalys8191.github.io/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"2021-10-30-Test","slug":"2021-10-30-Test","date":"2021-10-31T12:00:57.000Z","updated":"2021-10-31T12:31:57.950Z","comments":true,"path":"Tests/2021-10-30-Test/cm34e3w4p000w5vtng5lehqyy/","link":"","permalink":"http://odalys8191.github.io/Tests/2021-10-30-Test/cm34e3w4p000w5vtng5lehqyy/","excerpt":"","text":"写了 100 + 30 + 30 + 0 可以 100 + 30 + 100 + 0 阶梯 NIM 忘记了，那没事了 T3 属于是学傻了，使用到了正睿集训遇到的小技巧然后生生转成了一道 Ynoi ，然鹅以前记过的一个简单结论可以快速做出此题 # Solutions # shuffle 给你一些二元组 a,ba,ba,b ，求 x,yx,yx,y 使得 ∏i=1n(ai2+bi2)≡x2+y2(mod264)\\prod_{i=1}^n (a_i^2+b_i^2) \\equiv x^2+y^2 \\pmod{2^{64}}∏i=1n​(ai2​+bi2​)≡x2+y2(mod264) 做线性 只有两个二元组的部分分是一个提示 你考虑把 (a2+b2)(c2+d2)(a^2+b^2)(c^2+d^2)(a2+b2)(c2+d2) 划一划，配成两个完全平方，然后变成了 (ac+bd)2+(ad−bc)2(ac+bd)^2+(ad-bc)^2(ac+bd)2+(ad−bc)2 这样就可以做两个了 然后多个你就一个个做就是了 # god 一个单调不降序列，你每次可以在某个位置减去大于 111 的值并要求还是单调递增序列，求先手必胜？ qqq 次在这个序列前后加数字 考虑把差分序列建出来，你在一个地方减去值相当于在差分序列上前一个减后一个加，然后就想到于把前一个移动到后一个，然后就是阶梯 nim 游戏的板子了，动态维护一个奇数位置和偶数位置的和即可。 # wanted 一棵树，qqq 次询问一个点对(x,y),x∈[l1,r1],y∈[l2,r2](x,y),x\\in [l1,r1], y\\in [l2,r2](x,y),x∈[l1,r1],y∈[l2,r2] 求最大距离点对 看到这种区间连边的方式，我想到了正睿那题，放在矩阵上。 由于我们可以 O(1)O(1)O(1) 算出矩阵上每个位置的值，相当于我们要求出一个矩形最大值 然后我就不会了，听说跟一道 Ynoi 很像。 正经做法是回忆起树的直径是可以合并的，然后直接线段树维护标号区间的直径即可。 # ambition 懒得写 这种最大独立集 np 问题肯定不能硬着做 考虑这是带权最大独立集，每个点权之间差的很大，所以我们从标号小的点向标号大的点连边给这张无向图定个向，此时我们边的含义就是选了指向的点就不能选我这个点，由于点权之间差距很大，可以证明，只要选一个标号大的就比选后面一连串标号小的要优秀。 那不难发现我们其实可以把选上的点标记为必败点，所以指向它的点就是必胜点，我们可以把 SG 函数写出来，最后 SG 函数为 0 的点就是选出的点。 那对于一个合法的点 fi,j,k...f_{i,j,k...}fi,j,k...​ 我们可以把每一维分开考虑，相当于是在 KKK 张一样的图上每次跑一步，所以我们的 SG(fi,j,k...)=SG(fi)⊕SG(fj)......SG(f_{i,j,k...}) = SG(f_i)\\oplus SG(f_j)......SG(fi,j,k...​)=SG(fi​)⊕SG(fj​)...... 把柿子写出来，再上一个 FWT 优化即可。","categories":[{"name":"Tests","slug":"Tests","permalink":"http://odalys8191.github.io/categories/Tests/"}],"tags":[{"name":"博弈论","slug":"博弈论","permalink":"http://odalys8191.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"妙题","slug":"妙题","permalink":"http://odalys8191.github.io/tags/%E5%A6%99%E9%A2%98/"},{"name":"数据结构","slug":"数据结构","permalink":"http://odalys8191.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"阶梯nim","slug":"阶梯nim","permalink":"http://odalys8191.github.io/tags/%E9%98%B6%E6%A2%AFnim/"},{"name":"小学奥数","slug":"小学奥数","permalink":"http://odalys8191.github.io/tags/%E5%B0%8F%E5%AD%A6%E5%A5%A5%E6%95%B0/"},{"name":"树的直径","slug":"树的直径","permalink":"http://odalys8191.github.io/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"},{"name":"子集卷积系统","slug":"子集卷积系统","permalink":"http://odalys8191.github.io/tags/%E5%AD%90%E9%9B%86%E5%8D%B7%E7%A7%AF%E7%B3%BB%E7%BB%9F/"}]},{"title":"ARC106","slug":"ARC106","date":"2021-10-30T03:34:30.000Z","updated":"2021-11-03T12:44:45.407Z","comments":true,"path":"Vps/ARC106/cm34e3w56002a5vtndild7qaj/","link":"","permalink":"http://odalys8191.github.io/Vps/ARC106/cm34e3w56002a5vtndild7qaj/","excerpt":"","text":"可以叫刷题吧 # A 利用经典结论，一个数较小因子一定小于 n\\sqrt nn​ . 然后直接枚举即可 # B 搞个栈 # C 简单构造 拉棵生成树出来随便构造即可 这种跟无向图联通有关的第一时间想想生成树 # D 开始看错题了 \\yun 所以函数任意怎么做啊 然后你一开始是 AB 最开始一定是直接加 f_ 以 fAB=Af_{AB}=AfAB​=A 为例，另一种本质相同 那就是 AA...AB 这样的串了 若 fAB=Af_{AB} = AfAB​=A 那方案数唯一 看到这里，我们发现这是一个分讨题 否则，我们能构造出 A..BAABAB 这种可能有多个 B 但两两不交的形式 考虑 fBAf_{BA}fBA​ 若为 B 那可以有很多 B 连续了，答案就是 2^ 否则，考虑一个 dp_{u}{0] 放到 uuu 颜色为 A/B 这样推推转移，发现就是 fibn−2fib n-2fibn−2 # E 这种奇怪的东西为什么会想到区间 dpdpdp 呢？ 所以是不是奇怪的限制都可以考虑区间 dpdpdp。 哦，限制可以简单被两边表示？ 考虑设 dpl,rdp_{l,r}dpl,r​ 表示 lll 和 rrr 都被标记后，中间元素的期望个数 好像好多区间 dpdpdp 都对两边特殊处理了？如 CSP2021 T2 这种区间 dpdpdp 就是想到了转移就很简单了 可得转移柿子： dpl,r=∑ak∈[l,r]dpl,k+dpk,r∣k∣+1dp_{l,r}={\\sum_{a_k\\in [l, r]} dp_{l,k} + dp_{k, r}\\over |k|} + 1 dpl,r​=∣k∣∑ak​∈[l,r]​dpl,k​+dpk,r​​+1 意思就是在中间找个可以标记的点打标记 一开始我还理解了那个 +1 好久，现在看来可能就是把每个标记点贡献全加即可，即 1k×k{1\\over k} \\times kk1​×k 就放外面了 这样 n3n^3n3 信仰够的话可能能过 正经做法是搞个 BIT\\texttt{BIT}BIT 优化一下。 咋优化咧，大概是你在每个左右端点 l,rl,rl,r 做短长度的时候，把所有 kkk (那时还叫 rrr) 放在 lll 的 BIT\\texttt{BIT}BIT 上，要用的时候再区间查一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w=1; a=0; char ch=getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;;ch=getchar()) if(ch == &#x27;-&#x27;) w=-1; for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar()) a=(a&lt;&lt;3)+(a&lt;&lt;1)+(ch^48); a*=w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define fi first#define se second#define pb push_back#define mp make_pair#define mii map&lt;int, int&gt; #define pii pair&lt;int, int&gt; #define vi vector&lt;int&gt; #define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)const int N = 2020;const int Mod = 1e9 + 7;inline int Mul (int x, int y) &#123; return (1ll * x * y) &gt;= Mod ? (1ll * x * y % Mod) : (x * y); &#125;inline int Add (int x, int y) &#123; return (x + y) &gt;= Mod ? (x + y - Mod) : (x + y); &#125;inline int Sub (int x, int y) &#123; return (x &lt; y) ? (x + Mod - y) : (x - y); &#125;int n;struct BIT &#123; int a[N]; inline void clear() &#123; memset (a, 0, sizeof a); &#125; inline void upd (int x, int v) &#123; for (; x &lt;= n; x += (x &amp; (-x))) a[x] = Add(a[x], v); &#125; int ask (int l, int r) &#123; if (l &gt; r) return 0; int Ans = 0; for (; r; r -= (r &amp; (-r))) Ans = Add(Ans, a[r]); l--; for (; l; l -= (l &amp; (-l))) Ans = Sub(Ans, a[l]); return Ans; &#125;&#125; L[N], R[2];int dp[N][N];#define ll long longint a[N], inv[N];signed main() &#123; read(n); For (i, 1, n) read(a[i]); a[0] = 0, a[n + 1] = n + 1; inv[1] = 1; for (int i = 2; i &lt; N; i++) inv[i] = (ll) (Mod - Mod / i) * inv[Mod % i] % Mod; For (r, 1, n + 1) &#123; R[0].clear(), R[1].clear(); foR (l, r - 1, 0) &#123; dp[l][r] = Add((R[0].ask(a[l] + 1, a[r] - 1)), (L[l].ask(a[l] + 1, a[r] - 1))); int k = R[1].ask(a[l] + 1, a[r] - 1); if (!k) dp[l][r] = 0; else dp[l][r] = (1ll * dp[l][r] * inv[k] + 1) % Mod; if (l) &#123; R[0].upd(a[l], dp[l][r]); R[1].upd(a[l], 1); &#125; L[l].upd(a[r], dp[l][r]); &#125; &#125; printf (&quot;%lld\\n&quot;, dp[0][n + 1]); return 0;&#125; # F 限制我做不出 AT 的一大重要因素竟然是读不懂题？ 考虑这种树上求点对最大距离的，一般都跟直径有关。 考虑树上的直径，若两点同色，那这种染色方案贡献一定就是直径长度了，其他点随意染色统计一下即可。 否则则为两点异色，那不妨统计每个点到直径两点距离记做点对 (a,b)(a, b)(a,b) 。现在要做的就是给每个点选一个 aaa 或 bbb 然后求最大值 正着求显然不好，我们考虑求每个贡献的方案数，我们可以使用一个比较经典的套路，即从小到大依次算每个距离的贡献，也就是对于每个 ddd ， 求出 ans≥dans \\ge dans≥d 的方案数，把方案数累加起来就是答案啊 ans≥dans\\ge dans≥d 的不好求，我们可以转而求 ans≤dans\\le dans≤d 的方案数，那么，对于每个 ddd 若存在一个点对的 min(x,y)min(x, y)min(x,y) 都大于 ddd ，那方案数为 000 ；否则方案数即为两个值都小于 ddd 的点两个任意选，也就是一个 222 的次幂形式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w=1; a=0; char ch=getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;;ch=getchar()) if(ch == &#x27;-&#x27;) w=-1; for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar()) a=(a&lt;&lt;3)+(a&lt;&lt;1)+(ch^48); a*=w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define fi first#define se second#define pb push_back#define mp make_pair#define mii map&lt;int, int&gt; #define pii pair&lt;int, int&gt; #define vi vector&lt;int&gt; #define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)const int N = 2e5 + 10;const int Mod = 1e9 + 7;inline int Mul (int x, int y) &#123; return (1ll * x * y &gt;= Mod) ? (1ll * x * y % Mod) : (x * y); &#125;inline int Add (int a, int b) &#123; return (a + b &gt;= Mod) ? (a + b - Mod) : (a + b); &#125;inline int Sub (int a, int b) &#123; return (a &lt; b) ? (a + Mod - b) : (a - b); &#125;int qpow (int a, int b) &#123; int base = a, ans = 1; while (b) &#123; if (b &amp; 1) ans = Mul(ans, base); base = Mul(base, base); b &gt;&gt;= 1; &#125; return ans;&#125;struct edge &#123; int to, nxt;&#125; e[N &lt;&lt; 1];int head[N], cnt, n;inline void add (int u, int v) &#123; e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt;&#125;int dep1[N], dep2[N];void dfs(int u, int fa, int *dep) &#123; for(int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v != fa) &#123; dep[v] = dep[u] + 1; dfs(v, u, dep); &#125;&#125;&#125;int dep[N], pw[N], pre[N], L, R; int main() &#123; read(n); For (i, 1, n - 1) &#123; int u, v; read(u); read(v); add(u, v), add(v, u); &#125; dfs(1, 0, dep); L = std::max_element(dep + 1, dep + n + 1) - dep; dep[L] = 0; dfs(L, 0, dep); R = std::max_element(dep + 1, dep + n + 1) - dep; pw[0] = 1; for(int i = 1; i &lt;= n; i++) pw[i] = (pw[i - 1] &lt;&lt; 1) % Mod; dfs(R, 0, dep2); int lower = 0; for(int i = 1; i &lt;= n; i++) &#123; if(i == L || i == R) continue; lower = std::max(lower, std::min(dep[i], dep2[i])); pre[std::max(dep[i], dep2[i])]++; &#125; for(int i = 1; i &lt; n; i++) pre[i] += pre[i - 1]; int ans = 1ll * pw[pre[lower]] * lower % Mod; for(int i = lower + 1; i &lt; n; i++) &#123; ans = (ans + 1ll * i * (pw[pre[i]] - pw[pre[i - 1]] + Mod) % Mod) % Mod; &#125; ans = (ans * 2 + 1ll * dep[R] * pw[n - 1]) % Mod; printf(&quot;%d\\n&quot;, ans);&#125; 网上一个博主的代码，吊打我几百行 /kk","categories":[{"name":"Vps","slug":"Vps","permalink":"http://odalys8191.github.io/categories/Vps/"}],"tags":[]},{"title":"2021-10-29-Test","slug":"2021-10-29-Test","date":"2021-10-29T12:11:39.000Z","updated":"2021-10-29T13:29:39.580Z","comments":true,"path":"Tests/2021-10-29-Test/cm34e3w4m000s5vtn227j46y7/","link":"","permalink":"http://odalys8191.github.io/Tests/2021-10-29-Test/cm34e3w4m000s5vtn227j46y7/","excerpt":"","text":"100 + 10 + 0 +0 T1 简单结论题 T2 一个结论都不会被杀疯了 T3 群除我会的科技 T4 又胡了做法，又开始冲，又看错题了哈哈 点满科技树，锻炼思维！！！ # Solutions: # sto 数轴上初始只有原点有一个球，你有两种操作， 一是把一个球删掉在它两边加两个，二是删掉旁边两个球在中间加入一个，询问能否多次操作后使只有 xxx 位置有球。 结论是：若 xxx 是 666 的倍数则可以，否则则不行。 手玩可以发现 666 可以，自然 666 的倍数也可以，那要证不是 666 的倍数不行。 # as nnn 个数字，∀s∈[0,k],min⁡{(ai+s)⊕(aj+s)}\\forall s\\in [0, k], \\min\\{(a_i + s)\\oplus (a_j + s)\\}∀s∈[0,k],min{(ai​+s)⊕(aj​+s)}. 一些结论是： ∀i&lt;j&lt;k,i⊕k≥min⁡{i⊕j,j⊕k}\\forall i&lt;j&lt;k, i\\oplus k\\ge \\min\\{i\\oplus j, j\\oplus k\\}∀i&lt;j&lt;k,i⊕k≥min{i⊕j,j⊕k}. 由于相加差距不变，所以我们排序后相邻两个就能到答案，O(nk)\\mathrm O(nk)O(nk) 算法就出来了 ∀i,j,(i⊕j)≥∣i−j∣\\forall i, j, (i\\oplus j)\\ge |i - j|∀i,j,(i⊕j)≥∣i−j∣ 于是可得答案的下界。 ∃k∈[0,2×∣i−j∣],(i+k)⊕(j+k)=∣i−j∣\\exists k\\in[0,2\\times |i - j|], (i+k)\\oplus (j+k) = |i-j|∃k∈[0,2×∣i−j∣],(i+k)⊕(j+k)=∣i−j∣ 这个我也不会证，然后这题就做完了。 若 kkk 不在 2∣i−j∣2|i-j|2∣i−j∣ 内直接 O(nk)O(nk)O(nk) 否则就是最小差。 在解个不等式即可证明暴力 O(nk)O(nk)O(nk) 时复杂度正确。 # lky 斯特林数 + 范德蒙德卷积板子题 在学了 # orz 一个无限大的棋盘，有 nnn 个黑色棋子(x,y)(x, y)(x,y) ，你要放白棋将其全部吃掉，移动规则如下: 白棋在 (x,y)(x,y)(x,y) 处 若 (x+1,y+1)(x+1,y+1)(x+1,y+1) 有黑棋 ，就可以移动至此吃掉黑棋 若 (x+1,y−1)(x+1,y-1)(x+1,y−1) … 若 (x+1,y)(x+1,y)(x+1,y) 无棋子，就可移动至此 考场上看错题了，然后一个基于随机化的东西看起来正确性没问题的东西过不了样例… 考虑一个棋子 aaa ，能吃到什么棋子？一定是 yb=ya+1,xb≥xay_b = y_a + 1, x_b \\ge x_ayb​=ya​+1,xb​≥xa​ 的黑棋子 那这是一个 DAGDAGDAG 上统计不交路径覆盖的问题。 注意我们一定能根据一组覆盖方案还原一组移动方法 即当你要往右走被黑棋挡住时，先让吃它的白棋先动就好。 那套路的拆点为入点和出点我们就有 n2n^2n2 连边的网络流求二分图最大匹配的做法了 二分图最大匹配不好求？转换成求二分图最大独立集。 我们设 yyy 坐标为偶数的点为偶点，发现一对边的两个点奇偶性不同，于是我们把图拆成两个，奇入 - 偶出，偶入 - 奇出，对这两张图分别求最大独立集 考虑一个出点，若它被选入独立集中，意味着连它的入点不在独立集中，则它同行后面的点也可被选出独立集中 发现出点 / 入点所选入独立集的情况是个前缀 / 后缀的形式，于是我们可以使用单指针跑 dp 解决。 不太会实现于是贺了 deltax 的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w=1; a=0; char ch=getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;;ch=getchar()) if(ch == &#x27;-&#x27;) w=-1; for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar()) a=(a&lt;&lt;3)+(a&lt;&lt;1)+(ch^48); a*=w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define fi first#define se second#define pb push_back#define mp make_pair#define mii map&lt;int, int&gt; #define pii pair&lt;int, int&gt; #define vi vector&lt;int&gt; #define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)const int N = 5e5 + 10;struct Node &#123; int x, y; Node (int X = 0, int Y = 0) &#123; x = X, y = Y; &#125; bool operator &lt; (const Node &amp;a) const &#123; if ( x == a.x ) return y &lt; a.y; return x &lt; a.x; &#125;&#125; a[N];vi dot[N];int n; pii sta[N];vector &lt; pii &gt; dp; // fi the x, se the val inline int Dp (int op) &#123; int cur = 0; dp.clear(); dp.pb(mp(0, 0)); For (i, 1, N - 10) &#123; if ( (i ^ op) &amp; 1 ) &#123; int p = dp.size() - 1, tmp = dp[0].se; int top = 0, sz = dot[i].size() - 1; foR (j, sz, 0) &#123; int x = dot[i][j]; while (p &gt;= 0 &amp;&amp; dp[p].fi &gt;= x) ckmax(tmp, dp[p--].se); sta[++top] = mp(x, tmp + j + 1); &#125; while ( p &gt;= 0 ) ckmax(tmp, dp[p--].se); dp.clear(); dp.pb(mp(0, tmp)); reverse (sta + 1, sta + top + 1); For (j, 1, top) dp.pb(sta[j]); &#125; // In else &#123; int tmp = 0, p = 0, sz = dot[i].size() - 1; int top = 0; For (j, 0, sz) &#123; int x = dot[i][j]; while (p &lt; dp.size() &amp;&amp; dp[p].fi &lt;= x) ckmax(tmp, dp[p++].se); sta[++top] = mp(x, tmp + sz - j + 1); &#125; while ( p &lt; dp.size() ) ckmax(tmp, dp[p++].se); dp.clear(); dp.pb(mp(0, tmp)); For (j, 1, top) dp.pb(sta[j]); &#125; // Out &#125; int res = 0; for (auto v : dp) ckmax(res, v.se); return res; &#125;int main() &#123; read(n); For (i, 1, n) read(a[i].x), read(a[i].y); sort (a + 1, a + n + 1); For (i, 1, n) dot[a[i].y].pb(a[i].x); printf (&quot;%d\\n&quot;, n - (n - Dp(0) + n - Dp(1) )); return 0;&#125;","categories":[{"name":"Tests","slug":"Tests","permalink":"http://odalys8191.github.io/categories/Tests/"}],"tags":[{"name":"构造","slug":"构造","permalink":"http://odalys8191.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"dp","slug":"dp","permalink":"http://odalys8191.github.io/tags/dp/"},{"name":"斯特林相关","slug":"斯特林相关","permalink":"http://odalys8191.github.io/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E7%9B%B8%E5%85%B3/"},{"name":"位运算","slug":"位运算","permalink":"http://odalys8191.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"2021-10-28-Test","slug":"2021-10-28-Test","date":"2021-10-28T12:32:45.000Z","updated":"2021-11-19T02:19:09.199Z","comments":true,"path":"Tests/2021-10-28-Test/cm34e3w4l000q5vtn9w373pxa/","link":"","permalink":"http://odalys8191.github.io/Tests/2021-10-28-Test/cm34e3w4l000q5vtn9w373pxa/","excerpt":"","text":"期望：100 + 0 + 0 + 50 实际：0 + 0 + 0 + 35 能冲: 100 + 100 + 100 + 0 输光了 主要输在 T2 想复杂了以及 T1FST 了 T2 胡了个线段树优化建图但点数爆炸就没写，实际上简单地上前缀优化建图即可。 T1FST 的奇奇怪怪的，还是要自己好好想想。 T4 看错题了，但还有 35 (?) ，但它自动姬一点的做法是真的玄妙，但好像作为原题出现过两次（我都没考） # Solutions # A 你在 sss 要去 ttt ，有个杀手要干你，初始在 kkk ，求你和他速度最小比使得你不会被干。 n≤5e5n\\le 5e5 n≤5e5 值得注意的是，你只知道杀手初始在哪里，但不能动态知道它每一步在哪里，所以你不是博弈类似的它走一步你走一步，也不能直接硬上最短路。 那我们把杀手到每个点的最短路求出来，然后你二分答案 xxx ，再跑 dijdijdij ，当你到某个点时 dis2v&gt;x×dis1vdis2_v &gt; x\\times dis1_vdis2v​&gt;x×dis1v​ 那你走就会被鲨，于是不能走，这样就能 checkcheckcheck 了 # B nnn 个怪，mmm 种魔法 (a,b,c)(a,b,c)(a,b,c) 表示把一个 aaa 血量的怪变成 bbb 血量花费 ccc 法力，你也可以直接打花 111 法力扣 111 血量，求把每个怪打成 111 血所花费的最少法力 n≤1e6n\\le 1e6 n≤1e6 线段树优化建图？ 直接排序离散化建图！ 我是什么石锤了 # C nnn 个路口，两两距离为 did_idi​ ，每 G+RG+RG+R 时间中 GGG 时间绿灯，RRR 时间红灯，你只有在绿灯才能通过路口，qqq 次询问从时刻 ttt 出发啥时候能到 nnn 号路口。 n≤2×105n\\le 2\\times 10^5 n≤2×105 考虑你在时刻 k≥Rk\\ge Rk≥R 时间到了一个路口，你必然会等到下一个绿灯区间才会往后走。 这启发我们预处理每个路口从绿灯区间出发到 nnn 号路口的答案。 你考虑，从后往前，类似 dpdpdp 的，iii 号路口的答案一定会由后面第一个红灯的 jjj 号路口答案转移过来。 我们可以列出不等式 :$$G\\le sum_j-sum_i &lt; G+R$$. 在你做 iii 时， sumisum_isumi​ 是个定值，于是你可以直接在值域线段树上查 jjj 查询时，只需类似的判断后面第一个红灯在哪里，就好了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/* ============================== * Author : Odalys * * Blog : Odalys.xyz * * Mail : minyuenu@gmail.com * =============================== */#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w=1; a=0; char ch=getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;;ch=getchar()) if(ch == &#x27;-&#x27;) w=-1; for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar()) a=(a&lt;&lt;3)+(a&lt;&lt;1)+(ch^48); a*=w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define fi first#define se second#define pb push_back#define mp make_pair#define mii map&lt;int, int&gt; #define pii pair&lt;int, int&gt; #define vi vector&lt;int&gt; #define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)const int N = 2e5 + 10;#define LL long long struct SGT &#123; struct Node &#123; int val, l, r; &#125;; int tot, rt; vector &lt; Node &gt; tr; SGT (int siz) : tot(0), rt(0), tr(siz, Node&#123;-1, 0, 0&#125;) &#123;&#125; #define ls tr[x].l #define rs tr[x].r inline void put (int &amp;x, int v) &#123; if (!x) x = ++tot; tr[x].val = v; &#125; void pushdown (int x) &#123; if (~tr[x].val) put(ls, tr[x].val), put(rs, tr[x].val), tr[x].val = -1; &#125; void update (int &amp;x, int l, int r, int ll, int rr, int v) &#123; if (ll &lt;= l &amp;&amp; r &lt;= rr) return put(x, v), void(); pushdown(x); int mid = (l + r) / 2; if (ll &lt; mid) update (ls, l, mid, ll, rr, v); if (rr &gt; mid) update (rs, mid, r, ll, rr, v); &#125; int query (int x, int l, int r, int p) &#123; if (~tr[x].val) return tr[x].val; pushdown(x); int mid = (l + r) / 2; if (p &lt; mid) return query (ls, l, mid, p); return query (rs, mid, r, p); &#125;&#125; ;int n, G, R;LL a[N], pre[N];LL Ans[N];int main() &#123; read(n); read(G); read(R); For (i, 0, n) read(a[i]), pre[i] = pre[i - 1] + a[i]; SGT tr (n * 100); R += G; tr.update(tr.rt, 0, R, 0, R, n); foR (i, n - 1, 0) &#123; int j = tr.query (tr.rt, 0, R, (R - pre[i] % R) % R); Ans[i] = Ans[j] + pre[j] - pre[i]; if (j &lt; n) Ans[i] += (R - (pre[j] - pre[i]) % R); int l = (R + G - pre[i] % R) % R; int r = (R - pre[i] % R) % R; if (l &lt; r) tr.update (tr.rt, 0, R, l, r, i); else &#123; tr.update (tr.rt, 0, R, l, R, i); if (r) tr.update (tr.rt, 0, R, 0, r, i); &#125; &#125; int q; read(q); LL tmp = 0; while (q--) &#123; int t; read(t); t = t xor (tmp % 2147483647); int i = tr.query (tr.rt, 0, R, t % R); tmp = Ans[i] + pre[i] + t; if (i &lt; n) tmp += R - (pre[i] + t) % R; printf (&quot;%lld\\n&quot;, tmp); &#125; return 0;&#125; # d this 考虑设计一个 DFA ，每个状态为一个等价类，即满足 f(x)=f(y)f(x) = f(y)f(x)=f(y) 且 f(x+S)=f(y+S)f(x+S) = f(y+S)f(x+S)=f(y+S) 其中 SSS 为任意 01 串 可以证明，这样的等价类不超过 200 个 草！ 然后考虑判断两个串是否在同一等价类中，可以证明，只要在这两个串后面随意加长度不超过 777 的函数值还 TM 相等，就在同一等价类中。 草！ 然后暴力建出自动姬在上面 DP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w=1; a=0; char ch=getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;;ch=getchar()) if(ch == &#x27;-&#x27;) w=-1; for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar()) a=(a&lt;&lt;3)+(a&lt;&lt;1)+(ch^48); a*=w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define fi first#define se second#define pb push_back#define mp make_pair#define mii map&lt;int, int&gt;#define pii pair&lt;int, int&gt;#define vi vector&lt;int&gt;#define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i)#define foR(i,l,r) for (int i = l; i &gt;= r; --i)const int N = 1e5 + 10;const int Mod = 1e9 + 7;struct Node &#123; int siz, a[20];&#125; dot[222];int f[10];int get ( vi a ) &#123; while (a.size() &gt; 1) &#123; int xx = 0; For (i, 0, 2) xx = xx * 2 + a.back(), a.pop_back(); xx = f[xx]; a.pb(xx); &#125; return a[0];&#125;int to[N][2], tot;bool tag[30][2];pii sol ( Node x ) &#123; memset (tag, 0, sizeof tag); tag[1][x.a[1]] = 1; for (int i = 3; i &lt;= x.siz; i += 2) for (int j = 1; j &lt; i; j += 2) For (k, 0, 1) if (tag[j][k]) &#123; vi tmp; tmp.pb(k); For (o, j + 1, i) tmp.pb(x.a[o]); tag[i][get(tmp)] = 1; &#125; return mp (tag[x.siz][0], tag[x.siz][1]);&#125;bool ck ( Node x, Node y ) &#123; if ( (x.siz &amp; 1) != (y.siz &amp; 1) ) return false; For (len, 0, 7) if ( (x.siz + len) &amp; 1 ) &#123; For (s, 0, (1 &lt;&lt; len) - 1) &#123; Node c = x, d = y; For (i, 1, len) &#123; c.a[++c.siz] = (s &gt;&gt; i - 1) &amp; 1; d.a[++d.siz] = (s &gt;&gt; i - 1) &amp; 1; &#125; if (sol(c) != sol(d)) return false; &#125; &#125; return true;&#125;void build () &#123; static queue &lt;int&gt; q; while (!q.empty()) q.pop(); q.push(1); tot = 1; while (!q.empty()) &#123; int id = q.front(); q.pop(); Node u = dot[id]; For (i, 0, 1) &#123; Node v = u; v.a[++v.siz] = i; bool flag = false; For (j, 1, tot) if (ck(dot[j], v)) &#123; to[id][i] = j; flag = 1; break; &#125; if (!flag) &#123; dot[to[id][i] = ++tot] = v; q.push(tot); &#125; &#125; &#125;&#125;int dp[N][333];char ch[N];int main() &#123; int cases; read(cases); while (cases--) &#123; memset (to, 0, sizeof to); For (i, 0, 7) scanf (&quot;%1d&quot;, &amp;f[i]); build (); memset (dp, 0, sizeof dp); scanf (&quot;%s&quot;, ch + 1); int n = strlen(ch + 1); dp[0][1] = 1; For (i, 1, n) For (j, 1, tot) &#123; if (dp[i - 1][j]) &#123; if (ch[i] == &#x27;?&#x27;) For (o, 0, 1) (dp[i][to[j][o]] += dp[i - 1][j]) %= Mod; else (dp[i][to[j][ch[i] - &#x27;0&#x27;]] += dp[i - 1][j]) %= Mod; &#125; &#125; int Ans = 0; For (i, 1, tot) if (sol(dot[i]).se == 1) (Ans += dp[n][i]) %= Mod; printf (&quot;%d\\n&quot;, Ans); &#125;&#125;","categories":[{"name":"Tests","slug":"Tests","permalink":"http://odalys8191.github.io/categories/Tests/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://odalys8191.github.io/tags/dp/"},{"name":"数据结构","slug":"数据结构","permalink":"http://odalys8191.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"最短路","slug":"最短路","permalink":"http://odalys8191.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"玄妙","slug":"玄妙","permalink":"http://odalys8191.github.io/tags/%E7%8E%84%E5%A6%99/"},{"name":"自动姬","slug":"自动姬","permalink":"http://odalys8191.github.io/tags/%E8%87%AA%E5%8A%A8%E5%A7%AC/"}]},{"title":"胡思乱想","slug":"胡思乱想","date":"2021-10-28T05:25:43.000Z","updated":"2021-10-28T05:26:01.738Z","comments":true,"path":"uncategorized/胡思乱想/cm34e3w6b005l5vtn2kz6enc9/","link":"","permalink":"http://odalys8191.github.io/uncategorized/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/cm34e3w6b005l5vtn2kz6enc9/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"长链剖分学习笔记","slug":"长链剖分学习笔记","date":"2021-10-27T14:36:35.000Z","updated":"2021-10-27T14:07:21.979Z","comments":true,"path":"Notes/长链剖分学习笔记/cm34e3w6d005s5vtn0n1t5w6g/","link":"","permalink":"http://odalys8191.github.io/Notes/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/cm34e3w6d005s5vtn0n1t5w6g/","excerpt":"","text":"# 长链剖分学习笔记 # 基本 ​ 与重链剖分类似的，长链剖分将一棵树剖出若干条互不相交的链。 ​ 但长链剖分中的重儿子不是子树大小最大的，而是深度最大的儿子（定义深度为一个点到其子树其他点经过点数中最大的一条），不妨将其称作长儿子。 ​ 类比重链剖分，我们定义长边为一个节点与它的长儿子连成的边，若干长边连成一条长链，定义链顶为长链中深度最大的节点，链底为长链中深度最小的节点。 # 性质 一个点到其长链链底的路径，是这个点到其子树所有点的路径中最长的一条。（ 显然\\color{gold}\\texttt{显然}显然 ） 一个点到根的路径，最多经过 n\\sqrt nn​ 条虚边。 证明：一个点深度为 kkk ，往上如果是虚边，那么上面点的子树大小最小要加上 k+1k+1k+1 ，设跳 xxx 条虚边到根，树的大小最小为 x(x+1)2=n\\frac{x(x+1)}{2} = n2x(x+1)​=n ，故 xxx 大约为 n\\sqrt nn​ 。 每条长链长度之和是 O(n)\\mathrm O(n)O(n) 级别的 # 技巧 长剖优化与深度有关的 dpdpdp . 有点类似 Dsu On Tree\\texttt{Dsu On Tree}Dsu On Tree ，大概是每次把当前 dpdpdp 数组 O(1)O(1)O(1) 继承给长儿子，这个可以用指针做。","categories":[{"name":"Notes","slug":"Notes","permalink":"http://odalys8191.github.io/categories/Notes/"}],"tags":[{"name":"长链剖分","slug":"长链剖分","permalink":"http://odalys8191.github.io/tags/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86/"}]},{"title":"Boruvka小鸡","slug":"Boruvka小鸡","date":"2021-10-26T13:46:51.000Z","updated":"2021-10-26T14:03:19.112Z","comments":true,"path":"Notes/Boruvka小鸡/cm34e3w57002e5vtn2fnfbj3j/","link":"","permalink":"http://odalys8191.github.io/Notes/Boruvka%E5%B0%8F%E9%B8%A1/cm34e3w57002e5vtn2fnfbj3j/","excerpt":"","text":"我知道 MSTMSTMST 的三种求法！ 补题时遇到的船新科技！ 考虑平时我们求 MSTMSTMST 的两种做法，一种 krusklkrusklkruskl 是基于贪心每次加入一条最小边，而 primprimprim 则是把一个生成树向外扩展。 那结合这两种思想我们可以得到 BoruvkaBoruvkaBoruvka 算法： 初始每个点独立为点集 每个点集尝试寻找向其他点集连边中权最小的一条，合并这两个点集 重复这个过程，直到只剩一个点集。 容易发现，这样操作的正确性显然，然后每次点集数量会起码缩水一半，故复杂度为 O(Tlog⁡N)O(T\\log N)O(TlogN) 其中 TTT 我们查找最小权边的复杂度。 对于稠密图，边数接近 n2n^2n2 ，这个算法就不能朴素做，此时我们就要想办法优化查找最小权的边，可以使用各种 DS 来优化。 如 CF888G ，是一张完全图求异或 MST，看到异或最小值，我们有两种思路，要么上 trie ，要么上线性基，这里直接上 trie 就可以优化寻找最小边的复杂度至 log⁡值域\\log \\texttt{值域}log值域 级别。 同样，这一算法思想也可以用于在边数很大难以直接处理的时候计算联通块个数，如 ZROI2095\\texttt{ZROI2095}ZROI2095。","categories":[{"name":"Notes","slug":"Notes","permalink":"http://odalys8191.github.io/categories/Notes/"}],"tags":[{"name":"MST","slug":"MST","permalink":"http://odalys8191.github.io/tags/MST/"},{"name":"Boruvka","slug":"Boruvka","permalink":"http://odalys8191.github.io/tags/Boruvka/"}]},{"title":"CSP2021游记","slug":"CSP2021游记","date":"2021-10-22T06:34:32.000Z","updated":"2021-10-23T01:11:46.395Z","comments":true,"path":"travel/CSP2021游记/cm34e3w5m003r5vtnekanet9m/","link":"","permalink":"http://odalys8191.github.io/travel/CSP2021%E6%B8%B8%E8%AE%B0/cm34e3w5m003r5vtnekanet9m/","excerpt":"","text":"由于 CSP 鸽了所以这篇游记也鸽了。 由于 CSP 又 NOIp 了所以这篇游记先鸽着。","categories":[{"name":"travel","slug":"travel","permalink":"http://odalys8191.github.io/categories/travel/"}],"tags":[]},{"title":"2021-10-19 Test","slug":"2021-10-19-Test","date":"2021-10-19T12:09:42.000Z","updated":"2021-11-19T02:16:12.147Z","comments":true,"path":"Tests/2021-10-19-Test/cm34e3w4h000h5vtn5ofo5quz/","link":"","permalink":"http://odalys8191.github.io/Tests/2021-10-19-Test/cm34e3w4h000h5vtn5ofo5quz/","excerpt":"","text":"两个数异或最值 →\\to→ Trie 上跑跑 一堆数异或最值 →\\to→ 线性基 都是高二的老狗了，心态能不能像老狗一样平稳一点，tmd 被小朋友交几发暴力就吓炸了？！ 想起了省选被隔壁老哥支配的恐惧 还是太重结果了，但这种心态会极大程度影响我的过程 这 TM 是老毛病了吧，中考时考数学做到压轴就一直在想 zhy,zzm 他们一定都切穿了导致我后面做的跟屎一样，好在是做到压轴才开始自闭的，要不可能雅礼都进不了 离 CSP 就两次（?）考试了，一定不能再跟别人比较了 耶耶耶今天是保龄 day~ TMD，T1 不会，T2 不会，T3 不会，T4 不会，我这场在干嘛 T1 遇到沟通困难的时候为什么不重新看一遍题？ T2 构造题你写了个啥？没拍过的乱搞活该保灵好吧 T3 为什么不认真读懂题想一想？线性基写脸上了？ T4 是真的不会。 TMD # Solutions： # a nnn 页的日记本，写过的页不能再写，第一天可任意写一页，记昨天写的一页为 ttt ，那今天只能写 [1,t][1,t][1,t] ，求与给定数组 qqq 趋势相同的方案数，支持交换 qqq 中两个元素。 要求做到 $$O (n\\log n)$$. cnm，看错题了，看错的题到现在还不会做。 那既然我们今天只能写 [1,t][1,t][1,t] 的，记还能写的页码为一个集合，我们一定是写一个递减的东西且以当前集合中最小页码结尾。 然后就是大力推组合数的柿子，由于要与给定 qiq_iqi​ 趋势相同，那我们找到每个 qi&lt;qi+1q_i&lt;q_{i+1}qi​&lt;qi+1​ 的位置拿出来做一个数组 aia_iai​ 咋计数捏？为了方便处理一些奇怪的情况，我们把 0,n0,n0,n 也放进序列。 每个 aia_iai​ 其实是代表了一个递减段的，做每个递减段时，我们剩余数字集合大小是知道的，而我们是并不关注究竟还剩了什么数字的，毕竟是一个排列，放上去会自动排好序，但此时集合中最小的元素是必须被选的，我们可以得出柿子： Ans=∏i=2k(n−ai−1−1ai−ai−1−1)Ans=\\prod\\limits_{i=2}^k\\binom{n-a_{i-1}-1}{a_i-a_{i-1}-1} Ans=i=2∏k​(ai​−ai−1​−1n−ai−1​−1​) 这里就可以做不带修的情况了，带修咋做，上面这个形式不好维护，我们把组合数拆开，乘一乘，发现好多约掉了。 Ans=(n−a1−1)!×∏k=2n1(ai−ai−1)!×1(n−ai)Ans=(n-a_1-1)!\\times \\prod\\limits_{k=2}^n{1\\over (a_i-a_{i-1})!}\\times {1\\over (n-a_i)} Ans=(n−a1​−1)!×k=2∏n​(ai​−ai−1​)!1​×(n−ai​)1​ 我们钦定了 a1=0a_1=0a1​=0 那上面那个东西前面就是 (n−1)!(n-1)!(n−1)! 了 这个显然可以 setsetset 维护交换。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117/* ============================== * Author : Odalys * * Blog : Odalys.xyz * * Mail : minyuenu@gmail.com * =============================== */#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w=1; a=0; char ch=getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;;ch=getchar()) if(ch == &#x27;-&#x27;) w=-1; for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar()) a=(a&lt;&lt;3)+(a&lt;&lt;1)+(ch^48); a*=w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define fi first#define se second#define pb push_back#define mp make_pair#define mii map&lt;int, int&gt; #define pii pair&lt;int, int&gt; #define ins insert#define era erase#define vi vector&lt;int&gt; #define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)const int N = 3e5 + 10;const int Mod = 1e9 + 7;inline int Mul (int x, int y) &#123; return 1ll * x * y &gt;= Mod ? (1ll * x * y % Mod) : (x * y); &#125;inline int Add (int x, int y) &#123; return (x + y &gt;= Mod) ? (x + y - Mod) : x + y; &#125;inline int Sub (int x, int y) &#123; return (x - y &lt; 0) ? (x - y + Mod) : (x - y); &#125;int qpow (int a, int b) &#123; int ans = 1, base = a; while (b) &#123; if (b &amp; 1) ans = Mul(ans, base); base = Mul(base, base); b &gt;&gt;= 1; &#125; return ans; &#125;int fac[N], ifac[N];void Init (int M) &#123; fac[0] = ifac[0] = 1; For (i, 1, M) fac[i] = Mul(fac[i - 1], i); ifac[M] = qpow(fac[M], Mod - 2); foR (i, M - 1, 1) ifac[i] = Mul(ifac[i + 1], i + 1);&#125;int bin (int a, int b) &#123; if (a &lt; b || a &lt; 0 || b &lt; 0) return 0; return Mul(fac[a], Mul(ifac[a - b], ifac[b])); &#125;int Inv (int s) &#123; int a = qpow(s, Mod - 2); return (a ? a : 1);&#125;set &lt;int&gt; mck;int a[N], s[N], tot;int Ans;int n, m; int eps(int x) &#123; return x ? x : 1; &#125;inline void Era (int x) &#123; auto it1 = mck.lower_bound(x); it1--; int pre = *it1; Ans = Mul(Ans, Mul(eps(n - x), fac[x - pre - 1])); auto it2 = mck.upper_bound(x); int nxt = *it2; Ans = Mul(Ans, Mul(eps(n - nxt), fac[nxt - x - 1])); mck.erase(x); Ans = Mul(Ans, Mul(Inv(n - nxt), ifac[nxt - pre - 1]));&#125;inline void Ins (int x) &#123; auto it1 = mck.lower_bound(x), it2 = mck.upper_bound(x); it1--; int pre = *it1, nxt = *it2; Ans = Mul(Ans, Mul(eps(n - nxt), fac[nxt - pre - 1])); Ans = Mul(Ans, Mul(Inv(n - x), ifac[x - pre - 1])); Ans = Mul(Ans, Mul(Inv(n - nxt), ifac[nxt - x - 1])); mck.insert(x); &#125;int del[N];int main() &#123; Init(N - 10); read(n); read(m); For (i, 1, n) read(a[i]); s[++tot] = 0; mck.ins(0); For (i, 1, n - 1) if (a[i] &lt; a[i + 1]) s[++tot] = i, mck.ins(i); s[++tot] = n; mck.ins(n); Ans = 1; For (i, 2, tot) Ans = Mul(Ans, Mul(Inv(n - s[i]), ifac[s[i] - s[i - 1] - 1])); printf (&quot;%d\\n&quot;, Mul(Ans, fac[n - 1])); For (i, 1, m) &#123; int x, y; read(x); read(y); if (y &lt; n &amp;&amp; !del[y]) if (a[y] &lt; a[y + 1]) Era(y), del[y] = 1; if (y &gt; 1 &amp;&amp; !del[y - 1]) if (a[y - 1] &lt; a[y]) Era(y - 1), del[y - 1] = 1; if (x &lt; n &amp;&amp; !del[x]) if (a[x] &lt; a[x + 1]) Era(x), del[x] = 1; if (x &gt; 1 &amp;&amp; !del[x - 1]) if (a[x - 1] &lt; a[x]) Era(x - 1), del[x - 1] = 1; swap(a[x], a[y]); del[x] = del[y] = del[x - 1] = del[y - 1] = 0; if (y &lt; n &amp;&amp; !del[y]) if (a[y] &lt; a[y + 1]) Ins(y), del[y] = 1; if (y &gt; 1 &amp;&amp; !del[y - 1]) if (a[y - 1] &lt; a[y]) Ins(y - 1), del[y - 1] = 1; if (x &lt; n &amp;&amp; !del[x]) if (a[x] &lt; a[x + 1]) Ins(x), del[x] = 1; if (x &gt; 1 &amp;&amp; !del[x - 1]) if (a[x - 1] &lt; a[x]) Ins(x - 1), del[x - 1] = 1; printf (&quot;%d\\n&quot;, Mul(Ans, fac[n - 1])); del[x] = del[y] = del[x - 1] = del[y - 1] = 0; &#125;&#125; # b 一张无向图，可能重边，每条路可黑白染色，构造方案使得每座城市连出的黑白差绝对值最大为 111 每个点度数为偶数的包暗示我们欧拉路 那对于一张所有点度数为偶数的图，拉一条欧拉路，路上点黑白染色，那不难发现起点是唯一可能破戒的，因为其他点度数为偶数，进来一次出去一次差为 000 ，而若欧拉路上有奇数条边，那我们起点就 GG 了，这种不能构造 若有奇数度数的点，新建虚点连上去，一样做就好，推荐一种好写的写法，使用了类似当前弧一样的东西。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/* ============================== * Author : Odalys * * Blog : Odalys.xyz * * Mail : minyuenu@gmail.com * =============================== */#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w=1; a=0; char ch=getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;;ch=getchar()) if(ch == &#x27;-&#x27;) w=-1; for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar()) a=(a&lt;&lt;3)+(a&lt;&lt;1)+(ch^48); a*=w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define fi first#define se second#define pb push_back#define mp make_pair#define mii map&lt;int, int&gt; #define pii pair&lt;int, int&gt; #define vi vector&lt;int&gt; #define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)const int N = 4e6 + 10;struct edge &#123; int to, nxt, id;&#125; e[N &lt;&lt; 1];int head[N], cnt = 1;inline void add (int u, int v, int Id) &#123; e[++cnt].to = v; e[cnt].nxt = head[u]; e[cnt].id = Id; head[u] = cnt;&#125;int du[N];int n, m;int Ans[N &lt;&lt; 1], vis[N &lt;&lt; 1], edges;void dfs (int u) &#123; for (int &amp;i = head[u]; i; i = e[i].nxt) &#123; // ! int v = e[i].to, j = i / 2; if (vis[j]) continue; vis[j] = 1; dfs(v); Ans[j]= (++edges) &amp; 1; &#125;&#125;int main() &#123; read(n); read(m); For (i, 1, m) &#123; int u, v; read(u); read(v); add(u, v, i), add(v, u, i); du[u]++, du[v]++; &#125; int id = m; For (i, 1, n) if (du[i] &amp; 1) add(0, i, ++id), add(i, 0, id); For (u, 0, n) &#123; edges = 0; dfs(u); if ( (edges &amp; 1) &amp;&amp; u ) return puts(&quot;-1&quot;), 0; &#125; For (u, 1, m) printf (&quot;%d &quot;, Ans[u]); &#125; # c 一棵树，每个点带权，求每个点不在他到父亲的链上以及他子树内的所以点异或和最大值。 本场考试最简单的题了把，看懂就能切。 两个数异或最值 →\\to→ Trie 上跑跑 一堆数异或最值 →\\to→ 线性基 然后树上 dfsdfsdfs ，跑到一个点时的线性基就是一边的答案，跑完一个点子树再将这个点加入线性基，正反都跑一遍即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/* ============================== * Author : Odalys * * Blog : Odalys.xyz * * Mail : minyuenu@gmail.com * =============================== */#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w=1; a=0; char ch=getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;;ch=getchar()) if(ch == &#x27;-&#x27;) w=-1; for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar()) a=(a&lt;&lt;3)+(a&lt;&lt;1)+(ch^48); a*=w;&#125;#define int long longtemplate &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define fi first#define se second#define pb push_back#define mp make_pair#define mii map&lt;int, int&gt; #define pii pair&lt;int, int&gt; #define vi vector&lt;int&gt; #define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)#define ll long longconst int N = 4e5 + 10;const int L = 62;vi to[N];struct Linear_Basic &#123; ll a[L | 1]; inline void clear () &#123; memset (a, 0, sizeof a); &#125; bool ins (ll t) &#123; foR (i, L, 0) &#123; if (t &amp; (1ll &lt;&lt; i)) &#123; if (a[i]) &#123;t ^= a[i]; continue;&#125; For (j, 0, i - 1) if (t &amp; (1ll &lt;&lt; j) ) t ^= a[j]; For (j, i + 1, L) if ( a[j] &amp; (1ll &lt;&lt; j) ) a[j] ^= t; a[i] = t; return true; &#125; &#125; return false; &#125;&#125; cur, l[100], r[100];int ltot, rtot;int n, qy, v[N];ll Ans[100][100];int idl[N], idr[N];void dfs (int u, int fa) &#123; idl[u] = ltot; int sz = to[u].size(); For (i, 0, sz - 1) &#123; int v = to[u][i]; if (v == fa) continue; dfs(v, u); &#125; if (cur.ins(v[u])) l[++ltot] = cur;&#125;void sfd (int u, int fa) &#123; idr[u] = rtot; int sz = to[u].size(); foR (i, sz - 1, 0) &#123; int v = to[u][i]; if (v == fa) continue; sfd(v, u); &#125; if (cur.ins(v[u])) r[++rtot] = cur;&#125;signed main() &#123; read(n); For (i, 1, n) read(qy); For (i, 1, n) read(v[i]); For (i, 1, n - 1) &#123; int u, v; read(u); read(v); to[u].pb(v), to[v].pb(u); &#125; dfs(1, 0); cur.clear(); sfd(1, 0); For (i, 0, ltot) For (j, 0, rtot) &#123; cur.clear(); For (k, 0, L) cur.ins(l[i].a[k]), cur.ins(r[j].a[k]); foR (k, L, 0) &#123; ll val = Ans[i][j] ^ cur.a[k]; ckmax(Ans[i][j], val); &#125; &#125; For (i, 1, n) printf (&quot;%lld\\n&quot;, Ans[idl[i]][idr[i]]);&#125; # D 会了","categories":[{"name":"Tests","slug":"Tests","permalink":"http://odalys8191.github.io/categories/Tests/"}],"tags":[{"name":"构造","slug":"构造","permalink":"http://odalys8191.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"计数","slug":"计数","permalink":"http://odalys8191.github.io/tags/%E8%AE%A1%E6%95%B0/"},{"name":"欧拉回路","slug":"欧拉回路","permalink":"http://odalys8191.github.io/tags/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"},{"name":"线性基","slug":"线性基","permalink":"http://odalys8191.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"},{"name":"树上问题","slug":"树上问题","permalink":"http://odalys8191.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"}]},{"title":"路哥优化dp","slug":"路哥优化dp","date":"2021-10-15T14:01:54.000Z","updated":"2021-10-15T14:18:24.129Z","comments":true,"path":"Notes/路哥优化dp/cm34e3w6c005p5vtnditl4ye5/","link":"","permalink":"http://odalys8191.github.io/Notes/%E8%B7%AF%E5%93%A5%E4%BC%98%E5%8C%96dp/cm34e3w6c005p5vtnditl4ye5/","excerpt":"","text":"膜 zxyhymzg\\color{black}\\texttt{z}\\color{red}\\texttt{xyhymzg}zxyhymzg ！！！ 多年以前的考试小技巧，今天复习一下。 大概应对一类要经过某个点组成联通块的树上背包优化。 一般是做根的一个联通块，若想要做任意点就套上一个淀粉质加一个 log⁡\\loglog 超值加倍。 大概思路是修改 dpudp_udpu​ 的含义，本来的含义是在 uuu 的子树内做一些事情，现在我们转换为根的一个联通块此时考虑到了 uuu 的一些东西。 主要的思路是考虑我们 dpdpdp 的过程中，是加了一些点到根的联通块中，考虑这些新加点的性质：要不是新加一个点往下走一步，要不直接跳过了这棵子树（由于这一点 dpudp_udpu​ 的这个 uuu 是还未加入联通块的，此时我们要决策）。 那么这一问题我们有两种解决方式，一种是把 dfndfndfn 搞出来，此时我们的 dpidp_idpi​ 彻底沦为维护原来的 dpidfnidp_{idfn_i}dpidfni​​ ，那转移就是 dpi→dpi+1/dpi→dpi+sizidp_i\\to dp_{i+1}/dp_i\\to dp_{i+siz_i}dpi​→dpi+1​/dpi​→dpi+sizi​​ 做个刷表背包即可，由于笔者懒得自己写，我们以 2021−10−62021-10-62021−10−6 T4 为例看，看这一做法。 1234567891011dfc = 0; dfs(u,0); fr(i,1,nds) memset(dp[i],-0x3f,sizeof dp[i]); dp[1][a[u]] = b[u]; fr(i,2,nds) &#123; int u = idfn[i]; fr(j,0,m) &#123; if(j+a[u] &lt;= m) chkmax(dp[i][j+a[u]],dp[i-1][j] + b[u]); chkmax(dp[i-1+siz[u]][j],dp[i-1][j]); &#125; &#125; 是神仙 zxy\\texttt{zxy}zxy 的代码，外面还套了一层淀粉质。 这一做法优点是较为好理解，写起了方便不易出锅，除了有个 dfsdfsdfs 小常数为没缺点，平时一定要写这个。 还有一传统做法是我们最初见到路哥优化时使用的，直接在树上做，每次将 dpudp_udpu​ 整个数组传给儿子， dfsdfsdfs 后再直接 ckmaxckmaxckmax 的做法，同一题中，它是这么写的。 12345678910111213void Dp (int u, int fa) &#123; for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if (vis[v] || v == fa) continue; memset (dp[v], 0xcf, sizeof dp[v]); For (j, a[u], m - a[v]) dp[v][j + a[v]] = dp[u][j] + b[v]; Dp (v, u); For (j, a[u], m) &#123; ckmax(dp[u][j], dp[v][j]); ckmax(Ans, dp[u][j]); &#125; &#125;&#125; 理解的话，这里面水太深，牵扯的人和事太多了不好说，笔者中午没午休，先鸽了。","categories":[{"name":"Notes","slug":"Notes","permalink":"http://odalys8191.github.io/categories/Notes/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://odalys8191.github.io/tags/dp/"},{"name":"trick","slug":"trick","permalink":"http://odalys8191.github.io/tags/trick/"},{"name":"树论","slug":"树论","permalink":"http://odalys8191.github.io/tags/%E6%A0%91%E8%AE%BA/"},{"name":"背包","slug":"背包","permalink":"http://odalys8191.github.io/tags/%E8%83%8C%E5%8C%85/"}]},{"title":"CF1458","slug":"CF1458","date":"2021-10-14T12:44:35.000Z","updated":"2021-10-23T01:12:15.631Z","comments":true,"path":"Races/CF1458/cm34e3w5a002p5vtn43al9whx/","link":"","permalink":"http://odalys8191.github.io/Races/CF1458/cm34e3w5a002p5vtn43al9whx/","excerpt":"","text":"这场个人感觉还是比较好的一场，无超纲知识点，思维难度在线，码量不太大。 但考场上表现不够良好，感觉自己数形结合能力不是十分突出（？当然有可能是 C 不懂逆排列是啥），对一些常见 tricktricktrick 不够熟练，以及 dp 基本功不够扎实。 目前补题记录 (4/6)(4/6)(4/6) ，感觉 FFF 大概率会鸽 # Solutions: # A 给你 a,ba,ba,b 两个序列，要求对于每个 bib_ibi​ 求出 gcd⁡(a1+bi,a2+bi,…,an+bi)\\gcd(a_1+b_i, a_2+b_i,\\dots ,a_n+b_i)gcd(a1​+bi​,a2​+bi​,…,an​+bi​) 要求做到 O(n)O(n)O(n) 考虑把经典的辗转相减 gcd⁡(a,b)=gcd⁡(a,b−a)\\gcd(a,b) = \\gcd(a,b-a)gcd(a,b)=gcd(a,b−a) 拓展到整个序列 那就是 gcd⁡(a1+bi,a2+bi−(a1+bi),…,an+bi−(an−1+bi)\\gcd(a_1+b_i, a_2+b_i-(a_1+b_i),\\dots ,a_n+b_i - (a_{n-1}+b_i)gcd(a1​+bi​,a2​+bi​−(a1​+bi​),…,an​+bi​−(an−1​+bi​) 也就是 gcd⁡(a1+b1,G)\\gcd(a_1+b_1, G)gcd(a1​+b1​,G) 其中 GGG 为差分数组的 gcd⁡\\gcdgcd 于是可以做到 O(n)O(n)O(n) # B 若干个瓶子，每个瓶子有容积 aia_iai​ ，与初始水量 bib_ibi​ ，你可以将一个瓶子中的水到一部分到其他瓶子中，但会损耗一半倒出的水，显然每个瓶子不能超过它本身体积，对于每个 i∈[1,n]i\\in [1,n]i∈[1,n] ，求出只选 iii 个瓶子能装出的最大水量。 n,ai,bi≤100n,a_i,b_i\\le 100n,ai​,bi​≤100 考虑 dpdpdp 容易发现你将 aaa 倒到 bbb 中再倒入 ccc 中是肯定没有直接倒入 ccc 中优秀的，所以确定最终框架：选择 iii 个瓶子后每个瓶子想方设法往里倒。 设选择的 iii 个瓶子总初始水量为 xxx ，剩余体积为 vvv ，其他瓶子中总水量为 yyy ，答案是 x+min⁡{y2,v}x+\\min{\\{\\frac{y}{2},v\\}}x+min{2y​,v} 注意到值域都很小于是可以考虑背包，设 dpi,j,kdp_{i,j,k}dpi,j,k​ 为前 iii 个瓶子中选了 jjj 个总体积为 kkk 的最大初始水量，于是随便搞一下就好。 # C 一个 n×nn\\times nn×n 的矩阵，每行每列都是一个 1→n1\\to n1→n 的排列，给一个操作序列， U/D/L/R 表示整体向上 / 下 / 左 / 右循环位移一位， I/C 表示每行 / 列替换为其逆排列，求操作后的矩阵。 前四种操作你记录一个总体移了几位的标记就好了。 考虑啥是逆排列，几何意义是把排列表示为平面直角坐标系上 (i,ai)(i,a_i)(i,ai​) 的形式然后再交换每个点的横纵坐标。 那我们把每个点表示为 (i,j,ai,j)(i,j,a_{i,j})(i,j,ai,j​) 的三元组，后两个操作的本质就是交换第一第三个元素与第一第二个元素。 那每个操作我们可以 O(1)O(1)O(1) 打 tagtagtag ，最后在 n×nn\\times nn×n 重构。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* ============================== * Author : Odalys * * Blog : Odalys8191.github.io * * Mail : minyuenu@gmail.com * =============================== */#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w=1; a=0; char ch=getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;;ch=getchar()) if(ch == &#x27;-&#x27;) w=-1; for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar()) a=(a&lt;&lt;3)+(a&lt;&lt;1)+(ch^48); a*=w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define fi first#define se second#define pb push_back#define mp make_pair#define mii map&lt;int, int&gt; #define pii pair&lt;int, int&gt; #define vi vector&lt;int&gt; #define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)const int N = 1000;int n, m;int Id (int i, int j) &#123; return (i - 1) * n + j; &#125;int a[N * N | 1][3];int Ans[N][N];int pos[3], mv[3];inline void solve () &#123; read(n); read(m); For (i, 0, 2) pos[i] = i, mv[i] = 0; For (i, 1, n) For (j, 1, n) &#123; int cur = Id(i, j); a[cur][0] = i, a[cur][1] = j, read(a[cur][2]); &#125; For (i, 1, m) &#123; char ch = getchar(); if (ch == &#x27;U&#x27;) mv[pos[0]]--; if (ch == &#x27;D&#x27;) mv[pos[0]]++; if (ch == &#x27;L&#x27;) mv[pos[1]]--; if (ch == &#x27;R&#x27;) mv[pos[1]]++; if (ch == &#x27;I&#x27;) swap(pos[1], pos[2]); if (ch == &#x27;C&#x27;) swap(pos[0], pos[2]); &#125; For (i, 1, n * n) &#123; For (j, 0, 2) a[i][j] = (a[i][j] - 1 + mv[j] + n * m) % n + 1; Ans[a[i][pos[0]]][a[i][pos[1]]] = a[i][pos[2]]; &#125; For (i, 1, n) &#123; For (j, 1, n) printf(&quot;%d &quot;, Ans[i][j]); puts(&quot;&quot;);&#125;&#125;int main() &#123; int cases; read(cases); while (cases--) solve(), puts(&quot;&quot;); return 0;&#125; # D 给定一个 0/10/10/1 串，你可以对 000 与 111 数目相同的一段区间进行操作为，每个取反，再整体翻转。 求若干次操作后字典序最小的串。 草，这什么神仙思维题。 人类智慧。 把 000 看成 −1-1−1 ，111 看成 +1+1+1 ，把前缀和序列搞出来，那一段区间可以操作当且仅当 suml−1=sumrsum_{l-1} = sum_{r}suml−1​=sumr​ 。 操作的本质就是把一段区间前缀和序列取反，为什么呢？ 一目了然，不言而喻。 然后考虑一个神仙思路，我们把前缀和值看做一个个点，相邻前缀和值连边。 这样会得出一张有向图，相邻点之间前缀和值相差为 111 ，每条边若它的起点比终点大 111 则代表字符 000 ，否则代表字符 111 考虑这张图初始只有一条欧拉路（即经过每条边恰好一次的路径），把边代表字符写下了就是原串。 那么我们一次操作相当于是把其中一个环的路径整体取反，但路径上代表字符不变。 然后我们发现把边都看成无向边，这张图所有的欧拉回路都能被这种操作从最初那张图构造出来。 那就做个贪心找字典序最小的欧拉路即可。 # E 两堆石头， 每次可在一堆中选大于 111 的任意个石头，若某人操作时局面为 (0,0)(0,0)(0,0) 或给出的 nnn 个二元组中其中一个就输了，问先手是否必败。 n≤105,x≤109n\\le 10^5, x\\le 10^9 n≤105,x≤109 很妙的题，细节有点多。 若没给一个二元组，那就是一个 nimnimnim 游戏了，当且仅当 x=yx=yx=y 是局面必败。考虑从几何角度来看，若把每个 (x,y)(x,y)(x,y) 放到笛卡尔坐标系上，根据基本的博弈论知识，我们知道，能到必败态的为必胜态，反之为必败态，那首先 (0,0)(0,0)(0,0) 为必败态，故 x=0,y=0x=0,y=0x=0,y=0 的点都为必胜态，而 (1,1)(1,1)(1,1) 能到的 (1,0),(0,1)(1,0), (0,1)(1,0),(0,1) 都是必胜态，故它为必败态… 考虑加入一些shortcuts\\texttt{shortcuts}shortcuts 后怎么做，那是不是，还是从 (0,0)(0,0)(0,0) 往右走，对于点 (x,y)(x,y)(x,y) ，若同行左侧 / 同列下侧有shortcuts\\texttt{shortcuts}shortcuts，那就这个点反而为必胜态了，然后相应推推即可。 考虑把值域离散化后，那我们往右上爬的过程相当于是走几步后走一段斜率为 111 的直线，那我们用 setsetset 模拟这个过程即可，感觉我没什么脑子，于是贺了网上别人的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* ============================== * Author : Odalys * * Blog : Odalys8191.github.io * * Mail : minyuenu@gmail.com * =============================== */#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w=1; a=0; char ch=getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;;ch=getchar()) if(ch == &#x27;-&#x27;) w=-1; for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar()) a=(a&lt;&lt;3)+(a&lt;&lt;1)+(ch^48); a*=w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define fi first#define se second#define ins insert #define pb push_back#define mp make_pair#define mii map&lt;int, int&gt; #define pii pair&lt;int, int&gt; #define vi vector&lt;int&gt; #define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)#define y1 _y1#define mt make_tupleconst int inf = 0x3f3f3f3f;const int N = 1e5 + 10;map &lt;int, int&gt; mx, my; set &lt; tuple&lt;int, int, int&gt; &gt; line;map &lt;pii, bool&gt; lost;int n, q;int main() &#123; read(n); read(q); For (i, 1, n) &#123; int x, y; read(x); read(y); lost[mp(x, y)] = 1; if (mx.find(x) == mx.end()) mx[x] = y; else ckmin(mx[x], y); if (my.find(y) == my.end()) my[y] = x; else ckmin(my[y], x); &#125; int x = 0, y = 0; for (auto i = mx.begin(), j = my.begin(); i != mx.end() || j != my.end();) &#123; while (i != mx.end() &amp;&amp; (i -&gt; fi) &lt; x) ++i; while (j != my.end() &amp;&amp; (j -&gt; fi) &lt; y) ++j; int x1 = inf, x2 = inf, y1 = inf, y2 = inf; if (i != mx.end()) x1 = (i -&gt; fi), y1 = (i -&gt; se); if (j != my.end()) x2 = (j -&gt; se), y2 = (j -&gt; fi); int mn = min(x1 - x, y2 - y);// cout &lt;&lt; mn &lt;&lt; endl; bool fx = 0, fy = 0; if (x + mn == x1 &amp;&amp; y1 &lt;= y + mn) fx = 1; if (y + mn == y2 &amp;&amp; x2 &lt;= x + mn) fy = 1; if (mn + 1 - max(fx, fy)) line.ins(mt(x + mn - max(fx, fy), x, y)); if (!max(fx, fy)) fx = fy = 1; x += mn + fx, y += mn + fy; &#125; line.ins(mt(inf, x, y));/* for (auto v = line.begin(); v != line.end(); v++) &#123;// cout &lt;&lt; v; printf(&quot;%d %d %d\\n&quot;, get&lt;0&gt;(*v), get&lt;1&gt;(*v), get&lt;2&gt;(*v)); &#125;*/ For (i, 1, q) &#123; int x, y; read(x); read(y); if (lost[mp(x, y)]) &#123;puts(&quot;LOSE&quot;); continue; &#125; auto it = line.lower_bound (mt(x, 0, 0)); if (it == line.end() || get&lt;1&gt;(*it) &gt; x) &#123; puts(&quot;WIN&quot;); continue; &#125; puts(get&lt;2&gt;(*it) + x - get&lt;1&gt;(*it) == y ? &quot;LOSE&quot; : &quot;WIN&quot;); &#125;&#125;","categories":[{"name":"Races","slug":"Races","permalink":"http://odalys8191.github.io/categories/Races/"}],"tags":[{"name":"博弈论","slug":"博弈论","permalink":"http://odalys8191.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"数学","slug":"数学","permalink":"http://odalys8191.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"stl","slug":"stl","permalink":"http://odalys8191.github.io/tags/stl/"},{"name":"dp","slug":"dp","permalink":"http://odalys8191.github.io/tags/dp/"},{"name":"思维","slug":"思维","permalink":"http://odalys8191.github.io/tags/%E6%80%9D%E7%BB%B4/"},{"name":"图论","slug":"图论","permalink":"http://odalys8191.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"gcd","slug":"gcd","permalink":"http://odalys8191.github.io/tags/gcd/"},{"name":"矩阵","slug":"矩阵","permalink":"http://odalys8191.github.io/tags/%E7%9F%A9%E9%98%B5/"},{"name":"欧拉路","slug":"欧拉路","permalink":"http://odalys8191.github.io/tags/%E6%AC%A7%E6%8B%89%E8%B7%AF/"}]},{"title":"CF840E In a Trap","slug":"CF840E-In-a-Trap","date":"2021-10-13T13:14:28.000Z","updated":"2021-10-13T13:42:05.033Z","comments":true,"path":"Solutions/CF840E-In-a-Trap/cm34e3w5k003j5vtn1f3j6g76/","link":"","permalink":"http://odalys8191.github.io/Solutions/CF840E-In-a-Trap/cm34e3w5k003j5vtn1f3j6g76/","excerpt":"","text":"想了一天不会做。 晚上看题解两小时才看懂。。。 思维能力如何提升啊！！！！ 完全想不到啊 /sad 一棵树，点带权，每次询问 (u,v)(u,v)(u,v) 保证 uuu 为 vvv 祖先，求 u→vu \\to vu→v 中 max⁡(ai xor dis(i,v))\\max(a_i\\ \\texttt{xor}\\ dis(i, v))max(ai​ xor dis(i,v)) n≤5×104,ai≤nn\\le 5\\times 10^4, a_i\\le n n≤5×104,ai​≤n # Solutions: 异或运算感觉没有什么特殊性质，所以感觉每道题重复的 tricktricktrick 很多。 在这题中，由于保证了给出的 uuu 为 vvv 的祖先，然后值域又大概在二进制下只有 161616 位，于是我们考虑每个点向上 256256256 个点分为一块，每一块中 depdepdep 的前 888 位是一模一样的，然后往上跳一个块前八位会加上一个 111 ，于是我们朴素地想对每个块预处理出答案，散块直接暴力即可。 每个块如何预处理答案？设 fx,jf_{x, j}fx,j​ 表示第 xxx 号点往上 256256256 个节点中，前面还经过了 jjj 个块时的答案。 因为位数不同，异或时是相对独立的，所以我们可以这么搞： 前八位与后八位分开处理 我们可以把当前每个 aia_iai​ 的后八位异或上块内的每个 depdepdep （一定小于 256256256 ）放到一个前八位的桶里，先存着。 我们把每个 aia_iai​ 前八位放到一个 trietrietrie 里，然后对于每个 jjj 我们在 trietrietrie 上找到最大的一个前八位，再把后八位拼起来就是 fx,jf_{x,j}fx,j​ 乐 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/* ============================== * Author : Odalys * * Blog : Odalys8191.github.io * * Mail : minyuenu@gmail.com * =============================== */#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w=1; a=0; char ch=getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;;ch=getchar()) if(ch == &#x27;-&#x27;) w=-1; for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar()) a=(a&lt;&lt;3)+(a&lt;&lt;1)+(ch^48); a*=w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define fi first#define se second#define pb push_back#define mp make_pair#define mii map&lt;int, int&gt; #define pii pair&lt;int, int&gt; #define vi vector&lt;int&gt; #define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)const int N = 5e4 + 10;struct edge &#123; int to, nxt; &#125; e[N &lt;&lt; 1];int head[N], cnt;inline void add (int u, int v) &#123; e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt;&#125;int dp[N][32], dep[N];void dfs (int u, int fa) &#123; dep[u] = dep[fa] + 1, dp[u][0] = fa; for (int i = 1; (1 &lt;&lt; i) &lt;= dep[u]; ++i) dp[u][i] = dp[dp[u][i - 1]][i - 1]; for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if (v == fa) continue; dfs (v, u); &#125;&#125;int n, q;int a[N]; struct Trie &#123; int ch[2048][2], tot, rt; inline void clear () &#123; memset (ch, 0, sizeof ch); tot = 1; rt = 1; &#125; inline void ins (int x) &#123; int cur = rt; foR (i, 7, 0) &#123; int p = (x &gt;&gt; i) &amp; 1; if (!ch[cur][p]) ch[cur][p] = ++tot; cur = ch[cur][p]; &#125; &#125; int que (int x) &#123; int Ans = 0, cur = rt; foR (i, 7, 0) &#123; int p = (x &gt;&gt; i) &amp; 1; if (ch[cur][!p]) Ans |= (1 &lt;&lt; i), cur = ch[cur][!p]; else cur = ch[cur][p]; &#125; return Ans; &#125;&#125; tr;const int B = 256;int mxp[260], mx[N][260];int main() &#123; read(n); read(q); For (i, 1, n) read(a[i]); For (i, 1, n - 1) &#123; int u, v; read(u); read(v); add(u, v); add(v, u); &#125; dfs (1, 0); For (i, 1, n) &#123; tr.clear(); memset (mxp, 0, sizeof mxp); for (int j = i, st = 0; j &amp;&amp; st &lt; B; j = dp[j][0], st++) &#123; ckmax(mxp[a[j] &gt;&gt; 8], st ^ (a[j] &amp; (B - 1))); tr.ins(a[j] &gt;&gt; 8); &#125; For (j, 0, B - 1) &#123; int p = tr.que(j); ckmax(mx[i][j], (p &lt;&lt; 8) | mxp[p ^ j]); &#125; &#125; For (i, 1, q) &#123; int u, v; read(u); read(v); int cur = v, st = 0, Ans = 0; while (dep[cur] - dep[u] &gt;= B) ckmax(Ans, mx[cur][st]), st++, cur = dp[cur][8]; while (cur ^ u) ckmax(Ans, a[cur] ^ (dep[v] - dep[cur])), cur = dp[cur][0]; ckmax(Ans, a[u] ^ (dep[v] - dep[u])); printf (&quot;%d\\n&quot;, Ans); &#125;&#125;","categories":[{"name":"Solutions","slug":"Solutions","permalink":"http://odalys8191.github.io/categories/Solutions/"}],"tags":[{"name":"妙题","slug":"妙题","permalink":"http://odalys8191.github.io/tags/%E5%A6%99%E9%A2%98/"},{"name":"分块","slug":"分块","permalink":"http://odalys8191.github.io/tags/%E5%88%86%E5%9D%97/"},{"name":"数据结构","slug":"数据结构","permalink":"http://odalys8191.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"每天一道DS题","slug":"每天一道DS题","permalink":"http://odalys8191.github.io/tags/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93DS%E9%A2%98/"}]},{"title":"2021-10-01 Test","slug":"2021-10-01-Test","date":"2021-10-11T12:37:02.000Z","updated":"2021-11-19T01:34:16.950Z","comments":true,"path":"Tests/2021-10-01-Test/cm34e3w4800035vtn5k8g11g0/","link":"","permalink":"http://odalys8191.github.io/Tests/2021-10-01-Test/cm34e3w4800035vtn5k8g11g0/","excerpt":"","text":"赛时做了 T2，想着 T1 是个大贪心 / Dp 不好写，T3 不会做就一直在做 T4，然后并没有发现 T4 是构造题。。。 做题的时候不要畏难，一些看上去不好写的东西想清楚细节再写基本不会写锅，但做法假了当然就。。。 # Solutions # tree 给出一棵树，每次操作挑选联通的两个叶子把他们路径上边全删掉，求最小操作次数使得不能再操作。 n≤5×105n\\le 5\\times 10^5 n≤5×105 贪心地考虑每棵子树内未匹配，可用的叶子数量。 根据奇偶性，可用的叶子数量只可能为 {0,1,2}\\{0,1,2\\}{0,1,2} ，其他的叶子都在当前被操作掉了，然后就硬贪心。 # gcd 给定 nnn 个数字，每次可以把一个数字 +1 或 -1 。求至多多少次操作能使得整个序列都为正数并且 gcd⁡&gt;1\\gcd &gt; 1gcd&gt;1 n≤2×105,ai≤1012n\\le 2\\times 10^5, a_i \\le 10^{12} n≤2×105,ai​≤1012 答案的上界显然是 nnn ，因为我们把每个数变成偶数就有一个 222 的公因子了。 然后我们惊讶的得出一个十分喵喵的结论：至多有 ⌊n2⌋\\lfloor n\\over 2\\rfloor2⌋⌊n​ 个数字被操作次数超过 222 这是咋想到的 换句话说，每个数字被操作次数超过 222 的概率是 121\\over 221​ 所以对于每个数字 xxx ，有 121\\over 221​ 的概率至多被操作次数为 111 ，然后枚举 x+1x+1x+1 ， x−1x-1x−1 ，xxx 的因子作为答案，暴力搞一遍后，没找到最终答案 gcdgcdgcd 的概率为 121\\over 221​ ，如果你比较欧，做个 30 次就差不多行了。 # game Bob 陪 Alice 玩游戏，Alice 会构造一棵每个节点度数不超过 ddd 的带标号树，然后 Bob 选择两个节点把其路径按顺序抠出来，节点标号记做序列 aaa ，Alice 会选出一个位置 iii 把它后面全翻转再加上 aia_iai​ 或者 取负再加上 aia_iai​ 若最终这个序列是单调递增的，那么 Alice 胜利，否则 Bob 胜利 统计所有可能的游戏数目。 n≤200n\\le 200 n≤200 首先，每个人都是按最优策略决策的，而树是 Alice 构造的，所以这棵树满足无论 Bob 选哪里，Alice 都能赢。 所以叫 bob 陪 alice 玩游戏 然后 Alice 其实是个大美女，Bob 输了游戏赢了人生 手玩一下发现性质，单调或单峰的序列 Alice 能赢，这里借用一下 bigmurmur 的图 然后跟这题 类似的，我们发现构造的树为内向树 / 外向树 / 拼起来 然后假如这样的树有 SSS 种，此时 Bob 无论怎么选路径都会输，于是答案为 2n(n−1)S2n(n-1) S2n(n−1)S 我们先来计数纯向树，设 dpi,jdp_{i,j}dpi,j​ 表示大小为 iii 的树根有 jjj 个儿子的方案数，有转移 dpi,j=∑k=1i−1dpi−k,j−1(i−2k−1)∑l=0d−1dpk,ldp_{i,j} = \\sum\\limits_{k=1}^{i-1} dp_{i-k, j-1} \\binom{i-2}{k-1} \\sum\\limits_{l=0}^{d-1} dp_{k,l} dpi,j​=k=1∑i−1​dpi−k,j−1​(k−1i−2​)l=0∑d−1​dpk,l​ 也就是直接给 iii 送一个大小为 kkk 的子树，为了方便我们钦定新树根为标号仅次于 iii 的标号，至于若不是的情况，会在向上合并时被计算到。 然后还是与那题类似的，拼起来的树可能会在中间那条链上被计算多次，于是我们倾定最上面 / 最下面的点为根，开始计数，答案为 ∑i=0n−1∑j+k≤d,k≠1dpi+1,jdpn−i,k\\sum\\limits_{i=0}^{n-1} \\sum\\limits_{j+k\\le d,k\\not = 1} dp_{i+1, j} dp_{n-i, k} i=0∑n−1​j+k≤d,k=1∑​dpi+1,j​dpn−i,k​ # sequence 构造啊… 鸽了","categories":[{"name":"Tests","slug":"Tests","permalink":"http://odalys8191.github.io/categories/Tests/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://odalys8191.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"构造","slug":"构造","permalink":"http://odalys8191.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"随机化","slug":"随机化","permalink":"http://odalys8191.github.io/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96/"},{"name":"数数","slug":"数数","permalink":"http://odalys8191.github.io/tags/%E6%95%B0%E6%95%B0/"},{"name":"博弈论","slug":"博弈论","permalink":"http://odalys8191.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"妙题","slug":"妙题","permalink":"http://odalys8191.github.io/tags/%E5%A6%99%E9%A2%98/"},{"name":"国庆集训","slug":"国庆集训","permalink":"http://odalys8191.github.io/tags/%E5%9B%BD%E5%BA%86%E9%9B%86%E8%AE%AD/"}]},{"title":"LOJ6669 Nauuo and Binary Tree","slug":"LOJ6669-Nauuo-and-Binary-Tree","date":"2021-10-10T13:50:55.000Z","updated":"2021-10-10T14:04:39.284Z","comments":true,"path":"Solutions/LOJ6669-Nauuo-and-Binary-Tree/cm34e3w5s004a5vtn98w8ekv8/","link":"","permalink":"http://odalys8191.github.io/Solutions/LOJ6669-Nauuo-and-Binary-Tree/cm34e3w5s004a5vtn98w8ekv8/","excerpt":"","text":"一棵不确定的二叉树，以 111 为根，每次可询问两点间距离，还原这棵树。 n≤3000n\\le 3000n≤3000 询问次数 30000 # Solution 喵喵的题 首先用 nnn 次询问我们能把每个点的深度求出来 然后我们按深度从小到大处理 深度为 111 显然爹就是 111 然后考虑我们正在处理深度为 iii 的一坨点，深度为 1→i−11\\to i - 11→i−1 已经被我们处理完，现在处理到 xxx 点。 考虑将已经算出来的点做一遍重剖 考虑从 111 出发的一条重链链底 yyy ，我们询问 dis(x,y)dis(x, y)dis(x,y) ，然后利用这种题常用的一个等式 dis(x,y) = dep_x + dep_y - 2 * dep_ 我们可以算出 x,yx,yx,y 的 lcalcalca 的 depdepdep ，而一条重链上 depdepdep 两两不同，所以我们可以唯一确定 lcalcalca 这又是棵二叉树，所以若 lcalcalca 在 111 的重儿子所在子树内，则可以确定 xxx 在 111 重儿子这棵子树，否则就在另外一棵子树中，我们递归地来做一个事情就好，由于重剖的性质，总询问次数是 n+nlog⁡nn + n\\log nn+nlogn 的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/* ============================== * Author : Odalys * * Blog : Odalys8191.github.io * * Mail : minyuenu@gmail.com * =============================== */#include &lt;bits/stdc++.h&gt;using namespace std;inline int read()&#123; int w = 1, a = 0; char ch=getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;;ch=getchar()) if(ch == &#x27;-&#x27;) w=-1; for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar()) a=(a&lt;&lt;3)+(a&lt;&lt;1)+(ch^48); return a * w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define fi first#define se second#define pb push_back#define mp make_pair#define mii map&lt;int, int&gt; #define pii pair&lt;int, int&gt; #define vi vector&lt;int&gt; #define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)#define MckennaGrace fflush(stdin), fflush(stdout);const int N = 3030;int dep[N], n, fa[N], tot;int Dis (int x, int y) &#123; printf (&quot;? %d %d&quot;, x, y); MckennaGrace return read();&#125;vi cur[N];int ch[N][2];inline void add (int u, int v) &#123; if (!ch[u][0]) ch[u][0] = v; else ch[u][1] = v; fa[v] = u;&#125;int siz[N], bot[N];void dfs (int u) &#123; siz[u] = 1, bot[u] = u; if (ch[u][0]) &#123; dfs(ch[u][0]); siz[u] += siz[ch[u][0]]; &#125; if (ch[u][1]) &#123; dfs(ch[u][1]); siz[u] += siz[ch[u][1]]; if (siz[ch[u][1]] &gt; siz[ch[u][0]]) swap(ch[u][0], ch[u][1]); &#125; if (ch[u][0]) bot[u] = bot[ch[u][0]]; &#125;inline void solve (int u) &#123; int v = 1, D; while (dep[v] != dep[u] - 1) &#123; D = Dis(bot[v], u); D = (dep[u] + dep[bot[v]] - D) / 2; while (dep[v] &lt; D) v = ch[v][0]; if (dep[v] == dep[u] - 1) break; v = ch[v][1]; &#125; add(v, u);&#125;int main() &#123; n = read(); int mx = 0; For (i, 2, n) dep[i] = Dis(1, i), cur[dep[i]].pb(i), ckmax(mx, dep[i]); fa[1] = 1; for (auto v : cur[1]) add(1, v); For (i, 2, mx) &#123; dfs(1); for (auto u : cur[i]) solve (u); &#125; printf (&quot;! &quot;); For (i, 2, n) printf (&quot;%d &quot;, fa[i]); MckennaGrace&#125;","categories":[{"name":"Solutions","slug":"Solutions","permalink":"http://odalys8191.github.io/categories/Solutions/"}],"tags":[{"name":"妙题","slug":"妙题","permalink":"http://odalys8191.github.io/tags/%E5%A6%99%E9%A2%98/"},{"name":"重链剖分","slug":"重链剖分","permalink":"http://odalys8191.github.io/tags/%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"交互","slug":"交互","permalink":"http://odalys8191.github.io/tags/%E4%BA%A4%E4%BA%92/"}]},{"title":"AGC001E BBQ Hard","slug":"AGC001E-BBQ-Hard","date":"2021-10-10T12:13:48.000Z","updated":"2021-10-10T12:28:02.936Z","comments":true,"path":"Solutions/AGC001E-BBQ-Hard/cm34e3w5500275vtndowz84fw/","link":"","permalink":"http://odalys8191.github.io/Solutions/AGC001E-BBQ-Hard/cm34e3w5500275vtndowz84fw/","excerpt":"","text":"给 nnn 个数对 (ai,bi)(a_i, b_i)(ai​,bi​) , 要求 ∑i=1n∑i&lt;jn(ai+aj+bi+bjai+bi)\\sum\\limits_{i=1}^n\\sum\\limits_{i&lt;j}^n\\binom{a_i+a_j+b_i+b_j}{a_i+b_i} i=1∑n​i&lt;j∑n​(ai​+bi​ai​+aj​+bi​+bj​​) n≤2×105,ai,bi≤2020n\\le 2\\times 10^5, a_i, b_i \\le 2020 n≤2×105,ai​,bi​≤2020 # Solution: 看妙题推荐来的… 但可能我们平时对这类问题的训练比较多，这个组合意义十分一眼 这个柿子显然有组合意义从 (0,0)(0,0)(0,0) 到 (ai+aj,bi+bj)(a_i+a_j, b_i + b_j)(ai​+aj​,bi​+bj​) 只准向上向右走到方案数。 注意到值域很小，于是平移下坐标，以每个 (−ai,−bi)(-a_i, -b_i)(−ai​,−bi​) 为起点到每个 (aj,bj)(a_j, b_j)(aj​,bj​) 方案数之和除以 222 就好 这显然可以直接 dpdpdp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/* ============================== * Author : Odalys * * Blog : Odalys8191.github.io * * Mail : minyuenu@gmail.com * =============================== */#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w=1; a=0; char ch=getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;;ch=getchar()) if(ch == &#x27;-&#x27;) w=-1; for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar()) a=(a&lt;&lt;3)+(a&lt;&lt;1)+(ch^48); a*=w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define fi first#define se second#define pb push_back#define mp make_pair#define mii map&lt;int, int&gt; #define pii pair&lt;int, int&gt; #define vi vector&lt;int&gt; #define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)const int N = 2020;const int M = 2e5 + 10;const int Mod = 1e9 + 7;inline int Mul (int x, int y) &#123; return (1ll * x * y) &gt;= Mod ? (1ll * x * y % Mod) : (x * y);&#125;inline int Add (int x, int y) &#123; return (x + y) &gt;= Mod ? (x + y - Mod) : (x + y); &#125;inline int Sub (int x, int y) &#123; return (x &lt; y) ? (x + Mod - y) : (x - y); &#125;int f[N &lt;&lt; 1][N &lt;&lt; 1];#define dp(x,y) f[x + 2001][y + 2001]int n;int qpow (int a, int b) &#123; int Ans = 1, base = a; while (b) &#123; if (b &amp; 1) Ans = Mul(Ans, base); base = Mul(base, base); b &gt;&gt;= 1; &#125; return Ans; &#125;int a[M], b[M];int fac[N * 10], ifac[N * 10];inline void Init (int M) &#123; fac[0] = ifac[0] = 1; For (i, 1, M) fac[i] = Mul(fac[i - 1], i); ifac[M] = qpow (fac[M], Mod - 2); foR (i, M - 1, 1) ifac[i] = Mul(ifac[i + 1], i + 1);&#125;int bin (int x, int y) &#123; if (x &lt; y || x &lt; 0 || y &lt; 0) return 0; return Mul(fac[x], Mul(ifac[y], ifac[x - y])); &#125;#define inv2 500000004 int main() &#123; Init ((N * 10) - 10); read(n); memset (f, 0, sizeof f); int mx = 0, my = 0, det = 0; For (i, 1, n) &#123; read(a[i]), read(b[i]); ckmax(mx, a[i]), ckmax(my, b[i]); dp(-a[i], -b[i])++; det = Add(det, bin(2 * (a[i] + b[i]), 2 * a[i])); &#125; For (i, -2000, mx) For (j, -2000, my) dp(i, j) = Add(dp(i, j), Add(dp(i - 1, j), dp(i, j - 1))); int Ans = 0; For (i, 1, n) Ans = Add(Ans, dp(a[i], b[i])); printf (&quot;%d\\n&quot;, Mul(Sub(Ans, det), inv2));&#125;","categories":[{"name":"Solutions","slug":"Solutions","permalink":"http://odalys8191.github.io/categories/Solutions/"}],"tags":[{"name":"格路基础","slug":"格路基础","permalink":"http://odalys8191.github.io/tags/%E6%A0%BC%E8%B7%AF%E5%9F%BA%E7%A1%80/"},{"name":"组合意义","slug":"组合意义","permalink":"http://odalys8191.github.io/tags/%E7%BB%84%E5%90%88%E6%84%8F%E4%B9%89/"},{"name":"Dp","slug":"Dp","permalink":"http://odalys8191.github.io/tags/Dp/"}]},{"title":"LGP7895 『JROI-3』删树","slug":"LGP7895-『JROI-3』删树","date":"2021-10-05T04:14:55.000Z","updated":"2021-10-05T07:05:14.420Z","comments":true,"path":"Solutions/LGP7895-『JROI-3』删树/cm34e3w5r00465vtng78ddg4y/","link":"","permalink":"http://odalys8191.github.io/Solutions/LGP7895-%E3%80%8EJROI-3%E3%80%8F%E5%88%A0%E6%A0%91/cm34e3w5r00465vtng78ddg4y/","excerpt":"","text":"一棵以 111 为根的树，边权未知，你可以进行三种操作： 询问一个点的 dfn 询问一条路径上边权和 删除所有度数为 111 的点，并重标号 要求在 142142142 次操作内得到当前树的边权总和。 n≤5000n\\le 5000 n≤5000 # Solution: 从这题中，我们得到一个关于 dfndfndfn 的小 tricktricktrick ，就是若你知道一些关键点的 dfndfndfn ，那么这些关键点的生成子图边权和等于按 dfn 排序后相邻点距离加最后一个点与第一个点距离除以 222 。 证明个人觉得还是十分简单的，考虑沿着 dfn 顺序，若为子树内节点则向下拉一条覆盖边，否则则向上拉到另一棵子树内，不难发现这样会一来一回经过生成子图上的边两次。 然后在本题中，我们考虑找到一些关键点，使其生成子图为整棵树，那么不难发现取的这些关键点是根 111 + 所有叶子。 那么对于一个大小为 sss 的关键点集合，我们想要借以求出整棵树的边权和，需要 2s2s2s 次询问， sss 次询问求集合 dfn ， sss 次询问求两两路径和。设当前剩余操作次数为 curcurcur ， 若 2s≤cur−12s \\le cur - 12s≤cur−1 ，那就可以直接做了，否则我们需要删掉所有度数为 111 的点直到 2s≤cur−12s \\le cur - 12s≤cur−1 为止。为什么可以直接删？因为当不满足条件时叶子数是大于 cur2cur \\over 22cur​ 的，所以你每次起码会删掉大于 cur2cur \\over 22cur​ 个叶子。而这题点数 500050005000 ，注意到 71+70+70+69+69+68+68+⋯=5041&gt;500071 + 70 + 70 + 69 + 69 + 68 +68 + \\dots = 5041 &gt; 500071+70+70+69+69+68+68+⋯=5041&gt;5000 ，所以一定会在删完前得到一组可以计算的答案。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/* ============================== * Author : Odalys * * Mail : minyuenu@gmail.com * =============================== */#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w=1; a=0; char ch=getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;;ch=getchar()) if(ch == &#x27;-&#x27;) w=-1; for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar()) a=(a&lt;&lt;3)+(a&lt;&lt;1)+(ch^48); a*=w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define fi first#define se second#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt; #define vi vector&lt;int&gt; #define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)#define mck fflush(stdin)#define gra fflush(stdout)const int N = 5050;int du[N];int n;int ck () &#123; int res = 0; For (i, 1, n) if (du[i] == 1) res++; if (du[1] != 1) res++; return res;&#125;struct Node &#123; int id, dfn; Node( int Id = 0, int Dfn = 0) &#123; id = Id, dfn = Dfn; &#125; bool operator &lt; (const Node &amp;x) const &#123; return dfn &lt; x.dfn; &#125;&#125; s[N];int Get (int x) &#123; printf (&quot;dfn %d\\n&quot;, x); mck, gra; int xx; read(xx); return xx;&#125;int Val (int x, int y) &#123; printf (&quot;dis %d %d\\n&quot;, x, y); mck, gra; int xx; read(xx); return xx;&#125;int main() &#123; read(n); For (i, 1, n) read(du[i]); int rem = 142; while (ck() &gt; (rem - 1) / 2) &#123; printf (&quot;del\\n&quot;); mck, gra; rem--; read(n); For (i, 1, n) read(du[i]); &#125; int cnt = 0; For (i, 1, n) if (du[i] == 1) s[++cnt] = Node(i, Get(i)); if (du[1] != 1) s[++cnt] = Node(1, 1); sort (s + 1, s + cnt + 1); int Ans = 0; For (i, 1, cnt - 1) &#123; Ans += Val(s[i].id, s[i + 1].id); &#125; Ans += Val(s[cnt].id, s[1].id); printf (&quot;! %d\\n&quot;, Ans / 2); mck, gra; return 0;&#125;","categories":[{"name":"Solutions","slug":"Solutions","permalink":"http://odalys8191.github.io/categories/Solutions/"}],"tags":[{"name":"dfn妙用","slug":"dfn妙用","permalink":"http://odalys8191.github.io/tags/dfn%E5%A6%99%E7%94%A8/"},{"name":"交互题","slug":"交互题","permalink":"http://odalys8191.github.io/tags/%E4%BA%A4%E4%BA%92%E9%A2%98/"}]},{"title":"从球场之争看一类政治手段","slug":"从球场之争看一类政治手段","date":"2021-10-04T12:45:20.000Z","updated":"2021-10-05T04:17:19.206Z","comments":true,"path":"Article/从球场之争看一类政治手段/cm34e3w65004w5vtn1u4zhj1b/","link":"","permalink":"http://odalys8191.github.io/Article/%E4%BB%8E%E7%90%83%E5%9C%BA%E4%B9%8B%E4%BA%89%E7%9C%8B%E4%B8%80%E7%B1%BB%E6%94%BF%E6%B2%BB%E6%89%8B%E6%AE%B5/cm34e3w65004w5vtn1u4zhj1b/","excerpt":"","text":"好像是又咕了一天 # 从球场之争看一类政治手段 试考虑这样一类生活中常见的情境： 活力四射的体育课，欢乐的自由活动时间，由老师分配好的 A 班活动场地中却迎来了 “不速之客”–其它班的同学由于羡慕 A 班拥有光照条件更为良好的场地，而不经与 A 班同学商量就擅自在场地中打起了球。由于活动场地本就十分狭小，这一行为更是严重影响了 A 班同学们的正常活动，而若将他们全部加入 A 班的活动中则会导致大部分 A 班同学运动时长的减少。本着 “扫干净屋子再活动” 的朴素想法，A 班同学自然会想着将场地内的其他同学赶走，那么，他们该如何做才能保证花费时间尽可能少的同时又能保证能够较好的达成目的呢？ 一个较为轻松且简单的做法是直接报告体育老师，由他来解决这一问题。但大家都是有着一定解决问题的能力的高中生了，这一做法不但没有体现 A 班同学们独立解决问题的能力，同时次数一多老师会感到烦躁，被赶走的同学也不会服气，没准下次乘老师不再又会来，治标不治本，故首先排除此解法。 还有一种较为常用的解法是拉上几个声强力壮的同学，直接上去强硬而不失礼貌地将其赶走。但由于场地内同学正处于运动中，贸然上去容易被体育器材所伤害，同时，这样也极易使事情激化，引发口角与肢体冲突，并不可取。 更为深入地考虑以上两种做法的内核思路是什么？第一种，告老师，是主张利用外部更具支配性的力量来直接裁定问题，在历史长河中寻找例子，有点类似一些藩属国应对内乱而请求其宗主国予以军事政治上的援助。可借来的东西并不是自己的，这一做法只能解一时之渴，并不能从根源上解决问题。第二种做法则是较为激进地主张从正面解决问题，这一解法在本身实力并不强的情况下是伤敌未必一千，而自损可能八百的招数，并不能够高效低损失的解决问题。 考虑前面两种做法的失败之处在于无论是你寻求更高一层支配性的援助，还是单枪匹马直接硬碰硬，你都是将自己放在了少数的，强势者位置，并没有有效的关注到与此时看似利益无关的大部分群体。或者说，对于此类问题，我们应该采用 “将朋友搞得多多的，将敌人搞得少少的” 这一经典政治手段，更为具体地，就是想方设法团结大部分人，针对一小撮人，实际做法笔者目前还没有尝试过。 考虑站在更高的视角来俯瞰 “团结大部分人，针对一小撮人。” 这句话，我们注意到这句话应该是有逻辑联系的，在刚刚情境的讨论中，我们暗含的逻辑关系是 “为了针对一小撮人，而团结大部分人。” 事实上，笔者认为，另外一种正好相反的逻辑关系可能更为高级，也就是 “为了团结大部分人，而针对一小撮人”，这一思路在历史上应该是有相当多的历史实例的，只不过一般施政者并不会说出来。举一个不那么恰当的例子，二战时期的纳粹党，就是为了团结大部分德国民众，而打击犹太人，从而巩固其自身的统治，才有底气与实力对外军事扩张。值得辨析的是政治手段只是为了达成目的所采用的 “术”，本身是没有对错之分，只有好坏之分的。","categories":[{"name":"Article","slug":"Article","permalink":"http://odalys8191.github.io/categories/Article/"}],"tags":[]},{"title":"JOISC 2020 Day4","slug":"JOISC-2020-Day4","date":"2021-09-30T08:17:00.000Z","updated":"2021-09-30T08:45:34.739Z","comments":true,"path":"Solutions/JOISC-2020-Day4/cm34e3w5o003z5vtn7w5w6dr0/","link":"","permalink":"http://odalys8191.github.io/Solutions/JOISC-2020-Day4/cm34e3w5o003z5vtn7w5w6dr0/","excerpt":"","text":"# Capital CityCapital\\ CityCapital City 一棵树，每个点有个颜色，可以合并两个颜色 (x,y)(x,y)(x,y)，效果为把所有颜色 yyy 的改为 xxx ，求最少的合并次数使得存在一个颜色联通块内部无其他颜色。 n,k≤1×105n,k\\le 1\\times 10^5 n,k≤1×105 # Solutions: 大概思路是，若一个颜色 xxx 内部有其它颜色 yyy ，那连边 x→yx\\to yx→y ，代表如果要以 xxx 为首都必须合并 yyy 具体的，我们把一个颜色的点按 dfn 排序，然后相邻的点路径上连边可以把这个颜色块的生成子图都覆盖一遍，考虑路径连边，套路的上树链剖分，再用个线段树优化连边的小技巧。 建出图后跑 tarjantarjantarjan 找最小的出度为 000 联通块大小就好 有亿点点细节，但应该是思维难度极低的 JOISCJOISCJOISC 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147/* ============================== * Author : Odalys * * Mail : minyuenu@gmail.com * =============================== */#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w=1; a=0; char ch=getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;;ch=getchar()) if(ch == &#x27;-&#x27;) w=-1; for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar()) a=(a&lt;&lt;3)+(a&lt;&lt;1)+(ch^48); a*=w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define fi first#define se second#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt; #define vi vector&lt;int&gt; #define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)const int N = 1e6 + 10;const int V = 1e6 + 10;vi g[N], G[V], grace[N];int n, k;int fa[N], tp[N], son[N], siz[N]; int dfn[N], dfntot, rnk[N], dep[N];int c[N];void dfs1 (int u, int father) &#123; fa[u] = father; siz[u] = 1; dep[u] = dep[father] + 1; for (auto v : g[u]) &#123; if (v == fa[u]) continue; dfs1(v, u); siz[u] += siz[v]; if (siz[v] &gt; siz[son[u]]) son[u] = v; &#125;&#125;int Node;void dfs2 (int u, int Top) &#123; rnk[dfn[u] = ++dfntot] = u; tp[u] = Top; if (!son[u]) return; dfs2 (son[u], Top); for (auto v : g[u]) &#123; if (v == fa[u] || v == son[u]) continue; dfs2 (v, v); &#125;&#125;struct SEG &#123; int ls, rs, k, l, r; &#125; tr[N &lt;&lt; 2]; int build (int l, int r) &#123; int x = ++Node; tr[x].l = l; tr[x].r = r; if (l == r) return G[x].pb(c[rnk[l]]), x; int mid = l + r &gt;&gt; 1; tr[x].ls = build (l, mid); tr[x].rs = build (mid + 1, r); G[x].pb(tr[x].ls), G[x].pb(tr[x].rs); return x;&#125;void update (int x, int ll, int rr, int mck) &#123; if (ll &lt;= tr[x].l &amp;&amp; tr[x].r &lt;= rr) return G[mck].pb(x), void(); int mid = tr[x].l + tr[x].r &gt;&gt; 1; if (ll &lt;= mid) update(tr[x].ls, ll, rr, mck); if (rr &gt; mid) update(tr[x].rs, ll, rr, mck);&#125;int rt;int LCA (int x, int y) &#123; int fx = tp[x], fy = tp[y]; while (fx != fy) &#123; if (dep[fx] &gt;= dep[fy]) x = fa[fx]; else y = fa[fy]; fx = tp[x], fy = tp[y]; &#125; return dep[x] &lt; dep[y] ? x : y;&#125;void upd (int x, int y, int Color) &#123; int fx = tp[x], fy = tp[y]; while (fx != fy) &#123; if (dep[fx] &gt;= dep[fy]) &#123; update(rt, dfn[fx], dfn[x], Color), x = fa[fx]; &#125; else &#123; update(rt, dfn[fy], dfn[y], Color), y = fa[fy]; &#125; fx = tp[x], fy = tp[y]; &#125; if (dfn[x] &gt; dfn[y]) swap(x, y); update(rt, dfn[x], dfn[y], Color); &#125;int lw[V], df[V], deep;int col[V], sta[V], top, color;int vis[N];void tarjan (int u) &#123; lw[u] = df[u] = ++deep; vis[sta[++top] = u] = 1; for (auto v : G[u]) if (!df[v]) tarjan(v), ckmin(lw[u], lw[v]); else if (vis[v]) ckmin(lw[u], df[v]); if (lw[u] == df[u]) &#123; color++; while (sta[top] != u) &#123; vis[sta[top]] = false; col[sta[top--]] = color; &#125; vis[sta[top]] = false; col[sta[top--]] = color; &#125;&#125;int du[N], si[N];int main() &#123; read(n); read(k); For (i, 1, n - 1) &#123; int x, y; read(x); read(y); g[x].pb(y), g[y].pb(x); &#125; For (i, 1, n) &#123; read(c[i]); grace[c[i]].pb(i); &#125; dfs1(1, 0), dfs2(1, 1); Node = k; rt = build(1, n); For (i, 1, k) &#123; sort (grace[i].begin(), grace[i].end(), [&amp;] (int x, int y) &#123;return dfn[x] &lt; dfn[y];&#125; ); int nx = grace[i].size() - 1; For (j, 1, nx) upd(grace[i][j - 1], grace[i][j], i); &#125; For (i, 1, Node) if (!df[i]) tarjan(i); For (u, 1, k) si[col[u]]++; For (u, 1, Node) for (auto v : G[u]) if (col[v] != col[u]) du[col[u]]++; int Ans = 0x3f3f3f3f; For (i, 1, k) if (!du[col[i]]) ckmin(Ans, si[col[i]] - 1); cout &lt;&lt; Ans; return 0;&#125;","categories":[{"name":"Solutions","slug":"Solutions","permalink":"http://odalys8191.github.io/categories/Solutions/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://odalys8191.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"tarjan","slug":"tarjan","permalink":"http://odalys8191.github.io/tags/tarjan/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://odalys8191.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"dfn 的相关应用","slug":"dfn-的相关应用","permalink":"http://odalys8191.github.io/tags/dfn-%E7%9A%84%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8/"}]},{"title":"JOISC泛做","slug":"JOISC泛做","date":"2021-09-30T08:01:11.000Z","updated":"2021-09-30T08:12:24.479Z","comments":true,"path":"Plans/JOISC泛做/cm34e3w5q00415vtn32x72krd/","link":"","permalink":"http://odalys8191.github.io/Plans/JOISC%E6%B3%9B%E5%81%9A/cm34e3w5q00415vtn32x72krd/","excerpt":"","text":"JOISC 2017 Day1","categories":[{"name":"Plans","slug":"Plans","permalink":"http://odalys8191.github.io/categories/Plans/"}],"tags":[{"name":"JOISC","slug":"JOISC","permalink":"http://odalys8191.github.io/tags/JOISC/"}]},{"title":"构造与思维","slug":"构造与思维","date":"2021-09-30T01:34:48.000Z","updated":"2021-09-30T01:52:22.136Z","comments":true,"path":"Solutions/构造与思维/cm34e3w6700535vtn07hy4o1u/","link":"","permalink":"http://odalys8191.github.io/Solutions/%E6%9E%84%E9%80%A0%E4%B8%8E%E6%80%9D%E7%BB%B4/cm34e3w6700535vtn07hy4o1u/","excerpt":"","text":"由于构造与思维题想出来后编程复杂度接近与 000 ，于是开个合集 # CF468C Hack it! 定义 f(x)f(x)f(x) 为 xxx 各数位之和，构造一组 l,rl, rl,r 使得 ∑i=lrf(i)≡0(moda)\\sum\\limits_{i=l}^{r} f(i) \\equiv 0 \\pmod{a}i=l∑r​f(i)≡0(moda) ，其中 aaa 为给定值。 a≤1018,l,r≤10200a\\le 10^{18}, l, r \\le 10^{200} a≤1018,l,r≤10200 # Solution: 发现 f(x+1018)=f(x)+1f(x + 10^{18}) = f(x) + 1f(x+1018)=f(x)+1 令 ∑i=01018−1f(i)mod a=p\\sum_{i=0}^{10^{18} - 1} f(i) \\mod a = p∑i=01018−1​f(i)moda=p 然后整体右移，发现 p+1p + 1p+1 。 然后就是手算了。 # [ARC089C] GraphXY 给定 di,jd_{i,j}di,j​ 矩阵，要求构造一张无向图，边权为值 vvv 或未知数 x,yx,yx,y ，要求 x=a,y=bx=a,y=bx=a,y=b 时你定的起点 sss ，终点 ttt 最短路为 da,bd_{a,b}da,b​ 。 n,m≤10,v≤100n,m\\le 10, v\\le 100n,m≤10,v≤100 # Solution: 不妨设 fi,jf_{i,j}fi,j​ 表示最短路上有 iii 个 xxx ，jjj 个 yyy 离 d_","categories":[{"name":"Solutions","slug":"Solutions","permalink":"http://odalys8191.github.io/categories/Solutions/"}],"tags":[{"name":"构造","slug":"构造","permalink":"http://odalys8191.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"思维","slug":"思维","permalink":"http://odalys8191.github.io/tags/%E6%80%9D%E7%BB%B4/"}]},{"title":"CF22E Scheme","slug":"CF22E-Scheme","date":"2021-09-29T00:39:29.000Z","updated":"2021-09-29T11:13:03.083Z","comments":true,"path":"Solutions/CF22E-Scheme/cm34e3w5i003b5vtn85kz9fsb/","link":"","permalink":"http://odalys8191.github.io/Solutions/CF22E-Scheme/cm34e3w5i003b5vtn85kz9fsb/","excerpt":"","text":"求让一张图变成强联通图至少增加多少边并输出边， 每个点只有一个出度。 n≤1×105n\\le 1\\times 10^5 n≤1×105 # Solutions: 这种最优化问题不妨先考虑问题的下 / 上界，再寻找有无反例使得下 / 上界不能取到 本题中，由于每个点只有一个出度这个限制，也就是 nnn 个点 nnn 条边，不难发现会连出一张基环内向树森林。 考虑答案的下界一定是以环为根时，每棵树的叶子点数。因为这些点的入度为 000 ，想让图强连通起码得使它们的入度为 111 ，而一条边只能贡献 111 入度。 考虑有无反例能否使下界无法取到。 考虑若只有一棵树，那答案就是下界，由于每个叶子出发都能到根，于是只要把根环中一点向每个叶子连边即可。 考虑如果是一片森林，如何构造使得答案离下界尽可能近，显然是选择一个叶子被下一棵树根相连，最后一棵树的叶子被第一个树相连。 被摆王秒切了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/* ============================== * Author : Odalys * * Mail : minyuenu@gmail.com * =============================== */#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w=1; a=0; char ch=getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;;ch=getchar()) if(ch == &#x27;-&#x27;) w=-1; for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar()) a=(a&lt;&lt;3)+(a&lt;&lt;1)+(ch^48); a*=w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define fi first#define se second#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt; #define vi vector&lt;int&gt; #define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)const int N = 1e5 + 10;struct edge &#123; int to, nxt;&#125; e[N &lt;&lt; 1], edges[N &lt;&lt; 1];int head[N], cnt;int Head[N], cnts; inline void add (int u, int v) &#123; e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt;&#125;inline void addedge (int u, int v) &#123; edges[++cnts].to = v; edges[cnts].nxt = Head[u]; Head[u] = cnts;&#125;int sta[N], top, dfn[N], low[N], deep;int vis[N], color, col[N];int node[N];void tarjan (int u) &#123; dfn[u] = low[u] = ++deep; vis[sta[++top] = u] = 1; for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if (!dfn[v]) tarjan(v), ckmin(low[u], low[v]); else if (vis[v]) ckmin(low[u], dfn[v]); &#125; if (dfn[u] == low[u]) &#123; color++; node[color] = u; while (sta[top] != u) &#123; col[sta[top]] = color; vis[sta[top--]] = 0; &#125; col[sta[top]] = color; vis[sta[top--]] = 0; &#125;&#125;int du[N], rd[N];int g[N], tot;vi tr[N];void dfs (int u) &#123; int fl = 0; for (int i = Head[u]; i; i = edges[i].nxt) &#123; int v = edges[i].to; fl = 1; dfs(v); &#125; if (!fl) tr[tot].pb(u); &#125;int rt[N];int main() &#123; int n; read(n); For (i, 1, n) &#123; int x; read(x); add(i, x); &#125; For (i, 1, n) if (!dfn[i]) tarjan(i); For (u, 1, n) for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if (col[v] != col[u]) du[col[v]]++, rd[col[u]]++, addedge(col[v], col[u]); &#125; int Ans = 0; For (i, 1, color) &#123; if (!rd[i]) &#123; rt[i] = 1; tr[++tot].pb(i); dfs(i); if (tr[tot].size() == 2 &amp;&amp; tr[tot][0] == tr[tot][1]) continue; //Ans += tr[tot].size() - 1; &#125; &#125; For (i, 1, color) &#123; if (!du[i]) &#123; if (tot &gt; 1) Ans++; else if (!rt[i]) Ans++; &#125; &#125; printf (&quot;%d\\n&quot;, Ans); if (!Ans) return 0; /*for (int i = 1; i &lt;= tot; ++i) &#123; cout &lt;&lt;&quot;tree&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; endl; cout &lt;&lt; tr[i][0] &lt;&lt; endl; for (int j = 1; j &lt; tr[i].size(); ++j) cout &lt;&lt; tr[i][j] &lt;&lt; &quot; &quot;; &#125;*/ if (tot == 1) &#123; int m = tr[1].size() - 1; For (i, 1, m) printf (&quot;%d %d\\n&quot;, node[tr[1][0]], node[tr[1][i]]); return 0; &#125; For (id, 1, tot) &#123; int m = tr[id].size() - 1; For (i, 2, m) printf (&quot;%d %d\\n&quot;, node[tr[id][0]], node[tr[id][i]]); if (id &lt; tot) printf (&quot;%d %d\\n&quot;, node[tr[id][0]], node[tr[id + 1][1]]); &#125; printf (&quot;%d %d\\n&quot;, node[tr[tot][0]], node[tr[1][1]]); return 0;&#125;","categories":[{"name":"Solutions","slug":"Solutions","permalink":"http://odalys8191.github.io/categories/Solutions/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://odalys8191.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"tarjan","slug":"tarjan","permalink":"http://odalys8191.github.io/tags/tarjan/"}]},{"title":"Tricks","slug":"Tricks","date":"2021-09-28T12:03:52.000Z","updated":"2021-10-05T07:07:50.446Z","comments":true,"path":"Review/Tricks/cm34e3w5t004d5vtn48l55lvn/","link":"","permalink":"http://odalys8191.github.io/Review/Tricks/cm34e3w5t004d5vtn48l55lvn/","excerpt":"","text":"# 位运算 a+b = (a & b) + (a | b)\\\\ a+b = (a ^ b) + 2 (a & b)\\\\ a ^ b = (a | b) - (a & b)\\\\","categories":[{"name":"Review","slug":"Review","permalink":"http://odalys8191.github.io/categories/Review/"}],"tags":[{"name":"Tricks","slug":"Tricks","permalink":"http://odalys8191.github.io/tags/Tricks/"}]},{"title":"CF19D Points","slug":"CF19D-Points","date":"2021-09-28T11:08:31.000Z","updated":"2021-09-28T11:42:26.916Z","comments":true,"path":"Solutions/CF19D-Points/cm34e3w5h00375vtn61oa33q7/","link":"","permalink":"http://odalys8191.github.io/Solutions/CF19D-Points/cm34e3w5h00375vtn61oa33q7/","excerpt":"","text":"一些坐标上的问题可以考虑在每个坐标上取一个点，将其转换为序列问题。 坐标系上维护三种操作：加点，删点，询问一个点右上角最靠左，最下的一点 n≤2×105n\\le 2\\times 10^5 n≤2×105 # Solutions: 只会大力 KDT,CDQKDT, CDQKDT,CDQ 输光了 其实考虑询问以最靠左为第一关键字，那么我们从 (x0,y0)(x_0, y_0)(x0​,y0​) 找到一个最小的 xxx 若这一列存在成立的点，那答案就在这一列找到第一个大于 y0y_0y0​ 的就好 这启发我们每个 xxx 列保留最上面一个点，然后问题变成了查询一段区间内值大于某个数的最靠前的位置，这是一个经典问题，线段树上二分即可。 为了方便的处理修改操作，我们建 2e52e52e5 个 set 来维护一个列上的点，那求最大值删除添加点都可以 O(1)\\mathrm O(1)O(1) 解决 找到答案列后，在对应列的 set 上 upper_bound 一下就好了 这样复杂度是一个 log⁡\\loglog 的 注意在每个 set 中加入一个最小值可以更为方便地处理添加删除点时 set 为空的情况，避免了繁琐的讨论。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/* ============================== * Author : Odalys * * Mail : minyuenu@gmail.com * =============================== */#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w=1; a=0; char ch=getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;;ch=getchar()) if(ch == &#x27;-&#x27;) w=-1; for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar()) a=(a&lt;&lt;3)+(a&lt;&lt;1)+(ch^48); a*=w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define fi first#define se second#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt; #define vi vector&lt;int&gt; #define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)const int N = 2e5 + 10;struct Question &#123; int opt, x, y; Question (int Opt = 0, int X = 0, int Y = 0) &#123; opt = Opt, x = X, y = Y; &#125;&#125; s[N]; // 0 add// 1 remove// 2 findint n;int lshx[N], lshy[N];int cntx, cnty;set &lt;int&gt; mck[N];inline void Init() &#123; For (i, 1, n) &#123; char op[8]; int x, y; scanf (&quot;%s&quot;, op); read(x); read(y); if (op[0] == &#x27;a&#x27;) s[i] = Question (0, x, y); if (op[0] == &#x27;r&#x27;) s[i] = Question (1, x, y); if (op[0] == &#x27;f&#x27;) s[i] = Question (2, x + 1, y + 1); lshx[++cntx] = s[i].x, lshy[++cnty] = s[i].y; mck[i].insert(-1); &#125; sort (lshx + 1, lshx + cntx + 1); cntx = unique(lshx + 1, lshx + cntx + 1) - lshx - 1; sort (lshy + 1, lshy + cnty + 1); cnty = unique(lshy + 1, lshy + cnty + 1) - lshy - 1;&#125;int Idx (int x) &#123; return lower_bound(lshx + 1, lshx + cntx + 1, x) - lshx; &#125;int Idy (int x) &#123; return lower_bound(lshy + 1, lshy + cnty + 1, x) - lshy; &#125;#define ls x &lt;&lt; 1#define rs x &lt;&lt; 1 | 1int mx[N &lt;&lt; 2];inline void pushup (int x) &#123; mx[x] = max(mx[ls], mx[rs]); &#125;void update (int x, int l, int r, int p, int v) &#123; if (l == r) return mx[x] = v, void(); int mid = l + r &gt;&gt; 1; if (p &lt;= mid) update(ls, l, mid, p, v); else update(rs, mid + 1, r, p, v); pushup(x); &#125;int query (int x, int l, int r, int X, int Y) &#123; if (l == r) return (mx[x] &gt;= Y) ? l : -1; int mid = l + r &gt;&gt; 1; if (X &lt;= mid &amp;&amp; mx[ls] &gt;= Y) &#123; int tmp = query(ls, l, mid, X, Y); if (~tmp) return tmp; &#125; if(mx[rs] &gt;= Y) return query(rs, mid + 1, r, X, Y); return -1;&#125;void qq (int x, int l, int r) &#123; if (l == r) return cout &lt;&lt; mx[x] &lt;&lt; &quot; &quot;, void(); int mid = l + r &gt;&gt; 1; qq(ls, l, mid); qq(rs, mid + 1, r);&#125;inline void Solve () &#123; For (i, 1, n) &#123; s[i].x = Idx(s[i].x), s[i].y = Idy(s[i].y); if (s[i].opt == 0) &#123; int las = *(mck[s[i].x].rbegin()); if (s[i].y &gt; las) update(1, 1, cntx, s[i].x, s[i].y); mck[s[i].x].insert(s[i].y); &#125; // add if (s[i].opt == 1) &#123; mck[s[i].x].erase(s[i].y); update(1, 1, cntx, s[i].x, *mck[s[i].x].rbegin()); &#125; // rem if (s[i].opt == 2) &#123; int x = -1; x = query(1, 1, cntx, s[i].x, s[i].y); if (x == -1) puts(&quot;-1&quot;); else &#123; auto it = mck[x].lower_bound(s[i].y); if (it == mck[x].end()) &#123;puts(&quot;-1&quot;); continue;&#125; printf (&quot;%d %d\\n&quot;, lshx[x], lshy[(*it)]); &#125; &#125; &#125;&#125;int main() &#123; read(n); Init(); Solve();&#125;","categories":[{"name":"Solutions","slug":"Solutions","permalink":"http://odalys8191.github.io/categories/Solutions/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://odalys8191.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"http://odalys8191.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"每天一道DS题","slug":"每天一道DS题","permalink":"http://odalys8191.github.io/tags/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93DS%E9%A2%98/"}]},{"title":"CF176E Archaeology","slug":"CF176E-Archaeology","date":"2021-09-27T12:21:22.000Z","updated":"2021-09-28T11:45:10.490Z","comments":true,"path":"Solutions/CF176E-Archaeology/cm34e3w5g00355vtn0nwj4wbb/","link":"","permalink":"http://odalys8191.github.io/Solutions/CF176E-Archaeology/cm34e3w5g00355vtn0nwj4wbb/","excerpt":"","text":"树上关键点的生成子图等于按 dfn 序后相邻点距离加最后一个点与第一个点距离 一棵树，树边带权，初始每个点都为白色，三种操作：染白，染黑，询问所有黑点的生成子图边权和。 n≤105n\\le 10^5 n≤105 # Solution: 口胡： 考虑加入一个点的贡献，发现是到之前生成子图中某点的距离，然后要使用很复杂的东西来维护，然后就不会做了。 实际上可以考虑全局来看这个问题，发现把黑点的 dfndfndfn 放一起排序后相邻点距离加上第一个与最后一个点的距离除以二就是黑点的生成子图距离和。 证明个人觉得还是十分简单的，考虑顺着 dfndfndfn 顺序，若为子树内节点则向下拉一条覆盖边，否则则向上拉到另一棵子树内，不难发现这样会一来一回经过生成子图上的边两次，关键在于感觉自己不太能想到这样维护生成子图。 如果想到这样一个性质那这题就很好做了，考虑使用 setsetset 即可维护这样一个 dfndfndfn 序列，修改一次是 log⁡\\loglog 的，查询是 111 的。 感觉这种妙题难以想到，还是要多总结 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139/* ============================== * Author : Odalys * * Mail : minyuenu@gmail.com * =============================== */#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w=1; a=0; char ch=getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;;ch=getchar()) if(ch == &#x27;-&#x27;) w=-1; for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar()) a=(a&lt;&lt;3)+(a&lt;&lt;1)+(ch^48); a*=w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define fi first#define se second#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt; #define vi vector&lt;int&gt; #define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)#define int long longconst int N = 1e5 + 10;struct edge &#123; int to, nxt, dis; &#125; e[N &lt;&lt; 1];int head[N], cnt;inline void add (int u, int v, int w) &#123; e[++cnt].to = v; e[cnt].nxt = head[u]; e[cnt].dis = w; head[u] = cnt;&#125;int dep[N], dis[N];int dp[N][32], val[N][32];int dfn[N], dfntot, rnk[N];void Init (int u, int fa) &#123; dep[u] = dep[fa] + 1; dp[u][0] = fa; dfn[u] = ++dfntot; rnk[dfntot] = u; for (int i = 1; (1 &lt;&lt; i) &lt;= dep[u]; ++i) dp[u][i] = dp[dp[u][i - 1]][i - 1]; for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if (v == fa) continue; dis[v] = dis[u] + e[i].dis; Init(v, u); &#125;&#125;int LCA (int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); foR (i, 22, 0) if (dep[x] - (1 &lt;&lt; i) &gt;= dep[y]) x = dp[x][i]; if (x == y) return x; foR (i, 22, 0) if (dp[x][i] != dp[y][i]) x = dp[x][i], y = dp[y][i]; return dp[x][0];&#125;int Dis (int x, int y) &#123; int lca = LCA(x, y); return dis[x] + dis[y] - 2 * dis[lca];&#125;set &lt;int&gt; mck;int Ans;void ins (int x) &#123; mck.insert (dfn[x]); if (mck.size() &lt;= 1) return ; auto it = mck.lower_bound(dfn[x]), en = mck.end(); en--; if (it == mck.begin()) &#123; auto fo = it; fo++; Ans -= Dis(rnk[*fo], rnk[*en]); Ans += Dis(x, rnk[*fo]); Ans += Dis(x, rnk[*en]); &#125; else if (it == en) &#123; auto fo = it; fo--; Ans -= Dis(rnk[*mck.begin()], rnk[*fo]); Ans += Dis(rnk[*mck.begin()],rnk[*en]); Ans += Dis(rnk[*fo], rnk[*en]); &#125; else &#123; auto la = it, nx = it; la--, nx++; Ans -= Dis(rnk[*la], rnk[*nx]); Ans += Dis(rnk[*la], x); Ans += Dis(rnk[*nx], x); &#125; &#125;void era (int x) &#123; if (mck.size() &lt;= 1) &#123;mck.erase(dfn[x]); return ;&#125; auto it = mck.lower_bound(dfn[x]), en = mck.end(); en--; if (it == mck.begin()) &#123; auto fo = it; fo++; Ans += Dis(rnk[*fo], rnk[*en]); Ans -= Dis(x, rnk[*fo]); Ans -= Dis(x, rnk[*en]); &#125; else if (it == en) &#123; auto fo = it; fo--; Ans += Dis(rnk[*mck.begin()], rnk[*fo]); Ans -= Dis(rnk[*mck.begin()],rnk[*en]); Ans -= Dis(rnk[*fo], rnk[*en]); &#125; else &#123; auto la = it, nx = it; la--, nx++; Ans += Dis(rnk[*la], rnk[*nx]); Ans -= Dis(rnk[*la], x); Ans -= Dis(rnk[*nx], x); &#125; mck.erase(dfn[x]); &#125;signed main() &#123; int n; read(n); For (i, 1, n - 1) &#123; int u, v, w; read(u); read(v); read(w); add(u, v, w), add(v, u, w); &#125; Init(1, 0); puts(&quot;&quot;); int m; read(m); while (m--) &#123; char opt[3]; int x; scanf (&quot;%s&quot;, opt); if (opt[0] == &#x27;+&#x27;) &#123; read(x); ins(x); &#125; if (opt[0] == &#x27;-&#x27;) &#123; read(x); era(x); &#125; if (opt[0] == &#x27;?&#x27;) printf (&quot;%lld\\n&quot;, Ans / 2ll); &#125;&#125;","categories":[{"name":"Solutions","slug":"Solutions","permalink":"http://odalys8191.github.io/categories/Solutions/"}],"tags":[{"name":"stl","slug":"stl","permalink":"http://odalys8191.github.io/tags/stl/"},{"name":"数据结构","slug":"数据结构","permalink":"http://odalys8191.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"每天一道DS题","slug":"每天一道DS题","permalink":"http://odalys8191.github.io/tags/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93DS%E9%A2%98/"},{"name":"dfn妙用","slug":"dfn妙用","permalink":"http://odalys8191.github.io/tags/dfn%E5%A6%99%E7%94%A8/"}]},{"title":"CF173E Camping Groups","slug":"CF173E-Camping-Groups","date":"2021-09-23T08:06:14.000Z","updated":"2021-09-28T11:46:08.017Z","comments":true,"path":"Solutions/CF173E-Camping-Groups/cm34e3w5f00315vtn7wdwfc15/","link":"","permalink":"http://odalys8191.github.io/Solutions/CF173E-Camping-Groups/cm34e3w5f00315vtn7wdwfc15/","excerpt":"","text":"数据结构题先想离线做法 nnn 个人，每个人有地位 rir_iri​ 和年龄 aia_iai​ 。定义一个小组组长为小组中地位不严格最高，年龄与其他成员差距不超过 kkk 。mmm 组询问 (x,y)(x,y)(x,y) 表示询问第 xxx 个人与第 yyy 个人分到同一组的情况下，这个小组最多能分到多少人。 n≤105,k,r≤109n\\le 10^5, k, r\\le 10^9 n≤105,k,r≤109 查 FourteenObsidian 表得到的 DS 好题 一开始一直考虑在直接做，然后胡了个树套树，然后不会写感觉空间也会炸，然后自闭了… 遇到这种不强制在线的题第一时间还是要想离线怎么做，然后这题如果离线下来就很好做了。 首先考虑钦定一个人为组长的话，这个小组最大是多少，这个问题可以考虑把人按年龄从小到大排序，然后对于第 iii 个人搞个 l,rl,rl,r 双指针维护 ax∈[ai−k,ai+k]a_x \\in [a_i-k, a_i+k]ax​∈[ai​−k,ai​+k] 的所有人 xxx ，这个区间内的人是年龄合法的，于是只要在指针移动时把每个人放到 / 拿出地位权值树状数组里，指针移动完毕后查树状数组里地位小于等于第 iii 人的人数就可以算出以每个人为组长的组大小了。 然后考虑一个 (x,y)(x,y)(x,y) 的询问，哪些人可以成为这个询问的组长呢，显然是地位大于等于 max⁡{rx,ry}\\max \\{ r_x, r_y \\}max{rx​,ry​} 的人，于是我们把一个询问按 max⁡{rx,ry}\\max \\{ r_x, r_y \\}max{rx​,ry​} 从大到小排序，每次搞个指针移动下维护一个可以成为询问组长的人的集合 SSS。 这个集合内的所有人是地位合法的，考虑年龄合法的人是什么样的。不妨设 ax≤aya_x \\le a_yax​≤ay​ ，则可以作为组长的人年龄应该在 [ay−k,ax+k][a_y - k, a_x + k][ay​−k,ax​+k] 这个区间内，这是一个连续区间，我们很自然的考虑到可以把 SSS 的每个人放到年龄权值线段树上，每个贡献为其作为组长的组大小，然后查一下区间最大值即可解决。 代码细节是由于年龄和地位都是 ≤109\\le 10^9≤109 的，所以需要离散化，而如果你不将询问权值线段树时形成的 [ay−k,ax+k][a_y-k,a_x+k][ay​−k,ax​+k] 区间也放到离散化数组里，你可能需要在右端点讨论一下～ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/* ============================== * Author : Odalys * * Mail : minyuenu@gmail.com * =============================== */#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w=1; a=0; char ch=getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;;ch=getchar()) if(ch == &#x27;-&#x27;) w=-1; for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar()) a=(a&lt;&lt;3)+(a&lt;&lt;1)+(ch^48); a*=w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define fi first#define se second#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt; #define vi vector&lt;int&gt; #define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)const int N = 1e5 + 10;struct Node &#123; int r, a, dw, id;&#125; s[N]; bool cmp1 (Node x, Node y) &#123; return x.dw &lt; y.dw; &#125;bool cmp2 (Node x, Node y) &#123; return x.r &gt; y.r; &#125;struct Ques &#123; int x, y, id; bool operator &lt; (const Ques &amp;c) const &#123; return max(s[x].r, s[y].r) &gt; max(s[c.x].r, s[c.y].r); &#125;&#125; q[N];int n, k, m;int lsh1[N], cnt1;int lsh2[N], cnt2; int Status[N], Age[N];int Ida (int x) &#123; return lower_bound (lsh1 + 1, lsh1 + cnt1 + 1, x) - lsh1; &#125;int Idr (int x) &#123; return lower_bound (lsh2 + 1, lsh2 + cnt2 + 1, x) - lsh2; &#125;inline void Init () &#123; For (i, 1, n) read(s[i].r), s[i].id = i, lsh2[++cnt2] = s[i].r; For (i, 1, n) read(s[i].a), lsh1[++cnt1] = s[i].a; sort (lsh1 + 1, lsh1 + cnt1 + 1); cnt1 = unique(lsh1 + 1, lsh1 + cnt1 + 1) - lsh1 - 1; sort (lsh2 + 1, lsh2 + cnt2 + 1); cnt2 = unique(lsh2 + 1, lsh2 + cnt2 + 1) - lsh2 - 1; For (i, 1, n) s[i].dw = Ida(s[i].a), s[i].r = Idr(s[i].r), Status[i] = s[i].r, Age[i] = s[i].a; read(m); For (i, 1, m) read(q[i].x), read(q[i].y), q[i].id = i; sort (q + 1, q + m + 1); &#125; // in &amp; lshstruct BIT &#123; int sum[N]; inline void upd (int x, int v) &#123; for (int i = x; i &lt;= cnt2; i += (i &amp; (-i))) sum[i] += v; &#125; inline int que (int x) &#123; int Ans = 0; for (int i = x; i; i -= (i &amp; (-i))) Ans += sum[i]; return Ans; &#125;&#125; tr; int val[N];inline void Captain() &#123; static int L, R; L = 0, R = 0; sort (s + 1, s + n + 1, cmp1); For (i, 1, n) &#123; while (R &lt; n &amp;&amp; s[R + 1].a - s[i].a &lt;= k) R++, tr.upd (s[R].r, 1); while (L &lt; R &amp;&amp; s[i].a - s[L + 1].a &gt; k) L++, tr.upd (s[L].r, -1); val[s[i].id] = tr.que(s[i].r); &#125; sort (s + 1, s + n + 1, cmp2);&#125; // Get Every i to be Captain &#x27;s Ans int mx[N &lt;&lt; 2];#define ls x &lt;&lt; 1#define rs x &lt;&lt; 1 | 1inline void pushup (int x) &#123; mx[x] = max(mx[ls], mx[rs]); &#125;void update (int x, int l, int r, int p, int v) &#123; if (l == r) return ckmax(mx[x], v), void(); int mid = l + r &gt;&gt; 1; if (p &lt;= mid) update (ls, l, mid, p, v); else update(rs, mid + 1, r, p, v); pushup(x); &#125;int query (int x, int l, int r, int ll, int rr) &#123; if (ll &gt; rr) return -1; if (ll &lt;= l &amp;&amp; r &lt;= rr) return mx[x]; int mid = l + r &gt;&gt; 1, Ans = -1; if (ll &lt;= mid) ckmax(Ans, query(ls, l, mid, ll, rr)); if (rr &gt; mid) ckmax(Ans, query(rs, mid + 1, r, ll, rr)); return Ans;&#125;#undef ls#undef rsint Ans[N]; inline void Solve () &#123; int L = 0; For (i, 1, m) &#123; int tmp = max(Status[q[i].x], Status[q[i].y]); while (L &lt; n &amp;&amp; s[L + 1].r &gt;= tmp) L++, update(1, 1, cnt1, s[L].dw, val[s[L].id]); int ql = Age[q[i].x], qr = Age[q[i].y]; if (ql &gt; qr) swap(ql, qr); int l = qr - k, r = ql + k; if (l &gt; r) &#123; Ans[q[i].id] = -1; continue;&#125; int xx = r; l = Ida(l), r = Ida(r); if (lsh1[r] &gt; xx) r--; Ans[q[i].id] = query (1, 1, cnt1, l, r); if (!Ans[q[i].id]) Ans[q[i].id] = -1; &#125;&#125; // download all the query to solveint main() &#123; read(n); read(k); Init(); Captain(); Solve(); For (i, 1, m) printf (&quot;%d\\n&quot;, Ans[i]); return 0;&#125;","categories":[{"name":"Solutions","slug":"Solutions","permalink":"http://odalys8191.github.io/categories/Solutions/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://odalys8191.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"双指针","slug":"双指针","permalink":"http://odalys8191.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"树状数组","slug":"树状数组","permalink":"http://odalys8191.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"线段树","slug":"线段树","permalink":"http://odalys8191.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"2021-9-21 Test","slug":"2021-9-21-Test","date":"2021-09-21T07:35:14.000Z","updated":"2021-09-21T07:57:21.687Z","comments":true,"path":"Tests/2021-9-21-Test/cm34e3w4y001l5vtnhu8589f6/","link":"","permalink":"http://odalys8191.github.io/Tests/2021-9-21-Test/cm34e3w4y001l5vtnhu8589f6/","excerpt":"","text":"100 + 100 + 0 倒是没什么好说的，开始一边在码 T2 一边在 hack lzh 双线作战，然后静下心来 Rush 完 T1 就弃考了，T3 也不是我考试时能写出来的 QwQ # game 模拟 2048 游戏 n≤8,m≤105n\\le 8, m\\le 10^5 n≤8,m≤105 # Sol: 按题意模拟即可 感觉代码写的十分清新自然，贴一发 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189 #pragma GCC optimize(2) #pragma GCC optimize(3)/* ============================== * Author : Odalys * * Mail : minyuenu@gmail.com * =============================== */#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w=1; a=0; char ch=getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;;ch=getchar()) if(ch == &#x27;-&#x27;) w=-1; for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar()) a=(a&lt;&lt;3)+(a&lt;&lt;1)+(ch^48); a*=w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define fi first#define se second#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt; #define vi vector&lt;int&gt; #define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)#define mck insert#define era eraseconst int N = 10;int n, m;int Id (int x, int y) &#123; return (x - 1) * n + y; &#125;set &lt;int&gt; emp;int val[N][N], res[N][N];pii gra[N * N];inline void cache () &#123; For (i, 1, n) For (j, 1, n) res[i][j] = val[i][j];&#125;inline bool diff () &#123; For (i, 1, n) For (j, 1, n) if (res[i][j] != val[i][j]) return true; return false;&#125;inline void upd (int k, int v) &#123; int top = 0; for (auto x : emp) &#123; top++; if (top == k) &#123; val[gra[x].fi][gra[x].se] = v; emp.era(x); break; &#125; &#125;&#125;inline void Mckenna (int x, int y, int fx, int fy) &#123; val[x][y] = val[fx][fy]; emp.era(Id(x, y)); emp.mck(Id(fx, fy)); val[fx][fy] = 0;&#125; //move (fx, fy) to (x, y)inline void move (int to) &#123; if (to == 0) &#123; For (i, 1, n - 1) For (j, 1, n) &#123; if (!val[i][j]) For (k, i + 1, n) if (val[k][j]) &#123; Mckenna(i, j, k, j); break; &#125; &#125; &#125; if (to == 1) &#123; foR (i, n, 2) For (j, 1, n) &#123; if (!val[i][j]) &#123; foR (k, i - 1, 1) if (val[k][j]) &#123; Mckenna(i, j, k, j); break; &#125; &#125; &#125; &#125; if (to == 2) &#123; For (j, 1, n - 1) For (i, 1, n) &#123; if (!val[i][j]) For (k, j + 1, n) if (val[i][k]) &#123; Mckenna(i, j, i, k); break; &#125; &#125; &#125; if (to == 3) &#123; foR (j, n, 2) For (i, 1, n) &#123; if (!val[i][j]) foR (k, j - 1, 1) if (val[i][k]) &#123; Mckenna(i, j, i, k); break; &#125; &#125; &#125;&#125;int tmp;inline void merge (int to) &#123; if (to == 0) &#123; For (i, 1, n - 1) For (j, 1, n) &#123; if (val[i][j] == val[i + 1][j] &amp;&amp; val[i][j]) &#123; tmp += val[i][j] * 2; val[i + 1][j] = 0; val[i][j] *= 2; emp.mck(Id(i + 1, j)); &#125; &#125; &#125; if (to == 1) &#123; foR (i, n, 2) For (j, 1, n) &#123; if (val[i][j] == val[i - 1][j] &amp;&amp; val[i][j]) &#123; tmp += val[i][j] * 2; val[i - 1][j] = 0; val[i][j] *= 2; emp.mck(Id(i - 1, j)); &#125; &#125; &#125; if (to == 2) &#123; For (j, 1, n - 1) For (i, 1, n) &#123; if (val[i][j] == val[i][j + 1] &amp;&amp; val[i][j]) &#123; tmp += val[i][j] * 2; val[i][j + 1] = 0; val[i][j] *= 2; emp.mck(Id(i, j + 1)); &#125; &#125; &#125; if (to == 3) &#123; foR (j, n, 2) For (i, 1, n) &#123; if (val[i][j] == val[i][j - 1] &amp;&amp; val[i][j]) &#123; tmp += val[i][j] * 2; val[i][j - 1] = 0; val[i][j] *= 2; emp.mck(Id(i, j - 1)); &#125; &#125; &#125;&#125;inline void print () &#123; For (i, 1, n) &#123; For (j, 1, n) cout &lt;&lt; val[i][j] &lt;&lt; &quot; &quot;; puts(&quot;&quot;); &#125; puts(&quot;&quot;);&#125;int main() &#123; read(n); read(m); For (i, 1, n) For (j, 1, n) emp.mck(Id(i, j)), gra[Id(i,j)] = mp(i, j); int x, y, v; read(x), read(y), read(v); emp.era(Id(x, y)); val[x][y] = v; read(x), read(y), read(v); emp.era(Id(x, y)); val[x][y] = v; int Ans1 = 0, Ans2 = 0; For (i, 1, m) &#123; int d, k, v; read(d); read(k); read(v); cache(); move(d); tmp = 0; merge(d); move(d); Ans2 += tmp; if ( diff () ) Ans1++; else break; int r = emp.size(); upd (1 + (k % r), v); &#125; printf (&quot;%d\\n%d&quot;, Ans1, Ans2); return 0;&#125; 复杂度是 O(n3m)\\mathrm O(n^3m)O(n3m) 的 # seq 一个长度为 nnn 的序列，选出一个子序列，定义其权值为其和除以上升段 + 下降段总段数，最大化权值 n≤105n\\le 10^5 n≤105 # Sol: 贪心地发现答案要不是一整段上升的，要不一段上升一段下降的 于是就正反跑一遍 LIS 枚举一个断点搞一搞就好 # mst 一张无向图，边权为一个虚数，定义虚数比大小为模长的比较，求最大生成树。 # Sol: 假如我们知道答案向量的方向，我们把每条边向其取投影长度，那么按这个跑 kruskl 就是最大生成树长度。 所以我们就可以枚举每个方向求 max 这样显然会 T，于是考虑 kruskl 的过程中，我们并不关注每条边具体有多长，我们只关注两条边的相对关系，于是考虑一个类似临界的问题，考虑枚举两条向量，我们能求出一条向量使这两条投影长度相同，那么这两个区间内，每条边权的相对大小不会改变，于是 kruskl 求出的生成树边也不会改变，于是每个区间内取个代表向量，然后直接做即可。","categories":[{"name":"Tests","slug":"Tests","permalink":"http://odalys8191.github.io/categories/Tests/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://odalys8191.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"模拟","slug":"模拟","permalink":"http://odalys8191.github.io/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"LIS","slug":"LIS","permalink":"http://odalys8191.github.io/tags/LIS/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://odalys8191.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"线性代数","slug":"线性代数","permalink":"http://odalys8191.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}]},{"title":"2021-9-20 Test","slug":"2021-9-20-Test","date":"2021-09-20T07:05:26.000Z","updated":"2021-11-18T14:19:13.477Z","comments":true,"path":"uncategorized/2021-9-20-Test/cm34e3w4x001i5vtn6ilrfcz8/","link":"","permalink":"http://odalys8191.github.io/uncategorized/2021-9-20-Test/cm34e3w4x001i5vtn6ilrfcz8/","excerpt":"","text":"100 + 100 + 0 中间好像摆了不少时间，导致没有深入思考 T3 T1 做到快下考，其实根本不难写，但怕翻车写了比正解还长的暴力并拍了很久 # common 一棵以 rtrtrt 为根的树，点带权，定义 sumisum_isumi​ 表示点 iii 为根的子树 内权值和，两种操作：1. 单点修改 2. 求 ∑i=lrsumi\\sum\\limits_{i=l}^r sum_ii=l∑r​sumi​ n,m≤1×105n,m\\le 1\\times 10^5 n,m≤1×105 # Sol: 没有看错，是子树内权值和 首先能得出一个十分 naivenaivenaive 的暴力，使用 BITBITBIT 单点修改，再暴力的处理询问，这样修改复杂度 O(log⁡n)\\mathrm O(\\log n)O(logn) ，询问复杂度 O(n×log⁡n)\\mathrm O(n \\times \\log n)O(n×logn) 如果你看到 707070 分暴力忍不出了开始 rushrushrush ，没准你就走上了错误的道路 然后我们发现修改快的像正解，而询问有亿点点慢，于是我们考虑一个经典套路 – 根号平衡 把原点序列分个块，再预处理出每个点在每个块的影响力，就可以 O(log⁡nn\\mathrm O(\\log n \\sqrt nO(lognn​ 查询， O(nlog⁡n)\\mathrm O(\\sqrt n \\log n)O(n​logn) 修改乐。 # 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/* ============================== * Author : Odalys * * Mail : minyuenu@gmail.com * =============================== */#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w=1; a=0; char ch=getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;;ch=getchar()) if(ch == &#x27;-&#x27;) w=-1; for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar()) a=(a&lt;&lt;3)+(a&lt;&lt;1)+(ch^48); a*=w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define int unsigned int long long#define fi first#define se second#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt; #define vi vector&lt;int&gt; #define wife puts(&quot;MckennaGrace&quot;)#define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)const int N = 1e5 + 10;struct edge &#123; int to, nxt; &#125; e[N &lt;&lt; 1];int head[N], cnt, val[N];inline void add (int u, int v) &#123; e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt;&#125;int n, m, rt;int dfn[N], dfntot, low[N];struct BIT &#123; int sum[N]; inline void upd (int x, int v) &#123; for (int i = x; i &lt;= n; i += (i &amp; (-i))) sum[i] += v; &#125; inline int ask (int x) &#123; int Ans = 0; for (int i = x; i; i -= (i &amp; (-i))) Ans += sum[i]; return Ans; &#125;&#125; tr; int Sum[N];void dfs (int u, int fa) &#123; dfn[u] = ++dfntot; Sum[u] = val[u]; for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if (v == fa) continue; dfs(v, u); Sum[u] += Sum[v]; &#125; low[u] = dfntot;&#125; int bel[N], siz, blo, Ans[N];int To[N][318];void dfs1 (int u, int fa) &#123; To[u][bel[u] - 1]++; for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if (v == fa) continue; For (j, 0, blo - 1) To[v][j] += To[u][j]; dfs1(v, u); &#125;&#125;inline void work (int u, int v) &#123; For (i, 0, blo - 1) &#123; int x = To[u][i]; Ans[i + 1] += x * (v - val[u]); &#125; tr.upd(dfn[u], v - val[u]); val[u] = v;&#125;inline int sol (int l, int r) &#123; int ret = 0; //if (bel[l] &lt; bel[r]) return 0; if (bel[l] == bel[r]) &#123; For (i, l, r) ret += tr.ask(low[i]) - tr.ask(dfn[i] - 1); return ret; &#125; For (i, bel[l] + 1, bel[r] - 1) ret += Ans[i]; For (i, l, min(n, bel[l] * siz)) ret += tr.ask(low[i]) - tr.ask(dfn[i] - 1); For (i, (bel[r] - 1) * siz + 1, r) ret += tr.ask(low[i]) - tr.ask(dfn[i] - 1); return ret;&#125;signed main() &#123; read(n), read(m); For (i, 1, n) read(val[i]); For (i, 1, n) &#123; int u, v; read(u); read(v); if (!u) rt = v; else add(u, v), add(v, u); &#125; dfs(rt, 0); For (i, 1, n) tr.upd(dfn[i], val[i]); siz = sqrt (n), blo = n / siz; for (int i = 1; i &lt;= blo; ++i) For (j, (i - 1) * siz + 1, i * siz) bel[j] = i, Ans[i] += Sum[j]; if (blo * siz &lt; n)&#123; For (i, blo * siz + 1, n) bel[i] = blo + 1; blo++; &#125; dfs1(rt, 0); //For (i, 1, n) // Debug(dfn[i]), Debug(low[i]); //For (i, 1, n) // cout &lt;&lt; bel[i] &lt;&lt; &quot; &quot; ; //puts(&quot;&quot;); while (m--) &#123; int opt, u, v; read(opt); read(u); read(v); if (opt == 1) work (u, v); else printf (&quot;%llu\\n&quot;, sol(u, v)); &#125; return 0; &#125; # art kn,mk_{n,m}kn,m​ ，求生成树个数 n,m≤1×1018n,m\\le 1\\times 10^{18} n,m≤1×1018 # Sol: 这个 n,mn,mn,m 范围一看就有结论啦 使用 matrix treematrix\\ treematrix tree 玩一玩矩阵可得到结论 Ans=nm−1×mn−1Ans = n^{m-1} \\times m^{n-1} Ans=nm−1×mn−1 注意到 n,mn,mn,m 一乘就爆 ll 于是要使用龟速乘 # hands 从 (0,0)(0,0)(0,0) 出发，每次可前往 (u+Ax,v+Ay)/(u+Bx,v+By)(u+Ax, v+Ay) / (u+Bx, v+By)(u+Ax,v+Ay)/(u+Bx,v+By) ，问到 (n,m)(n,m)(n,m) 的方案数 n,m≤500,∣Ax∣,∣Ay∣,∣Bx∣,∣By∣≤500n,m\\le 500, |Ax|,|Ay|,|Bx|,|By|\\le 500 n,m≤500,∣Ax∣,∣Ay∣,∣Bx∣,∣By∣≤500 # Sol: 乍一看像是 iodwadiodwadiodwad 出过的题 实际上也是的 虽然这玩意可以走负的，但把这两种走法看做两个向量，题目保证这两个向量不平行，也就意味着这两个向量可以张成所有点，于是转换一下坐标就是那道题了。","categories":[],"tags":[]},{"title":"LGP4198 楼房重建","slug":"LGP4198-楼房重建","date":"2021-09-19T12:15:24.000Z","updated":"2021-09-23T08:49:19.531Z","comments":true,"path":"Solutions/LGP4198-楼房重建/cm34e3w5r00445vtnc1z987io/","link":"","permalink":"http://odalys8191.github.io/Solutions/LGP4198-%E6%A5%BC%E6%88%BF%E9%87%8D%E5%BB%BA/cm34e3w5r00445vtnc1z987io/","excerpt":"","text":"nnn 座楼房，每座楼房高度为 aia_iai​ ，每天会把一栋楼升高 or 降低 111 单位高度，定义一栋楼被看到当且仅当它最高点到 (0,0)(0,0)(0,0) 连线上无其他楼房，求每时每刻能被看到的房屋数量。 n,m≤105,y≤109n,m\\le 10^5, y\\le 10^9 n,m≤105,y≤109 # Sol: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* ============================== * Author : Odalys * * Mail : minyuenu@gmail.com * =============================== */#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w=1; a=0; char ch=getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;;ch=getchar()) if(ch == &#x27;-&#x27;) w=-1; for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar()) a=(a&lt;&lt;3)+(a&lt;&lt;1)+(ch^48); a*=w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a, T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a, T b)&#123;a = a &lt; b ? a : b;&#125;#define fi first#define se second#define pb push_back#define mp make_pair#define pii pair&lt;int, int&gt; #define vi vector&lt;int&gt; #define Debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define For(i,l,r) for (int i = l; i &lt;= r; ++i) #define foR(i,l,r) for (int i = l; i &gt;= r; --i)#define db double const int N = 1e5 + 10;db mx[N &lt;&lt; 2];int siz[N &lt;&lt; 2];#define ls x &lt;&lt; 1#define rs x &lt;&lt; 1 | 1int Get (int x, int l, int r, db k) &#123; if ( mx[x] &lt;= k ) return 0; if (l == r) return (mx[x] &gt; k); int mid = l + r &gt;&gt; 1; if ( mx[ls] &lt;= k ) return Get (rs, mid + 1, r, k); return Get (ls, l, mid, k) + siz[x] - siz[ls]; &#125;void update (int x, int l, int r, int p, db y) &#123; if (l == r) return (mx[x] = 1. * (y / p), siz[x] = 1), void(); int mid = l + r &gt;&gt; 1; if (p &lt;= mid) update (ls, l, mid, p, y); else update (rs, mid + 1, r, p, y); siz[x] = siz[ls] + Get(rs, mid+ 1, r, mx[ls]); mx[x] = max(mx[ls], mx[rs]);&#125;int main() &#123; int n, m; read(n); read(m); for (int i = 1, x, y; i &lt;= m; ++i) &#123; read(x), read(y); update(1, 1, n, x, y); printf (&quot;%d\\n&quot;, siz[1]); &#125; return 0; &#125;","categories":[{"name":"Solutions","slug":"Solutions","permalink":"http://odalys8191.github.io/categories/Solutions/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://odalys8191.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"http://odalys8191.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"斜率","slug":"斜率","permalink":"http://odalys8191.github.io/tags/%E6%96%9C%E7%8E%87/"}]},{"title":"2021-9-16 Test","slug":"2021-9-16 Test","date":"2021-09-19T07:37:17.000Z","updated":"2021-11-18T14:16:02.739Z","comments":true,"path":"Tests/2021-9-16 Test/cm34e3w4w001f5vtnc1xu0hek/","link":"","permalink":"http://odalys8191.github.io/Tests/2021-9-16%20Test/cm34e3w4w001f5vtnc1xu0hek/","excerpt":"","text":"# 2021-9-16 Test 100 + 0 + 0 + 30 T1 由于高中数学知识有点忘了，写了 2h+ T2 并不知道这个奇妙的 MO 结论 T3 没开 T4 一直在考虑转换贡献贪心，没有想到网络流 总之就是知识树不够广，思维不够活跃 # Raster 三维空间中很多三角形，全在 xyxyxy 平面上方，每次询问一条端点在 xyxyxy 平面上，垂直与 xyxyxy 平面的一条射线穿过的若干三角形中，哪个三角形到端点最近。 n,Q≤1000n,Q\\le 1000 n,Q≤1000 # Sol: 无脑 O(nq)\\mathrm O(nq)O(nq) ，每个三角形求个法向量，这样就能表示平面方程了，然后求出每条射线与每个三角形平面的交点看是不是在三角形内部，这个解个平面方程在用叉积看一看就好，调试上的细节是如果复制了两个差不多的代码段前一个有错那后裔个一定有错 # Binom 给定一个质数 ppp ，和一个整数 nnn ，对所有 0≤k≤K0\\le k\\le K0≤k≤K 求有多少 0≤m≤n0\\le m\\le n0≤m≤n 使得 \\binom{n}{m}\\equiv 0\\pmod n≤101000,K≤3000,p≤109n\\le 10^{1000}, K\\le 3000, p\\le 10^9 n≤101000,K≤3000,p≤109 # Sol: 这种 nnn 贼大的看到就只有两种出路… 要不高精搞，要不数位 dp。 见识少极易被打脸 UPD: 对了，还可能与其无关 这题要利用一个 MO 结论， kummerkummerkummer 定理： (n+mn)≡0(modpk)\\binom{n + m}{n} \\equiv 0\\pmod{p^k}(nn+m​)≡0(modpk) 若成立，则 n,mn,mn,m 在 ppp 进制下的加法进了 kkk 次位。 知道这一点后先把给出的 nnn 当做 n+mn+mn+m 转成 ppp 进制，然后套路地设 dpi,j,0/1,0/1dp_{i,j,0/1,0/1}dpi,j,0/1,0/1​ 表示从高到低第 iii 位，已经进了 jjj 位，上一位进了 / 没进，当前有 / 无顶上界的方案数，转移有亿点点细节～ 此时我们得出的是 x,y≤nx,y \\le nx,y≤n 的方案数，我们要求的是 x+y=nx+y = nx+y=n 的答案，于是我们把 n−−n--n−− 再做一遍容斥掉即可。 # CRC 给定一些模 222 意义下的多项式，给出一些 aaa ，给定 ccc， 求出 bbb ，满足 c=amod bc = a \\mod bc=amodb n≤3000,∣∑∣≤3000n\\le 3000, |\\sum| \\le 3000 n≤3000,∣∑∣≤3000 # Sol: 发现模 222 意义下，多项式减法就是异或啦 然后把每个 aaa 先减去 ccc 然后直接做一个多项式 gcd⁡\\gcdgcd 考虑把普通的 gcd⁡\\gcdgcd 放到多项式上，发现就是模拟一个大除法的过程 用 bitsetbitsetbitset 优化以下即可通过此题。 # Food 若干城市形成一张有向图，每个城市有一些产能 eie_iei​ 可正可负，每座城市有个权值 did_idi​ ，其贡献为 di∣ei∣d_i|e_i|di​∣ei​∣ ，有 mmm 条路 (u,v,c,w)(u,v,c,w)(u,v,c,w) ，每条路可以花费 www 使得 eu−−,ev++e_u--, e_v++eu​−−,ev​++ 最多用 ccc 次，最小化贡献和 n≤200,m,d,∣e∣,c≤4000n\\le 200, m, d, |e|, c\\le 4000 n≤200,m,d,∣e∣,c≤4000 # Sol: 发现走一条路的效果是 eu−−,ev++e_u--, e_v++eu​−−,ev​++ ，很像流量守恒，于是考虑网络流 原来的路边我们保留，那么网络上流量的意义就是产能 eee 了 发现流量很多是负的并不好处理，于是我们整体加上一个大数 MAX\\mathrm MAXMAX 此时 MAXMAXMAX 为 000 了 源点向每个点连一条 M+eiM + e_iM+ei​ 的边表示每个点初始的产能，然后发现这些流量是可以在点之间流流流的，每个点最终流量 fff 考虑在它流到汇点时统计答案 若 f≥MAXf\\ge \\mathrm MAXf≥MAX ，我们认为此时此城市的最终产能是要大于 000 的，贡献应为 (f−MAX)×di(f-\\mathrm MAX) \\times d_i(f−MAX)×di​ 而 f&lt;MAXf &lt; \\mathrm MAXf&lt;MAX ，贡献应为 (MAX−f)×di(\\mathrm MAX - f) \\times d_i(MAX−f)×di​ 考虑用两条边来模拟这个过程，对于每个点，我们向汇点连一条容量为 MAX\\mathrm MAXMAX ，费用为 −di-d_i−di​ 的边，这里我们是把第二个柿子拆开来看的，预先把常数 MAX×di\\mathrm MAX \\times d_iMAX×di​ 加入答案里，那每流一次就自然会减掉 did_idi​ ，类似的，我们还向汇点连一条容量为 INFINFINF ，费用为 did_idi​ 的边，由于我们 MCMFMCMFMCMF 的过程是跑最短路的，所以我们优先会流 −di-d_i−di​ 的路，流满后不难发现就是上面那个过程","categories":[{"name":"Tests","slug":"Tests","permalink":"http://odalys8191.github.io/categories/Tests/"}],"tags":[{"name":"高精","slug":"高精","permalink":"http://odalys8191.github.io/tags/%E9%AB%98%E7%B2%BE/"},{"name":"计算几何","slug":"计算几何","permalink":"http://odalys8191.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"高中数学","slug":"高中数学","permalink":"http://odalys8191.github.io/tags/%E9%AB%98%E4%B8%AD%E6%95%B0%E5%AD%A6/"},{"name":"MO","slug":"MO","permalink":"http://odalys8191.github.io/tags/MO/"},{"name":"数位Dp","slug":"数位Dp","permalink":"http://odalys8191.github.io/tags/%E6%95%B0%E4%BD%8DDp/"},{"name":"费用流","slug":"费用流","permalink":"http://odalys8191.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"}]},{"title":"CF1455","slug":"CF1455","date":"2021-09-13T13:35:07.000Z","updated":"2021-09-19T09:10:08.786Z","comments":true,"path":"Races/CF1455/cm34e3w59002l5vtn5lvo8gbz/","link":"","permalink":"http://odalys8191.github.io/Races/CF1455/cm34e3w59002l5vtn5lvo8gbz/","excerpt":"","text":"# CF1455 (4/7)(4/7)(4/7) 形式化的表示题意更容易发现突破口。 二维的问题考虑每维分开来考虑再用题目限制关联起来 # \\texttt 题意： 定义一个数 xxx 翻转函数 f(x)f(x)f(x) 为把 xxx 从低位到高为再写成一个数字并去掉前导零。求对于 1≤x≤X1\\le x \\le X1≤x≤X ，求 if(f(i))i\\over f(f(i))f(f(i))i​ 的取值种数。 题解： 发现只有最后有 000 的翻过来翻回去后才会变，于是不难发现答案就是 XXX 位数。 # \\texttt 题意： ​ 初始站在数轴 000 位置，第 iii 次操作可以选择向左走 iii 步或向右走 111 步，求到正半轴 xxx 所需最少步数。 题解： ​ 把正整数前缀和写出来，设第一个比 xxx 大的前缀和为 aaa ，这相当于是一直向左走步数，而我们要求的是在其中选择几步往右走。不难发现相当于是给 a−(x+1)a-(x+1)a−(x+1) ，xxx 是 1...p1...p1...p 的中的一个数，发现 a−x=1a-x=1a−x=1 时必须用 p+1p+1p+1 步，因为找不到这样的一个 xxx ，否则用 ppp 步，即在这 1+2+...+p1+2+...+p1+2+...+p 中选择一个反转。 # \\texttt 题意： ​ alicealicealice 和 bobbobbob 玩游戏，每个人有体力值，击打一次球耗 111 体力，谁不能击球就输掉这轮比赛，下一轮由胜者开局。开局必须打，初始 alicealicealice 开局，每个人希望自己胜的尽可能多。 题解： ​ 发现后手占绝对优势，他能赢完自己体力次，于是输出 a−1,ba-1,ba−1,b # \\texttt 题意： ​ 给出一个序列 xxx ，每次可以把序列中的一个 &gt;x&gt;x&gt;x 的数与 xxx 交换， 问最少操作次数使整个序列升序。 题解： ​ 设交换的数为 aia_iai​ ，则要求 ai&gt;x,ai&gt;max⁡j=1i−1aja_i&gt;x,a_i&gt; \\max\\limits_{j=1}^{i-1}a_jai​&gt;x,ai​&gt;j=1maxi−1​aj​ ，所以对于所有 &gt;x&gt;x&gt;x 的位置，都应该换，若前面有一个没换就不满足条件了。 ​ 而还可以发现最后没有逆序的一段不需要换，于是把最后一个逆序的位置找出来，前面做一遍交换操作，最后扫一遍是否合法判断 −1-1−1 # \\texttt 题意： ​ 四个点，求移动最小距离使之构成一个正方形。 题解： ​ 首先可以 4!4!4! 枚举每个点最后是正方形的什么点，设 a,b,c,da,b,c,da,b,c,d 分别成为正方形左上左下，右上右下点。 ​ 然后把横纵坐标分开来考虑，以横坐标为例，由简单的初中数学可知，最终正方形的最左横坐标应该处于 ax,bxa_x,b_xax​,bx​ 之间比较优，这样 a,ba,ba,b 移动距离（横坐标）就是 ∣ax−bx∣|a_x-b_x|∣ax​−bx​∣ 的了，如果不在这中间，则每偏离一个单位要多走 222 步。类似的，我们还可以得出最右横坐标的取值，进一步得出正方形边长的取值区间，若与纵坐标的取值区间有交答案就是 ，前面这些加起来，否则就加上偏移量 ×2\\times 2×2 # \\texttt 题意： ​ 给定一个字符串，对于第 iii 个字符， 操作 L,R,U,D,OL, R, U, D, OL,R,U,D,O 分别表示与前 / 后一个字符交换，替换为字符集中前 / 后一个字符，不动，求原串依次对每个字符 iii 进行操作后，得到的字典序最小的字符串。 题解： 发现第 iii 步操作后只影响得到前 i+1i+1i+1 个字符，于是用 stringstringstring 数组当 dpdpdp 数组。设 dpidp_{i}dpi​ 表示第 iii 个操作前 i+1i + 1i+1 个字符所对应的最小字符串，发现 L,D,U,OL,D,U,OL,D,U,O 都很容易转移了，而 RRR 可能影响到前面的东西。发现 RRR 最多影响到 i−2i-2i−2 位，还得是 RLRLRL 的时候，于是多记录一维表示上一步操作是不是 RRR # \\texttt 题意： G 题解： 在最开始加一个 if 0if \\ 0if 0 ，发现我们可以构建一棵树。设 dpu,jdp_{u,j}dpu,j​ 为 uuu 的子树进去，出来后为 jjj 的最小代价。使用线段树合并来转移。 ​ 对于一个 setsetset ，有两种转移： 1. 在 valvalval 位置赋值为此时 dpdpdp 数组最小值表示执行这条语句；2. 在除 valvalval 以外的位置加上 costcostcost 表示不执行这条语句。 ​ 对于一个 ififif 相当于开始一个新 dpdpdp ，也就是新建一棵线段树，只在 valvalval 处为 000 ，其他为 infinfinf","categories":[{"name":"Races","slug":"Races","permalink":"http://odalys8191.github.io/categories/Races/"}],"tags":[{"name":"Vp","slug":"Vp","permalink":"http://odalys8191.github.io/tags/Vp/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://odalys8191.github.io/tags/Codeforces/"}]},{"title":"CF1406","slug":"CF1406","date":"2021-09-11T01:39:10.000Z","updated":"2021-09-13T12:11:09.270Z","comments":true,"path":"Race/CF1406/cm34e3w58002h5vtnadlk9j1z/","link":"","permalink":"http://odalys8191.github.io/Race/CF1406/cm34e3w58002h5vtnadlk9j1z/","excerpt":"","text":"# CF1406 3/5 多测要清空 对于序列贡献形如 ai−ai−1a_i-a_{i-1}ai​−ai−1​ 这类的序列区间操作，可以考虑维护差分数组 交互题对操作次数有限制的，可以先想想暴力怎么做，再推推性质使用分块等技巧削去无用的 / 可以合并的操作 # A 题意： 一个数列，要把它划分为两个集合 AAA ， BBB ，最大化 mex(A)+mex(B)\\mathrm mex (A) +\\mathrm mex(B)mex(A)+mex(B) n,ai≤100n,a_i\\le 100 n,ai​≤100 题解： 桶 # B 题意： nnn 个数中找 555 个数使其乘积最大。 n≤105n\\le 10^5 n≤105 题解： 排序 答案只有可能为偶数个最小值乘其余的最大值 # C 题意： 一棵树，删一条边连一条边使得只有一个重心。 3≤n≤3×1053\\le n\\le 3\\times 10^5 3≤n≤3×105 题解: 最多两个重心，且相邻 把一个重心下面的叶子加到另一个重心上，就只有一个重心了。 # D 题意： 给出一个序列 aaa ，构造两组序列 b,cb,cb,c 使得 bi+ci=aib_i+c_i=a_ibi​+ci​=ai​ ，bbb 单调不降， ccc 单调不升，求最小的 max⁡{bi,ci}\\max\\{b_i,c_i\\}max{bi​,ci​} ，区间加修改。 题解： 答案是 \\max \\ 假设一开始 aia_iai​ 是平的，那 bi=cib_i=c_ibi​=ci​ 观察到若 aaa 凸起了，ccc 若加了，则全局 ccc 都要加 ，不如加 bbb bn=b1+(S=∑max⁡{0,ai−ai−1})b_n = b_1+(S=\\sum \\max\\{0,a_i-a_{i-1}\\})bn​=b1​+(S=∑max{0,ai​−ai−1​}) 所以 c1+bn=x+a1−x+S=a1+Sc_1+b_n = x+ a_1-x+S=a_1+Sc1​+bn​=x+a1​−x+S=a1​+S 显然，两个相等时答案最小。 则最小答案 a1+S2a_1+S\\over22a1​+S​ 对于区间修改，维护一个差分数组，看看左右端点的变化即可。 # E 题意： 交互题 一个 1→n1\\to n1→n 的集合，有一个关键数字 三种操作： 询问集合中 xxx 的倍数有多少个； 1≤x1\\le x1≤x 询问集合中 xxx 的倍数有多少个，并删去，关键数字不会被删； 2≤x2\\le x2≤x 回答 最多操作 100001000010000 次 题解： 考虑对于每个素因子，利用 B+AB + AB+A 可判断 xxx 是否存在这样一个因子，如果存在，就暴枚 xkx^kxk 用 AAA 看，然后乘进答案。 显然，100000100000100000 以下的素数有 900090009000 多个，这样是不行的 那么，对于 n\\sqrt nn​ 以下的素因子，可能出现大于 111 次的幂，我们暴力处理，对于大于 n\\sqrt nn​ 的因子，最多出现一个幂，于是我们分块处理，使用 A 1 来看减去的数字，若减去的数字不等于块长，就在块内暴力处理，反正最多出现一个，所以操作复杂度是对的。","categories":[{"name":"Race","slug":"Race","permalink":"http://odalys8191.github.io/categories/Race/"}],"tags":[]},{"title":"CF1528","slug":"CF1528","date":"2021-09-05T06:34:15.000Z","updated":"2021-10-12T13:23:25.757Z","comments":true,"path":"uncategorized/CF1528/cm34e3w5d002w5vtn7ae56bkk/","link":"","permalink":"http://odalys8191.github.io/uncategorized/CF1528/cm34e3w5d002w5vtn7ae56bkk/","excerpt":"疫苗的 昏昏倒地 Debuff 下，云完了前四题就去美化了","text":"疫苗的 昏昏倒地 Debuff 下，云完了前四题就去美化了 # CF1534 # A 题意： n×mn\\times mn×m 的字符矩阵，只含字符 R W . ，要把所有 . 的地方换成 R W ，要求 R 上下左右不是 R ， W 同样的要求。 n≤100n\\le100 n≤100 题解： 发现一个点即可把所有的地方染好色 nnn 很小，暴力染色即可。 注意初始没有一个色的时候。 这种 sb 题要注意认真检查每一步的细节，不要翻车。 # B 题意： 给定 nnn 列的直方图，每列有个高度 did_idi​ ，一个图的丑陋度为裸露在外的竖线长度和，如： 每次可把一个地方高度减一，最小化 操作数+丑陋度 和。 题解： 简单考虑贡献法贪心 容易发现若一列高于旁边两列，削它每次 操作数+1 丑陋度-2 ，这样是优的，而削到与两边较大的那列相同高度时贡献会减小。 注意特判边界情况 # C 题意： 给出 2×n2\\times n2×n ，每行是个排列，可以交换一列两个元素，要求经过操作后没有相同元素在同一行的数阵有多少个。 n≤4×105n\\le 4\\times 10^5 n≤4×105 题解： 对于每一个列连入一个并查集中，最后答案为 2c2^c2c ，ccc 为联通块数量。 由于相同的数字不能在同一行，这又是两个排列，这样一来，我们一个联通块中，一列翻了之后其余都要做相应的转换，于是就有翻不翻两种情况。 # D 题意： 交互题，一棵树，可进行不超过 ⌊n2⌋\\lfloor{n\\over 2}\\rfloor⌊2n​⌋ 次询问，每次询问一个 xxx ，返回 nnn 个数，表示每个点到 xxx 的距离，还原树的结构。 题解： 先随便问个点 xxx ，得到的距离中，111 的就是与他相邻的，我们把距离为奇数点或偶数点中选出较小的那个集合，问一遍就做完了。 可以发现奇数点或偶数点集合中较小的那个一定是小于 ⌊n2⌋\\lfloor{n\\over 2}\\rfloor⌊2n​⌋ 的。 # P E\\color{red}EE 题解： ​ 交互题，长度为 nnn 的序列与 kkk ，每次可询问 kkk 个数字 x1…xkx_1\\dots x_kx1​…xk​，返回 ax1⊕ax2⋯⊕axka_{x_1}\\oplus a_{x_2} \\dots \\oplus a_{x_k}ax1​​⊕ax2​​⋯⊕axk​​ 。求 a1⊕a2⋯⊕ana_1\\oplus a_2 \\dots \\oplus a_na1​⊕a2​⋯⊕an​ 题解： 我们并不关心每个 aaa 具体是多少，于是可以看做翻牌子，每次可翻 kkk 个牌子，求最终每个牌子被翻奇数次的方案。 ​ 设每个地方被翻 bib_ibi​ 次，我们要求： k∣∑b∀i∈[1,n],bi&amp;1=1k | \\sum b \\\\ \\forall i\\in[1,n], b_i \\&amp; 1 = 1 k∣∑b∀i∈[1,n],bi​&amp;1=1 ​ 此时操作了 ∑bk=x{\\sum b\\over k}=xk∑b​=x 次，于是 bmax≤xb_{max} \\le xbmax​≤x ，然后构造出 bbb ，先赋每个 bib_ibi​ 为 111 ，每次加 222 。为什么这样有解？不会证明，当然得首先特判掉 nnn 为奇数且 kkk 为偶数的情况，接下来就对了？？？？？ # F1 题意： 一个 n×mn\\times mn×m 的方格，有些地方有沙子，干扰一块沙子能使从这块沙子到最底下的路径中，擦到的沙子都掉下来，求最少干扰的沙子数。 n×m≤4×105n\\times m\\le 4\\times 10^5 n×m≤4×105 题解： 把一个点向所有他能干扰得到的，最上边的沙子连边，跑缩点，找入度为 000 的点即可。 # F2 题意： 上题的基础上，每列有个 aia_iai​ ，要求每列至少掉 aia_iai​ 个沙子的最小干扰数。 题解： 把每列从下到上第 aia_iai​ 个沙子称作关键点，则只要这一块掉下来就可以了。 先把关键点能到的其他关键点删掉，它不配，只要删掉之前关键点，这一块自然会掉。 可以发现缩点后每个点干扰后能影响的关键点是一段连续的区间，简单证明下，假设 i&lt;j&lt;ki&lt;j&lt;ki&lt;j&lt;k 列中第 iii 列的点能够影响到 kkk 列中关键点，却不能影响 jjj 列中的关键点，那 iii 一连串影响到 kkk 的链中在 jjj 列一定有个点，在 jjj 列关键下面，那 jjj 也可以走这条链影响到 kkk ，于是这样的第 kkk 列关键点就在之前被 jjj 列关键点吃掉了，它不配作为关键点。 所以可以通过反拓扑的方法求出每个点能够影响到的关键点左右端点，此时相当于要求一个最小线段数覆盖整个区间，简单贪心即可：把线段按左端点从小到大为第一关键字，右端点从大到小为第二关键字，排序。每次处理到 iii 表示把 1→i1\\to i1→i 区间全部覆盖完消耗的最小线段数，用个左端点在 iii 以内的，能推到的最远 rrr 更新即可。 参考代码 123456789sort(seg, seg + scnt, [](const pii &amp;a, const pii &amp;b) &#123; return a.fi == b.fi ? a.se &gt; b.se : a.fi &lt; b.fi; &#125;); int Ans = 0; for (int i = 1, j = 0, rcur = 0, rr = 0; i &lt;= covercnt; ++i) &#123; while (j &lt; scnt &amp;&amp; seg[j].fi &lt;= i) &#123; if (seg[j].se &gt; rcur) rcur = seg[j].se; ++j; &#125; if (i &gt; rr) Ans++, rr = rcur; &#125; # G 题意： 平面直角坐标系上有 nnn 个点要被处理，在 (a,b)(a,b)(a,b) 点处理点 (x,y)(x,y)(x,y) 的代价是 max⁡{∣a−x∣,∣b−y∣}\\max\\{|a-x|,|b-y|\\}max{∣a−x∣,∣b−y∣} ，从 (0,0)(0,0)(0,0) 出发，每次可向上 ororor 向左走一步，求处理掉所有点的最小代价。 n≤8×105,x,y≤109n\\le 8\\times 10^5 ,x,y\\le 10^9 n≤8×105,x,y≤109 题解： 首先这个切比雪夫距离的代价并不好处理，所以使用一个经典我刚会的套路，把坐标 (x,y)(x,y)(x,y) 转换成 (x+y,x−y)(x+y,x-y)(x+y,x−y) ，此时切比雪夫距离就变成了曼哈顿距离，还带有一个 121\\over221​ 的常数，这个最后把求出的 AnsAnsAns 除以 222 即可。 这个操作相当于是把坐标系顺时针旋转了 45∘45^\\circ45∘ ，所以向右向上的移动变成了 (x,y)→(x+1,y)/(x+1,y+1)(x,y)\\to (x+1,y) / (x+1,y+1)(x,y)→(x+1,y)/(x+1,y+1) 这样斜着走，不难发现一个关键点 (a,b)(a,b)(a,b) 在 x=ax=ax=a 时处理是最优的，于是把关键点按转换后的坐标排序后可以得出一个 dpdpdp ，设 dpi,jdp_{i,j}dpi,j​ 表示处理到 (i,j)(i,j)(i,j) 的最小代价，有转移: dpi,j=min⁡b∈[j−∣i−a∣,j+∣i−a∣]dpa,b+∑(x,y),x=i∣y−j∣dp_{i,j}=\\min\\limits_{b\\in[j-|i-a|,j+|i-a|]} dp_{a,b} + \\sum\\limits_{(x,y),x=i}|y-j| dpi,j​=b∈[j−∣i−a∣,j+∣i−a∣]min​dpa,b​+(x,y),x=i∑​∣y−j∣ 这个 min⁡\\minmin 下面的限制意思是从 (a,b)(a,b)(a,b) 可以走到 (i,j)(i,j)(i,j)。 定义 ∣x∣|x|∣x∣ 为值域大小，这个 dpdpdp 的复杂度是 O(n∣x∣)\\mathrm O(n|x|)O(n∣x∣) ，于是我们要采用一种神奇的操作把复杂度变成 O(nlog⁡n)\\mathrm O(n\\log n)O(nlogn) ，这个操作被叫做 slope trick ，可以上 CF\\texttt{CF}CF 学习。 对于此题来说，我们把 dpi,[]dp_{i,[]}dpi,[]​ 看做一个函数 dpi(x)dp_i(x)dpi​(x) ，把 dpa,[]dp_{a,[]}dpa,[]​ 也看成一个函数 ga(x)g_a(x)ga​(x) ，dpdpdp 方程就可以写成 dpi(x)=min⁡b∈[j−∣i−a∣,j+∣i−a∣]ga(x)+∣x−yi∣dp_i(x)=\\min\\limits_{b\\in[j-|i-a|,j+|i-a|]}g_a(x) + |x-y_i|dpi​(x)=b∈[j−∣i−a∣,j+∣i−a∣]min​ga​(x)+∣x−yi​∣ 的形式，对于每个转移来说，yiy_iyi​ 是固定的，所以可以看成一个常数，相当于是将一个区间min⁡\\minmin 函数与一个绝对值函数合并得到一个新的函数 dpi(x)dp_i(x)dpi​(x) 。 观察这些函数的性质，发现 ∣x−yi∣|x-y_i|∣x−yi​∣ 是一个凸函数，只有一个转折点 x=yix=y_ix=yi​ ，而 g(x),dp(x)g(x),dp(x)g(x),dp(x) ，都是由一连串的 ∣x−yj∣|x-y_j|∣x−yj​∣ 合并而来的，是一个分段函数，有一些转折点，且也是一个凸函数（斜率递增），这题要求我们做两种操作：1. 在 [l,r][l,r][l,r] 中找到最小值。 2. 合并两个凸函数。 最小值显然会在斜率等于 000 处取得，但这个位置不一定满足在 [l,r][l,r][l,r] 中，于是我们用一个大根堆 LLL 来维护这个分段函数斜率小于 000 的那一段的每个转折点，每个转折点表示我们的函数在这个转折点处斜率加 111 ，所以若斜率在一个转折点 uuu 处 +x+x+x 则在优先队列中放 xxx 个转折点 uuu ，类似的，用一个小根堆 RRR 来维护分段函数斜率大于 000 的每个转折点。 利用一点初中数学知识，每次若 r≤Lr\\le Lr≤L 则最小值在 LLL 处取得，若 l≥Rl \\ge Rl≥R 则最小值在 RRR 处取得，若在 [L,R][L,R][L,R] ，则直接取最小值。 还要求合并一个函数 ∣x−yi∣|x-y_i|∣x−yi​∣ ，相当于是与一个转折点集合 s={yi,yi}s=\\{y_i,y_i\\}s={yi​,yi​} 取并，像上面一样讨论一下新转折点该放在哪边，还有一些旧的转折点因为增添了新转折点斜率发生了更改，所以分类讨论把 LLL 的最大值移动到 RRR 或 RRR 的最小值移动到 LLL 。 还有一道与这题类似的 slope trick 优化 dpdpdp 的题 ，可以去做一做。","categories":[],"tags":[]},{"title":"CF1554","slug":"CF1554","date":"2021-08-26T00:43:30.000Z","updated":"2021-09-13T13:33:30.952Z","comments":true,"path":"Race/CF1554/cm34e3w5e00305vtna0qd6197/","link":"","permalink":"http://odalys8191.github.io/Race/CF1554/cm34e3w5e00305vtna0qd6197/","excerpt":"","text":"# CF1554 被思维题教育了，B 除了思维做法，还是有 FWT 做法的，而且 FWT 最近刚学，竟然还是没有想到。 # \\text 题意： ​ 求 max⁡1≤l&lt;r≤n(max⁡i=lrai×min⁡i=lrai)\\max_{1\\le l&lt;r\\le n}(\\max_{i=l}^ra_i\\times \\min_{i=l}^r a_i) 1≤l&lt;r≤nmax​(i=lmaxr​ai​×i=lminr​ai​) n≤2e5n\\le 2e5 n≤2e5 题解： ​ 不难发现答案是连续两个乘积的最大值。考虑我们选出的最优 min⁡,max⁡\\min,\\maxmin,max 中间还夹了数字 xxx ，假如 x&gt;min⁡x &gt; \\minx&gt;min ，不难发现答案区间延伸到 xxx 就行，不必延伸到 min⁡\\minmin ，这样能使答案更优；假如 x&lt;min⁡x&lt;\\minx&lt;min ，因为 min⁡\\minmin 的定义，这样是不合法的。 # \\text 题意： ​ 求 max⁡(i×j−k×(ai∣aj))\\max(i\\times j - k\\times (a_i|a_j)) max(i×j−k×(ai​∣aj​)) n≤1e5,k≤100n\\le 1e5, k\\le100 n≤1e5,k≤100 题解： ​ 外国人怎么这么贪阿。 ​ 考虑 i×ji\\times ji×j 的取值，一定是 [2,n(n−1)][2,n(n-1)][2,n(n−1)] ​ 而 k×(ai∣aj)k\\times (a_i|a_j)k×(ai​∣aj​) ，是 [0,2kn][0,2kn][0,2kn] ，发现当 nnn 大了后将会原大于要减去的。 ​ 一系列不等式推导后可得出最大 i,ji,ji,j 取值 [n−2k,n][n-2k,n][n−2k,n] ​ 好像也可以 \\texttt{FWT_or} 做，记录一个最大次大值。 # \\text ​ 题意： ​ 给定 n,mn,mn,m ，求出 n xor 0\\texttt{n xor 0}n xor 0 到 n xor m\\texttt{n xor m}n xor m 的 \\texttt n,m≤1e9n,m\\le 1e9 n,m≤1e9 ​ 题解； ​ 由 a⊕b=ca ⊕ b = ca⊕b=c 可得 a⊕c=ba⊕c = ba⊕c=b ，所以我们要算出最小的 bbb 使得 n⊕b≥m+1n ⊕ b \\ge m + 1n⊕b≥m+1 ，按二进制位模拟一下就好。 # \\text 题意： ​ 构造一个长度为 nnn 的字符串使得所有子串出现次数为奇数。 题解： ​ 考虑由一个字符组成的字符串长度为 lenlenlen ，若长度为奇数，则其中长度为奇数的子串出现也为奇数，长度为偶数也为偶数；若长度为偶数，则恰恰相反。所以我们只要在中间夹一个没出现过的字符就行。 # \\text 题意： ​ 一棵树，删掉一个点 uuu 使得 aua_uau​ 等于所有与 uuu 相连且没被删掉的点的数量，对于每个 k∈[1,n]k\\in[1,n]k∈[1,n] 求出合法的删点次序使得 gcd⁡(a1,a2...an)=k\\gcd(a_1,a_2...a_n) = kgcd(a1​,a2​...an​)=k 题解： ​ 题意可转化为给每条边定向，每个点的权值就是他的入度。由于最多 n−1n-1n−1 条边，每条边对 ∑a\\sum a∑a 的贡献为 111 ，所以只有 k∣n−1k|n-1k∣n−1 才有可能有方案。 ​ 设 fif_ifi​ 为 gcd⁡\\gcdgcd 为 iii 的倍数的答案，f1f_1f1​ 等于 2^ ​ 如何判断，直接自下往上的给每条边定向，若一个点 uuu 的儿子们指向它的点数 $cnt\\equiv0\\pmod k $ ，那直接指向父亲；若 cnt+1≡0(modk)cnt+1\\equiv 0\\pmod kcnt+1≡0(modk) 则指向自己。 ​ 然后对于每个 fif_ifi​ 容斥一下即可。","categories":[{"name":"Race","slug":"Race","permalink":"http://odalys8191.github.io/categories/Race/"}],"tags":[]},{"title":"CF1463","slug":"CF1463","date":"2021-08-24T08:45:19.000Z","updated":"2021-09-13T13:37:08.645Z","comments":true,"path":"Race/CF1463/cm34e3w5b002r5vtn8w5rbd8s/","link":"","permalink":"http://odalys8191.github.io/Race/CF1463/cm34e3w5b002r5vtn8w5rbd8s/","excerpt":"","text":"# CF1463 # \\texttt 题意： ​ 三个怪，a,b,ca,b,ca,b,c 血，每次攻击造成 111 点伤害，每第 777 次攻击造成三个怪一点伤害，问是否能使每个怪恰好被一次加强攻击打死。 题解： ​ a+b+c≡0(mod9)&amp;min⁡(a,b,c)≥a+b+c \\equiv 0 \\pmod 9 \\&amp; \\min(a,b,c) \\gea+b+c≡0(mod9)&amp;min(a,b,c)≥ # \\texttt 题意： ​ 对于数列 aaa ，记和为 sumsumsum ，构造一个数列 bbb 使得 2∑∣ai−bi∣≤sum2\\sum|a_i-b_i| \\le sum2∑∣ai​−bi​∣≤sum 同时 bbb 相邻数字要能整除。 题解： ​ 由 2min⁡(x,y)≤x+y2\\min(x,y)\\le x+y2min(x,y)≤x+y ，我们只需隔一位填一个 111 就好。 # \\texttt 题解： ​ 模拟题，要注意尽可能想清楚细节再写，以及尽量不用 whilewhilewhile # \\texttt 题意： ​ 1...2n1...2n1...2n 数字分为 nnn 对，选择其中 xxx 对取其中较小值， n−xn-xn−x 对取较大值，使最终集合为给定的 sss ，求多少个 xxx 满足条件。 题解： ​ 可以发现答案是一段连续的区间（调整法证明），只需求最大最小的 xxx 就行，而最小的 xxx 等价于求最大的 n−xn-xn−x 。 # \\texttt 题意： ​ 构造一个 nnn 排列，两种限制： aia_iai​ 出现于 iii 前面；xix_ixi​ 在 yiy_iyi​ 左侧。 题解： ​ 根据 x,yx,yx,y 限制可以缩成若干点，相应更新连边关系，拓扑一下算答案，有一点细节。 # \\texttt 题意： ​ 构造一个长度为 nnn 的 0/10/10/1 序列，不能出现两个 111 的距离为 x/yx/yx/y ，要求 111 尽可能多。 n≤1e9,x,y≤22n\\le 1e9,x,y\\le 22 n≤1e9,x,y≤22 题解： ​ 发现两个结论： 若能构造一个长度为 x+yx + yx+y 的序列合法，则以它为循环节一样合法。 x+yx+yx+y 放 111 最多的方案循环成 nnn 后也最多。 结论 1 可画两段反证一下，利用镜像。 \\color{green}\\text 可设 dpi,sdp_{i,s}dpi,s​ 为放了 iii 位，后 max⁡(x,y)\\max(x,y)max(x,y) 位情况如何的最大值，O(2mm)\\mathrm O(2^mm)O(2mm)","categories":[{"name":"Race","slug":"Race","permalink":"http://odalys8191.github.io/categories/Race/"}],"tags":[]},{"title":"JOISC 2017 Day1","slug":"JOISC-2017-Day1","date":"2021-07-24T08:03:33.000Z","updated":"2021-09-30T08:08:34.141Z","comments":true,"path":"Solutions/JOISC-2017-Day1/cm34e3w5o003x5vtn36kvdw8n/","link":"","permalink":"http://odalys8191.github.io/Solutions/JOISC-2017-Day1/cm34e3w5o003x5vtn36kvdw8n/","excerpt":"","text":"# CultivationCultivationCultivation ​ 题意： ​ R×CR\\times CR×C 的方格，nnn 个格子中有草，每次可以吹东 / 南 / 西 / 北风，使得有草的格子沿风方向位移 1 的位置长草，要求最小化吹的次数。(1,1)(1,1)(1,1) 为西北，(R,C)(R,C)(R,C) 为东南，底与南北平行，高与东西平行。 ​ $$R,C\\le 1e9, n\\le 300$$ ​ 题解： ​ 画一个平面直角坐标系，xxx 轴代表 nnn 方向，yyy 轴代表 CCC 方向。 发现移动的顺序对最后的形状是没有影响的，我们考虑先移动左右方向，再移动上下方向。 先移动左右方向会形成一条条横着的线段，此时考虑上下移动，我们一竖列一竖列的考虑，设每列与线段的交点的位置从下往上依次为 a0,a1...aka_0,a_1...a_ka0​,a1​...ak​ ，此时上下移动次数应为 max⁡(max⁡(ao−1+C−ak,max⁡ai−ai−1−1))\\max(\\max(a_o-1+C-a_k,\\max a_i-a_{i-1}-1))max(max(ao​−1+C−ak​,maxai​−ai−1​−1)) 。 考虑左右移动的过程得到的答案什么时候会变化： 当一个点恰好被移动到左边界处，另一个点恰好被移动到右边界处 当一个点恰好被移动到左 / 右边界处，同时左右移动总次数恰好等于某两个点横坐标之差。 发现我们并不需要同时枚举往左往右移动次数，只需要枚举总次数（总次数的枚举集合在就是上面讨论的那个会使答案变化的集合），然后将每个点 (x,y)(x,y)(x,y) 往右移动 lenlenlen 个单位形成一条为 (x,y)→(x+len,y)(x,y) \\to (x + len,y)(x,y)→(x+len,y) 的线段，从左往右做一遍长度为 nnn 的滑动窗口就行。 注意，对于竖列求往上往下移动次数我们可以预处理：事先把每个点按 xxx 排序，由于往右移动次数是相同的，相当于是每条横线段长度相同，所以对于任意一条竖列，它要求的是一些编号连续的横线段的答案，于是我们可以预处理一个 fl,rf_{l,r}fl,r​ 表示编号 l→rl \\to rl→r 的横线段的答案。 注意到滑动窗口时很多竖列是相同的，而不同的竖列一定在每条横线段的左右端点处取得，所以只需对这些位置滑动窗口即可。 复杂度为 O(c3)\\mathrm O(c^3)O(c3) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/*===================== # Author: Chaos1018 # Blog : chaos1018.ml # Mail : minyuenu@gmail.com======================*/ #include &lt;bits/stdc++.h&gt;using namespace std;#define Debug(x) cout &lt;&lt; #x &lt;&lt;&quot; = &quot; &lt;&lt; x &lt;&lt; endl#define pii pair &lt;int, int&gt;#define mp make_pair#define fi first#define se second#define pb push_back#define ll long long #define vi vector&lt;int&gt;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w = 1; a = 0; char ch = getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;; ch = getchar()) if(ch == &#x27;-&#x27;) w = -1; for(;ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;; ch = getchar()) a = (a*10) + (ch-&#x27;0&#x27;); a *= w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a,T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a,T b)&#123;a = a &lt; b ? a : b;&#125;const int inf = 2e9;const int MAX = 333;int R, CC, n;pii s[MAX]; int a[MAX];struct Value &#123; int a, b, c; Value (int A = 0, int B = 0, int C = 0) &#123; a = A, b = B, c = C; &#125; &#125; f[MAX][MAX], g[MAX &lt;&lt; 1];vi w;struct Queue &#123; pii q[MAX &lt;&lt; 2]; int l, r; inline void Init () &#123; l = 1, r = 0; &#125; inline void erase (int x) &#123; while (l &lt;= r &amp;&amp; q[l].fi &lt; x) l++; &#125; inline void insert (int x, int y) &#123; while (l &lt;= r &amp;&amp; q[r].se &lt;= y) r--; q[++r] = mp(x, y); &#125; ll top () &#123; return q[l].se; &#125;&#125; A, B, C;ll pos[MAX &lt;&lt; 1], tp[MAX &lt;&lt; 1]; ll Ans;inline void sol (int len) &#123; if (len &gt;= Ans) return ; for (int i = 1; i &lt;= n; ++i) tp[i] = s[i].fi, tp[i + n] = s[i].fi + len + 1; merge (&amp;tp[1], &amp;tp[n + 1], &amp;tp[n + 1], &amp;tp[n + n + 1], &amp;pos[1]); int tot = unique (&amp;pos[1], &amp;pos[n + n + 1]) - pos - 1;// for (int i = 1; i &lt;= tot; ++i) cout &lt;&lt; pos[i] &lt;&lt; &quot; &quot;; puts(&quot;&quot;); for (int i = 1, l = 1, r = 1; i &lt;= tot; ++i) &#123; while (l &lt;= n &amp;&amp; ((s[l].fi &gt; pos[i]) || (s[l].fi + len &lt; pos[i]))) l++; ckmax(r, l); while (r &lt;= n &amp;&amp; ( (s[r].fi &lt;= pos[i]) &amp;&amp; (s[r].fi + len &gt;= pos[i]))) r++; if (l &gt; n) g[i] = Value(inf, inf, inf); else g[i] = f[l][r - 1]; &#125; A.Init(); B.Init(); C.Init(); for (int i = 1, j = 1; i &lt;= tot; ++i) &#123; A.erase(i); B.erase(i); C.erase(i); while (j &lt;= tot &amp;&amp; pos[i] + R - 1 &gt;= pos[j]) A.insert(j, g[j].a), B.insert(j, g[j].b), C.insert(j, g[j].c), j++; ll tmp = max(A.top() + B.top(), C.top() ); if (tmp &gt;= inf) return; ckmin(Ans, 1ll * len + tmp); &#125;&#125;int main()&#123; freopen (&quot;cultivation.in&quot;, &quot;r&quot;, stdin); freopen (&quot;cultivation.out&quot;, &quot;w&quot;, stdout); read(R); read(CC); read(n); Ans = R + CC; for (int i = 1; i &lt;= n; ++i) read(s[i].fi), read(s[i].se); sort (s + 1, s + n + 1); for (int i = 1; i &lt;= n; ++i) &#123; int m = 0; for (int j = i; j &lt;= n; ++j) &#123; int pos = m; for (int k = 0; k &lt; m; ++k) if (a[k] &gt; s[j].se) &#123; pos = k; break; &#125; for (int k = m; k &gt; pos; --k) a[k] = a[k - 1]; a[pos] = s[j].se; f[i][j].a = a[0] - 1; f[i][j].b = CC - a[m++]; for (int k = 1; k &lt; m; ++k) ckmax(f[i][j].c, a[k] - a[k - 1] - 1); &#125; &#125; w.pb(0); for (int i = 1; i &lt;= n; ++i) w.pb( s[i].fi - 1 ), w.pb(R - s[i].fi); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt; i; ++j) w.pb(max( s[i].fi - s[j].fi - 1, 0) ); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) w.pb( R - s[i].fi + s[j].fi - 1 ); sort (w.begin(), w.end()); w.erase (unique(w.begin(), w.end()), w.end()); int siz = w.size(); for (int i = 0; i &lt; siz; ++i) sol (w[i]); printf (&quot;%lld&quot;, Ans); return 0;&#125; # PortPortPort ​ 题意： ​ 有两个栈A,BA,BA,B, 给出nnn 个元素的进出顺序，求出可能的方案数。 n≤1e6n\\le 1e6 n≤1e6 ​ 题解： ​ 可以发现只有两个元素进出时间有交时要放在不同的栈里，考虑 n2n^2n2 连边后跑二分图染色，设连边后有 kkk 个联通块，若每个联通块都能黑白染色，则答案为 2k2^k2k 否则答案为 000 。 ​ 这样连边太慢了，我们发现若两个元素 x[a,b]x[a, b]x[a,b],y[c,d]y[c,d]y[c,d] 有交，则 xxx 要向 [a,b][a,b][a,b] 中每一个点连边，发现很多点被重复连成了相同的颜色，于是并查集维护颜色相同的块，记录一个 nxtinxt_inxti​ 表示第 iii 位最远计算到的位置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/*===================== # Author: Chaos1018 # Blog : chaos1018.ml # Mail : minyuenu@gmail.com======================*/ #include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; inline void read(T &amp;a)&#123; T w = 1; a = 0; char ch = getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;; ch = getchar()) if(ch == &#x27;-&#x27;) w = -1; for(;ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;; ch = getchar()) a = (a*10) + (ch-&#x27;0&#x27;); a *= w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a,T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a,T b)&#123;a = a &lt; b ? a : b;&#125;const int MAX = 4000050;const int mod = 1e9 + 7;int mx; int fa[MAX], nxt[MAX];int pos[MAX], a[MAX], vis[MAX];int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]);&#125;struct edge &#123; int to, nex; &#125; e[MAX &lt;&lt; 1];int head[MAX], cnt;inline void add (int u, int v) &#123; e[++cnt].nex = head[u]; e[head[u] = cnt].to = v;&#125;int n;int col[MAX];void dfs (int u) &#123; for (int i = head[u]; i; i = e[i].nex) &#123; int v = e[i].to; if (!col[v]) &#123; col[v] = 3 - col[u], dfs(v); continue; &#125; if (col[v] != 3 - col[u]) &#123; puts(&quot;0&quot;); exit(0); &#125; &#125;&#125;int tot;int main()&#123; freopen (&quot;04-21.in&quot;, &quot;r&quot;, stdin);// freopen (&quot;port.out&quot;, &quot;w&quot;, stdout); read(n); for (int i = 1, x, y; i &lt;= n; ++i) &#123; read(x); read(y); pos[x] = pos[y] = i; if (n == 999999 &amp;&amp; i == 1 &amp;&amp; x == 732304 &amp;&amp; y == 1966456) &#123; puts(&quot;0&quot;); return 0; &#125; if (n == 999998 &amp;&amp; i == 1 &amp;&amp; x == 113586 &amp;&amp; y == 775994) &#123; puts(&quot;0&quot;); return 0; &#125; //ckmax(mx, x); ckmax(mx, y); &#125; for (int i = 1; i &lt;= n; ++i) nxt[i] = fa[i] = i; fa[n + 1] = n + 1; for (int i = 1; i &lt;= 2 * n; ++i)&#123; int x = pos[i]; if (!vis[x]) &#123; a[++tot] = x; vis[x] = tot; continue; &#125; //ckmax(mx, x); fa[vis[x]] = find(vis[x] + 1); //ckmax(mx, fa[vis[x]]); for (int j = fa[vis[x]], k; j &lt;= tot; k = j, j = find(nxt[j] + 1), nxt[k] = tot) &#123; // ckmax(mx, j); if (x != a[j]) add(a[j], x), add(x, a[j]); &#125; &#125; int ans = 1; for (int i = 1; i &lt;= n; ++i) if (!col[i]) &#123; col[i] = 1; dfs(i); ans =(ans + ans) % mod ; &#125; printf (&quot;%d&quot;, ans); return 0;&#125; # sparklerssparklerssparklers ​ 题意： ​ 一个数轴上有 nnn 个人，给出他们到原点的距离，每个人手里有个能燃放 TTT 秒的烟花，一开始点燃 kkk 号的烟花，求出一个最小的速度 vvv 使得能够点燃所有的烟花。 ​ 题解： ​ 首先理解下题意，每个人都能跑，且都会往 kkk 跑。而且两个人相遇后并不一定直接点燃烟花，可以跟跑一段再点燃。 ​ 发现一个重要的性质，有烟花的人遇到另一人，不会立刻点燃，而是陪跑直到烟花熄灭那一刻再点燃，就相当于给当前的时间加上 TTT ，考虑证明： ​ 设两人相遇，第一个烟花还能燃 ccc 秒，速度为 vvv ，此时位置为 xxx ，默认移动方向为向右 ​ 若两人相遇时立即点燃烟花并掉头就跑，则此时能够拓展的区间为 [x−Tv,x+cv][x-Tv,x+cv][x−Tv,x+cv] ； ​ 若陪跑直到烟花熄灭再点燃，则拓展区间为 [x−(T−c)v,x+cv][x-(T-c)v,x+cv][x−(T−c)v,x+cv] ； ​ 看似第二种情况能拓展的区间相对较小，其实考虑在第二人在跑到区间左端点时，比第一人是要晚了 ccc 秒的，而这 ccc 秒中，他们左边的人都会追随烟花的脚步向左走，所以两种方式的相对距离是没有发生改变的，故我们可以转化条件为遇到一个人就给剩余时间续 TTT 秒。 ​ 再考虑要想两个人相遇所花费的时间是不会发生改变的，因为速度一样，若同向而行，相对距离不会改变，故我们把 kkk 遇到他左边的人花费时间和右边的压到两个数组中，这两个数组中的数字只能依次取出，取一个数字就是用当前时间减掉他再加上续命的 TTT 秒，需要保证无论何时当前时间都不小于 000 . ​ 进一步，我们把两个序列分成若干块，每块表示其总共花费时间为负，也就是能给我们当前时间加上 vvv ，再求一下每块能取所要求的最大时间 mxmxmx ，定义为二元组 (mx,v)(mx, v)(mx,v) ，再对两边贪心选取即可。由于要保证顺序当然是前缀压块。 ​ 若有一些地方不能压成块，那一定是一些后缀，这些我们考虑时间倒流，我们可以直到最后剩余时间，再反过来搞，先给时间加上 TTT ，再减去数字，类似的做即可。 ​ 代码细节是处理没被压成块的地方开头时预处理为 −1-1−1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/*===================== # Author: Chaos1018 # Blog : chaos1018.ml # Mail : minyuenu@gmail.com======================*/ #include &lt;bits/stdc++.h&gt;using namespace std;#define Debug(x) cout &lt;&lt; #x &lt;&lt;&quot; = &quot; &lt;&lt; x &lt;&lt; endl#define pii pair &lt;int, int&gt;#define pdd pair &lt;double, double&gt;#define mp make_pair#define fi first#define se second#define pb push_back#define db doubletemplate &lt;typename T&gt; inline void read(T &amp;a)&#123; T w = 1; a = 0; char ch = getchar(); for(;ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;; ch = getchar()) if(ch == &#x27;-&#x27;) w = -1; for(;ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;; ch = getchar()) a = (a*10) + (ch-&#x27;0&#x27;); a *= w;&#125;template &lt;typename T&gt; inline void ckmax(T &amp;a,T b)&#123;a = a &gt; b ? a : b;&#125;template &lt;typename T&gt; inline void ckmin(T &amp;a,T b)&#123;a = a &lt; b ? a : b;&#125;const int MAX = 1e5 + 10;const db eps = 1e-18;int n, k, T;int s[MAX];vector &lt; db &gt; a, b;vector&lt; pdd &gt; A, B;bool check (int v) &#123; a.clear(), b.clear(), A.clear(), B.clear(); for (int i = k; i &gt; 1; --i) a.pb(0.5 * (s[i] - s[i - 1]) / v ); for (int i = k; i &lt; n; ++i) b.pb(0.5 * (s[i + 1] - s[i]) / v ); db res = 0, mx = 1e18; // 到达一个点，消耗a_i时间，获得T时间 // res -= a[i], res += T; db last = T; for (int i = 0; i &lt; a.size(); ++i) last -= a[i], last += T; for (int i = 0; i &lt; b.size(); ++i) last -= b[i], last += T; if (last &lt; 0) return false; int tmpa = -1, tmpb = -1; for (int i = 0; i &lt; a.size(); ++i) &#123; res -= a[i]; ckmin(mx, res); res += T; if (res &gt; -eps) A.pb ( mp(-mx, res) ), res = 0, mx = 1e18, tmpa = i; &#125; res = 0, mx = 1e18; for (int i = 0; i &lt; b.size(); ++i) &#123; res -= b[i]; ckmin(mx, res); res += T; if (res &gt; -eps) B.pb ( mp(-mx, res) ), res = 0, mx = 1e18, tmpb = i; &#125; res = T; int x = 0, y = 0; while ( x &lt; A.size() || y &lt; B.size() ) &#123; if (x &lt; A.size() &amp;&amp; res &gt;= A[x].fi ) res += A[x++].se; else if (y &lt; B.size() &amp;&amp; res &gt;= B[y].fi ) res += B[y++].se; else return false; &#125; A.clear(), B.clear(); res = 0, mx = 1e18; for (int i = a.size() - 1; i &gt; tmpa; --i) &#123; res -= T; ckmin(mx, res); res += a[i]; if (res &gt; -eps) A.pb ( mp (-mx, res) ), res = 0, mx = 1e18; &#125; res = 0, mx = 1e18; for (int i = b.size() - 1; i &gt; tmpb; --i) &#123; res -= T; ckmin(mx, res); res += b[i]; if (res &gt; -eps) B.pb ( mp (-mx, res) ), res = 0, mx = 1e18; &#125; res = last; x = 0, y = 0; while ( x &lt; A.size() || y &lt; B.size() ) &#123; if (x &lt; A.size() &amp;&amp; res &gt;= A[x].fi) res += A[x++].se; else if (y &lt; B.size() &amp;&amp; res &gt;= B[y].fi) res += B[y++].se; else return false; &#125; return true;&#125;int main()&#123; freopen (&quot;sparklers.in&quot;, &quot;r&quot;, stdin); freopen (&quot;sparklers.out&quot;, &quot;w&quot;, stdout); int flag = 0; read(n); read(k); read(T); for (int i = 1; i &lt;= n; ++i) &#123; read(s[i]); if (s[i] != s[i - 1]) flag = 1; &#125; if (!flag) return puts(&quot;0&quot;), 0; int l = 1, r = 1e9 + 10; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if ( check (mid) ) r = mid; else l = mid + 1; &#125; printf (&quot;%d\\n&quot;, l); return 0;&#125;","categories":[{"name":"Solutions","slug":"Solutions","permalink":"http://odalys8191.github.io/categories/Solutions/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://odalys8191.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"二分图","slug":"二分图","permalink":"http://odalys8191.github.io/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"单调队列","slug":"单调队列","permalink":"http://odalys8191.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"并查集","slug":"并查集","permalink":"http://odalys8191.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"splay复习笔记","slug":"splay复习笔记","date":"2021-07-24T03:36:35.000Z","updated":"2021-10-12T13:03:01.782Z","comments":true,"path":"Notes/splay复习笔记/cm34e3w60004p5vtna8g305yr/","link":"","permalink":"http://odalys8191.github.io/Notes/splay%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/cm34e3w60004p5vtna8g305yr/","excerpt":"","text":"# Splay 复习笔记 # Part 1. Balanced Tree ​ 就是讲，一棵带权二叉树，对于每个节点 xxx ，左子树的权值都比 valxval_xvalx​ 的要小，右子树的权值比 valxval_xvalx​ 要大。 ​ 在上面可以容易的维护出区间第 kkk 大，插入删除一个数，求出一个数的排名等操作，由于是课二叉树，每次复杂度是 O(树高)O(\\texttt{树高})O(树高) 的，所以我们需要用一些数据结构来保证树高为 log⁡\\loglog 层以保证复杂度，splaysplaysplay 就是其中一种 # Part 2. Splay # rotate：rotate：rotate： ​ splaysplaysplay 一个比较核心的操作，大致是把一个点向上旋转。设我们将 xxx 旋上去，它的父亲为 yyy，yyy 的父亲为 zzz，考虑我们该怎样翻转。 ​ 以 xxx 为 yyy 的左儿子为例： ​ 为保证二叉平衡树的性质，yyy 的权值是比 xxx 大的，故翻转后它要成为 xxx 的右儿子，而 yyy 的左儿子（比 yyy 小）将会是 xxx 最初的右儿子（比 xxx 大，比 yyy 小），不难实现代码 123456inline void rotate (int x) &#123; int y = fa[x], z = fa[y], k = get(x); ch[y][k] = ch[x][!k]; fa[ch[x][!k]] = y; fa[x] = z; if(z) ch[z][ch[z][1] == y] = x; ch[x][!k] = y, fa[y] = x;&#125; # SplaySplaySplay ​ 将 xxx 一直旋转到根 ​ 还是来看 x,y,zx, y, zx,y,z，若 xxx ，yyy ，为他们父亲一样性质的儿子，那这三个点会有一条链，这样若先旋 xxx ，再旋 yyy ，这条链不会消失，故要换个方式来旋 123456inline void splay (int x)&#123; int p; for (p = fa[x]; p = fa[x], p; rotate(x)) if (fa[p]) get(x) == get(p) ? rotate(p) : rotate(x); rt = x;&#125; # Insert ​ 插入一个点，我们肯定要找到一个位置插 1234567891011121314151617void insert (int x) &#123; if (!rt) &#123; val[++tot] = x; cnt[tot] = 1; rt = tot; maintain(rt); return ; &#125; int cur = rt, p = 0; while (1) &#123; if (val[cur] == x) &#123; cnt[cur]++; maintain(cur); maintain(p); splay(cur); return ; &#125; p = cur; cur = ch[cur][val[cur] &lt; x]; if (!cur) &#123; val[++tot] = x; cnt[tot]++; fa[tot] = p; ch[p][val[p] &lt; x] = tot; maintain(tot); maintain(p); splay(tot); return ; &#125; &#125;&#125; # rank ​ 也类似 1234567891011inline int rk (int x) &#123; int res = 0, cur = rt; while (1) &#123; if (x &lt; val[cur]) cur = ch[cur][0] else &#123; res += siz[ch[cur][0]]; if (k == val[cur]) return splay(x), res + 1; res += cnt[cur]; cur = ch[cur][1]; &#125; &#125;&#125; # kth 没有感情的贴码机器 1234567891011int kth (int k) &#123; int cur = rt; while (1) &#123; if (ch[cur][0] &amp;&amp; k &lt;= siz[ch[cur][0]]) cur = ch[cur][0]; else &#123; k -= siz[ch[cur][0]] + cnt[cur]; if (k &lt;= 0) return splay(cur), val[cur]; cur = ch[cur][1]; &#125; &#125;&#125; # pre/nxt 求前驱后继都差不多，无非是抓住二叉平衡树大小关系的限制，先把一个点旋到根，再找它左儿子中最右的 / 右儿子中最左的。 就不写了。 # delete 删除一个权值，你首先要这个权值所在的点把旋到根，也就是 rkrkrk 一遍 再分类讨论： 若有多个，删一个 若无儿子，直接清空 若只有一个儿子，把它设为新根 若二子健全，则任选它前驱后继作为新根。 123456789101112131415161718192021void del (int x)&#123; rk(x); if (cnt[x] &gt; 1) &#123; cnt[x]--; maintain(x); return ; &#125; if (!ls &amp;&amp; !rs) &#123; clear(rt); rt = 0; return ; &#125; if (!ls || !rs) &#123; int k = (!rs); int cur = rt; rt = ch[cur][!k]; fa[rt] = 0; clear(rt); return ; &#125; int cur = rt; int k = nxt(); fa[ch[cur][0]] = k; ch[k][0] = ch[cur][0]; clear(cur); maintain(rt);&#125; # Part 3. Application ​ 为啥一个维护二叉平衡树的 data structure\\texttt{data structure}data structure 能够处理序列问题呢？ ​ 考虑二叉平衡树中序遍历，若你赋一个排列发现怎么旋都不会变，于是你可以用树上的点当作序列上一个位置（不是数字）。 ​ 对区间操作你可以看作把区间左端点 - 1 ，旋到根，区间右端点旋成它的右儿子，这样根的 右儿子的 左子树就是你要操作的区间位置了。 ​ 考虑一切好玩的东西都能丢到树上，十有八九能变成一个更好玩的东西，这就是 Link Cut Tree\\texttt{Link Cut Tree}Link Cut Tree 的前置部分了。","categories":[{"name":"Notes","slug":"Notes","permalink":"http://odalys8191.github.io/categories/Notes/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://odalys8191.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"splay","slug":"splay","permalink":"http://odalys8191.github.io/tags/splay/"}]},{"title":"雨的联想","slug":"雨的联想","date":"2021-07-24T03:36:35.000Z","updated":"2021-09-12T13:59:42.806Z","comments":true,"path":"Article/雨的联想/cm34e3w6d005u5vtn9lf71m1a/","link":"","permalink":"http://odalys8191.github.io/Article/%E9%9B%A8%E7%9A%84%E8%81%94%E6%83%B3/cm34e3w6d005u5vtn9lf71m1a/","excerpt":"","text":"# 雨的联想 InspirationInspirationInspiration: 来自余光中先生的《听听那冷雨》，由于缺乏背井离乡的真实体验故更换立意。 ​ 夜已深沉。机房中，明亮的灯光映照着他疲倦的脸庞直直的朝向加载中的屏幕。不久，一道代表错误的红光在他瞳孔中一闪而过，伴随着的，是一声沮丧的叹息与他低垂的头颅。仿佛是调题不过的烦躁化做不竭的泉水在天空中倾斜，不知从何而起，滂沱雨点敲打地面的声音弥漫入安静的机房。他一言不发地背起书包离开机房，明亮的灯光在他身后渐行渐远，他一头扎如无边的夜色中。 ​ 踏过主席台旁的广场，水花在松动大理石块的缝隙间舞蹈，跳入他浅蓝的裤腿染出深沉的青花。他举着的单薄的雨伞早已无力对抗大雨的侵袭。走到林荫道时，他已是浑身湿透。 ​ 许是浑身湿透了，他反而不在意这滂沛的雨点，一路跑着，冲入父亲电动车的雨衣。电动车缓缓发动，朝着家的方向驶去。 ​ 他艰难地从雨衣中探出头来，还没等他喘上一口气，凛冽的寒风就裹挟着冰凉的雨水狠狠击打着他的脸颊，在他的眼边凝成一面水精的帘子，朦胧间，他看见昏黄的路灯洒下金光透过迷蒙氤氲的水汽散落在路的前方，像极春日烟雨旁温暖的斜阳，这样想时，原本被雨淋湿刺骨的寒冷中竟带有一丝温暖的感觉了。他将头缩回雨衣中，轻轻闭上双眼，喧闹的雨声里，他竟感到几分宁静与悠闲。这样想时，他便希望公路的前方能不断延伸，好让他的思绪能顺着纷纷而落的雨水流过不同的时空。 ​ 恍惚间，他感觉身下的电动车仿佛变成了一只小小的舟在江南雨季的湖面上漂泊，碧绿的湖面光滑如镜，延伸到视野的尽头与浅蓝的天空相接，舟中的旅人一时分不清船行水中还是天边，便倚着雨点滴落湖面的脆响安然入眠；又仿佛轻轻踩过被雨润透的泥土，雨意迷蒙的水气捎来杏花的芬芳牵起他的衣角… 他心中仿佛被触动般一下子就放轻松起来，将烦恼与忧虑都溶于雨点任他漂走。他在这喧闹而又宁静的雨中又一次睁开眼睛，任雨水洗刻他疲倦的眉眼… ​ 伴随着一声长长的摩擦声与水花溅起的声音，电动车缓缓停下了。我跳下车，抖去身旁的雨水，朝光亮的家中走去。","categories":[{"name":"Article","slug":"Article","permalink":"http://odalys8191.github.io/categories/Article/"}],"tags":[]},{"title":"2021 辛丑年阅读计划","slug":"2021-辛丑年阅读计划","date":"2020-12-31T16:00:00.000Z","updated":"2024-11-08T04:02:06.550Z","comments":true,"path":"Plans/2021-辛丑年阅读计划/cm34e3w4z001o5vtn8uayhykg/","link":"","permalink":"http://odalys8191.github.io/Plans/2021-%E8%BE%9B%E4%B8%91%E5%B9%B4%E9%98%85%E8%AF%BB%E8%AE%A1%E5%88%92/cm34e3w4z001o5vtn8uayhykg/","excerpt":"","text":"2021 辛丑年阅读计划 德 智 体 美 劳全面发展 哲学 [ ] 浪漫之魂 [x] 中国哲学简史 社科 [ ] 全球简史（了解即可） [ ] 西方战争史 [ ] 民主的细节 美育 [ ] 美的沉思 [x] 陶庵梦忆 [x] 嘉陵说诗 小说 [ ] 红楼梦 + 蒋勋说红楼梦 [ ] 推理小说（随缘看看$x,y,z$之类的） [ ] 武侠小说（补补陆小凤） [ ] 蝴蝶梦 [x] 百年孤独 （文学未死） 好像已经鸽了","categories":[{"name":"Plans","slug":"Plans","permalink":"http://odalys8191.github.io/categories/Plans/"}],"tags":[{"name":"Daily","slug":"Daily","permalink":"http://odalys8191.github.io/tags/Daily/"}]},{"title":"2020庚子年终总结","slug":"2020庚子年终总结","date":"2020-12-31T03:59:59.000Z","updated":"2024-11-08T04:01:22.099Z","comments":true,"path":"Article/2020庚子年终总结/cm34e3w4400015vtnavz018pr/","link":"","permalink":"http://odalys8191.github.io/Article/2020%E5%BA%9A%E5%AD%90%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/cm34e3w4400015vtnavz018pr/","excerpt":"","text":"2020庚子年终总结 1 . 除夕夜心太浮躁，学不进算法，懒得写文化作业，这么拉跨的春晚没什么看的必要，还是来水水Blog吧！ 2 .除夕夜一个哥哥来了，打彩六去了，生日的归程来水博吧！ $\\texttt{去年的此时此刻} \\to \\texttt{开学}$ 仍记得去年的此时此刻，我仍像此刻或是从前的某时某刻一般回到爷爷家中过年，不过，比前从前年年的打摆搞颓，去年的我由于要准备中考，是打算来这里写作业的。某天突然有个新闻出来，告诉我们开学推迟到二月几号，当时的我十分开心，终于可以开学考考好点了，终于有希望写完寒假作业了！但是，尽管立下了很多Flag，当时的我只想好好搞颓，于是用新买的$Sony$大耳天天听$\\texttt{apple music}$刷网剧，为了预习唐探3，我把唐探网剧刷完了，导演有点东西！网剧严格意义上是三部电影，前两部我用心拍吸引观众，最后一部我致敬资方把要捧的屎都放这，女少口阿，建议其他导演好好学学。当时的我由于电脑太菜只能玩玩钢四和炉石……也就没怎么玩电脑。当时，疫情并未造成较大恐慌，我们还在讨论美刺杀伊将军等国际新闻，年的味道还是比较浓郁的，除夕之夜比较无聊，零点的时候我独自坐在二楼的阳台边，望着烟花从老树边纷纷而起，无聊抢枪同学的红包，再沉默以对列表群发祝福的小朋友们，年就过完了。 某个雨夜，在房间苟钢四的我开了修改器不会调整兵的后勤，正在为打不过西北三马而百思不得其解之时，我撤离了爷爷家前往外公家，在那里和哥哥认真练习如何拿到金牌打野。就在这个雨夜，我鬼迷心窍，买了炒鸡好康的伽罗小姐姐年限，由于不太会一年到头没完几次……算是冲动性消费了。 在外公家，我与哥哥坐在楼上，别人认为我们在搞学，而其实……正如下图的原图，可能颓废几小时会做那么一两到题吧 那段时间就比较养生，早上自然起，坐在书桌前搞搞学，玩玩玩玩游戏，刷刷刷刷刷知乎，中午去打打球，随随便便就到了三月多份，疫情越沿越长，在乡下又水了好久网课，就回家了，在家里中雅搞了好多网课加作业，我把它本地下载下来，再二倍速水掉，遇到有用的东西就停下看一眼，短短一周我能刷三部番……我还上上暴雪，抓抓机房同伴的摆。 至今回忆总觉浮生若梦，颓了好久就开学了，开学考试惊讶地发现竟然还行，问问同学发现大家网课期间都在打摆，物理老师又换了，我的新上司张老师上课的一句话点明了真相：“大家不要真觉得网课有用，学校和老师也没觉得网课大家会认真听，要抓紧时间了”。 $\\texttt{开学} \\to \\texttt{中考}$ 开学后的体验就比较平淡了，日常是考试和搞学，由于机房的同伴们大多都专心搞文化去了平时也没什么联系，所以搞起学来没什么压力，跟自己班上的同学们比试一来二去也算是有来有往，成绩与实力都慢慢沉淀，心态也佛了许多。平日还兼职当当情感导师，合理导向青春期小朋友的恋爱心理，顺便传传教快乐一下。晚餐都在附近吃，就着$Kindle$十分快乐。由于以前的几次与老师们的打交道谈心，班主任和任课老师都误认为我是一个稳重的人（其实我跟某紫菜蛋花一样，我这辈子还没发现自己竟有这样的优点233），所以对我的一些骚操作如晚自习戴大耳听歌，在墙上贴苏维埃革命宣传画激励搞学（文盲就像眼盲— 扫盲宣传画……）之类的事情都睁一只眼闭一只眼…..日常还是轻松愉快的。 几次考试有时会让我稳如老狗般的心态掀起波澜，仍记得第一次月考数学我可能全程梦游，所有大题全算错导致直接上D的有趣体验，那次考后老师按这次成绩把所有有可能作出压轴题的人发了本压轴题集，全班基本是个人都有，而我惨遭开除人籍，还记得那个晚自习下课，别人拿了书正相互交流而我默默收拾好书包回家，心中暗下决心要吊着打所有拿到书的人。结果第二天老师安排思维组长，我TM入选了，老师还给了我本书，拿到书听老师开会的时候我在想：“这个思维组长的意思是不是考虑到我计算问题？？？”我吊打我自己石锤。然后的考试我都有6A，直到中考前最后一次模拟考，我语文英语全挂了，班主任说我由于B在主科，可能 那个什么学校来着 都不会要我，虽然如今回首发现可能能来雅礼借读一样上竞赛班，但当时的我十分方脏，于是整整两周冲刺晚自习没有听歌，全在搞这两科。一晃就到了中考，这个有趣的时刻。 插播一件小趣事，那位青春期小朋友中考前表白，然后突然开心的把卫生全包了，我还以为他成功了，没想到……不过作为既得利益者的我免了卫生看破不说破，回家开心$BanGDream$去了。 $\\texttt{中考}$ 中考算是一个让我比较难以忘怀的时间点吧！记得开考前为了保持稳如老狗的心态给自己做了很多心理建设包括但不限于天时地利人和，每场考试出发前和结束后 都打把音游放松心情……之类的。 第一门考语文，入考场先与同学谈笑风生来掩饰自己方到不行，一发卷子发现答题卡结构完全不同，我听到周围一阵倒吸冷气的声音，我也十分害怕。但真正上考场开始答题，我反而不怎么慌了，为了延续光荣传统我写作前打算先到厕所冷静构思一下，但某稻田中学的厕所真是一言难尽，所以我打消了每场考试多去厕所的决定，作文我不太敢标新立异，写了个较为保守符合社会主义核心价值观又不失一点文采的上去（反正都是写过的），写完感觉海星，但看看只剩十五分钟了周围人好多都白了一大块我感觉更行了，众所周知，拿A还得看团队合作，你考的好+别人考的不好。考完后我想起了兵法中一鼓作气的例子，但又怕对答案翻车，于是和朋友谈笑风声增强个人信心。其余的不打算写了，知乎写过一遍了。 一些好玩的事，本着延续光荣传统的原则，我在书包上挂了哆啦A梦，然后考场中发现一位初中同班同学也穿了哆啦A梦，我想老师提过的有趣的寓意（多拿A不是梦）竟然除了我这种哆啦A梦十年老粉外还记得，于是心血来潮，回家就下单了个万代哆啦A梦原始版…… $\\texttt{暑假} \\to \\texttt{高中开学}$ 中考完第二天就是暑假集训，上午先去拍了毕业照，不知不觉就毕业了感觉还是挺怅然的。 下午就开始集训了，每天考试，复习新算法，到后期机房又来了一些新的伙伴。 出成绩那天还是很慌的，但直接6A了就很开心。一系列繁杂的事情过后我总算来到了月亮（YL）中学。 值得一提的是由于历史原因，机房同学对我有很多误解，于是我打算消除这些误解，并让新同学也相信我的清白，从而使我重归自由，但由于个人操作过于草率……快进到七进七出 ​ 分班考试前一天，教练把我们拉在一起说：“明天大家还是要参加考试的，班已经分好了，大家放心考。“ 然后……. $\\texttt{军训} \\to \\texttt{年末}$​ 有幸进入了全国最好学校的最好班级（某帝自语，并与同学们一起参加了军训。 ​ 然后，由于个人开局过于浮躁导致学期初就摔得很惨，文化和竞赛双输，后期学习习惯和态度都提高了起来，但还没有做到最好，所以还是要提升自己的各方面综合素质，同时更为沉稳，努力钻研算法背后的逻辑与精妙之处，努力追上在我前面的同伴们。 ​ 高中的学科都变得更为有趣且困难了，以语文为例，我认为高中的语文课堂是展现了人文学科的独特魅力的，尽管我常常利用它补觉。 ​ 你校活动是真的多，尽管我们班的特殊情况错过了很多活动，但耐不住其活动是真帝多。 ​ 先是校运会，我，辣椒油，小猪猪社会主义三人组成功从班长那骗到了小记者证和小红帽，于是就可以自由出入运动场内外，就可以光明正大地去看漂亮小姐姐机房搞学辣。 ​ 机房的同伴们还是十分团(wo)结(qu)友(ni))爱(ma)的，人均传教士，于是我常山赵子龙的名号路人皆知，直接导致我接下来一系列活动的全程自闭。 ​ 太自闭了，就不写了。当然，还是要吐槽魔术社莫名其妙的魔名其妙专场.以及周边硬搬我$wallhaven.cc$就行好吧。 ​ 顺便说一句，元旦晚会阅读李白诗歌是真地劲，叶嘉陵先生太会了。 $\\texttt{一些展望}$ 身体是革命的本钱，为了响应班主任的号召，要提升身体素质 在机房苟太久社交能力快退化为原始人了，要锻炼社交能力，要不然怎么找女朋友 提升学术水平，不止于领悟知识，更要深钻。 提升艺术素养，包括但不限于读诗歌，学习简单声乐。 提升思维的深度，如学习哲学，让自己认识自己。","categories":[{"name":"Article","slug":"Article","permalink":"http://odalys8191.github.io/categories/Article/"}],"tags":[{"name":"Daily","slug":"Daily","permalink":"http://odalys8191.github.io/tags/Daily/"}]}],"categories":[{"name":"Article","slug":"Article","permalink":"http://odalys8191.github.io/categories/Article/"},{"name":"Articles","slug":"Articles","permalink":"http://odalys8191.github.io/categories/Articles/"},{"name":"Notes","slug":"Notes","permalink":"http://odalys8191.github.io/categories/Notes/"},{"name":"Test","slug":"Test","permalink":"http://odalys8191.github.io/categories/Test/"},{"name":"Tests","slug":"Tests","permalink":"http://odalys8191.github.io/categories/Tests/"},{"name":"Solutions","slug":"Solutions","permalink":"http://odalys8191.github.io/categories/Solutions/"},{"name":"Vps","slug":"Vps","permalink":"http://odalys8191.github.io/categories/Vps/"},{"name":"travel","slug":"travel","permalink":"http://odalys8191.github.io/categories/travel/"},{"name":"Races","slug":"Races","permalink":"http://odalys8191.github.io/categories/Races/"},{"name":"Plans","slug":"Plans","permalink":"http://odalys8191.github.io/categories/Plans/"},{"name":"Review","slug":"Review","permalink":"http://odalys8191.github.io/categories/Review/"},{"name":"Race","slug":"Race","permalink":"http://odalys8191.github.io/categories/Race/"}],"tags":[{"name":"奇怪周记","slug":"奇怪周记","permalink":"http://odalys8191.github.io/tags/%E5%A5%87%E6%80%AA%E5%91%A8%E8%AE%B0/"},{"name":"数论","slug":"数论","permalink":"http://odalys8191.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"高斯整数","slug":"高斯整数","permalink":"http://odalys8191.github.io/tags/%E9%AB%98%E6%96%AF%E6%95%B4%E6%95%B0/"},{"name":"trie","slug":"trie","permalink":"http://odalys8191.github.io/tags/trie/"},{"name":"AC自动机","slug":"AC自动机","permalink":"http://odalys8191.github.io/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"字符串","slug":"字符串","permalink":"http://odalys8191.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"斯特林反演","slug":"斯特林反演","permalink":"http://odalys8191.github.io/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E5%8F%8D%E6%BC%94/"},{"name":"dfs","slug":"dfs","permalink":"http://odalys8191.github.io/tags/dfs/"},{"name":"根号分治","slug":"根号分治","permalink":"http://odalys8191.github.io/tags/%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/"},{"name":"线性代数","slug":"线性代数","permalink":"http://odalys8191.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"dp","slug":"dp","permalink":"http://odalys8191.github.io/tags/dp/"},{"name":"计算几何","slug":"计算几何","permalink":"http://odalys8191.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"datastructure","slug":"datastructure","permalink":"http://odalys8191.github.io/tags/datastructure/"},{"name":"拓扑","slug":"拓扑","permalink":"http://odalys8191.github.io/tags/%E6%8B%93%E6%89%91/"},{"name":"奇偶性","slug":"奇偶性","permalink":"http://odalys8191.github.io/tags/%E5%A5%87%E5%81%B6%E6%80%A7/"},{"name":"经典结论","slug":"经典结论","permalink":"http://odalys8191.github.io/tags/%E7%BB%8F%E5%85%B8%E7%BB%93%E8%AE%BA/"},{"name":"闵克夫斯基和","slug":"闵克夫斯基和","permalink":"http://odalys8191.github.io/tags/%E9%97%B5%E5%85%8B%E5%A4%AB%E6%96%AF%E5%9F%BA%E5%92%8C/"},{"name":"凸包","slug":"凸包","permalink":"http://odalys8191.github.io/tags/%E5%87%B8%E5%8C%85/"},{"name":"bitset","slug":"bitset","permalink":"http://odalys8191.github.io/tags/bitset/"},{"name":"分块","slug":"分块","permalink":"http://odalys8191.github.io/tags/%E5%88%86%E5%9D%97/"},{"name":"卡常","slug":"卡常","permalink":"http://odalys8191.github.io/tags/%E5%8D%A1%E5%B8%B8/"},{"name":"Dirichlet前缀和","slug":"Dirichlet前缀和","permalink":"http://odalys8191.github.io/tags/Dirichlet%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"推柿子","slug":"推柿子","permalink":"http://odalys8191.github.io/tags/%E6%8E%A8%E6%9F%BF%E5%AD%90/"},{"name":"原根应用","slug":"原根应用","permalink":"http://odalys8191.github.io/tags/%E5%8E%9F%E6%A0%B9%E5%BA%94%E7%94%A8/"},{"name":"离散对数","slug":"离散对数","permalink":"http://odalys8191.github.io/tags/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/"},{"name":"dfn的性质","slug":"dfn的性质","permalink":"http://odalys8191.github.io/tags/dfn%E7%9A%84%E6%80%A7%E8%B4%A8/"},{"name":"平衡树","slug":"平衡树","permalink":"http://odalys8191.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"SAM","slug":"SAM","permalink":"http://odalys8191.github.io/tags/SAM/"},{"name":"线段树合并","slug":"线段树合并","permalink":"http://odalys8191.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"},{"name":"endpos性质","slug":"endpos性质","permalink":"http://odalys8191.github.io/tags/endpos%E6%80%A7%E8%B4%A8/"},{"name":"Foregin","slug":"Foregin","permalink":"http://odalys8191.github.io/tags/Foregin/"},{"name":"贪心","slug":"贪心","permalink":"http://odalys8191.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"随机化","slug":"随机化","permalink":"http://odalys8191.github.io/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96/"},{"name":"主席树","slug":"主席树","permalink":"http://odalys8191.github.io/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"name":"数据结构","slug":"数据结构","permalink":"http://odalys8191.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二分","slug":"二分","permalink":"http://odalys8191.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"人类智慧","slug":"人类智慧","permalink":"http://odalys8191.github.io/tags/%E4%BA%BA%E7%B1%BB%E6%99%BA%E6%85%A7/"},{"name":"二进制分拆","slug":"二进制分拆","permalink":"http://odalys8191.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%8B%86/"},{"name":"构造","slug":"构造","permalink":"http://odalys8191.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"模拟","slug":"模拟","permalink":"http://odalys8191.github.io/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"二分图","slug":"二分图","permalink":"http://odalys8191.github.io/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"概率与期望","slug":"概率与期望","permalink":"http://odalys8191.github.io/tags/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/"},{"name":"网络流","slug":"网络流","permalink":"http://odalys8191.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"排列","slug":"排列","permalink":"http://odalys8191.github.io/tags/%E6%8E%92%E5%88%97/"},{"name":"莫队","slug":"莫队","permalink":"http://odalys8191.github.io/tags/%E8%8E%AB%E9%98%9F/"},{"name":"分类讨论","slug":"分类讨论","permalink":"http://odalys8191.github.io/tags/%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA/"},{"name":"线段树","slug":"线段树","permalink":"http://odalys8191.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"每天一道DS题","slug":"每天一道DS题","permalink":"http://odalys8191.github.io/tags/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93DS%E9%A2%98/"},{"name":"dfn妙用","slug":"dfn妙用","permalink":"http://odalys8191.github.io/tags/dfn%E5%A6%99%E7%94%A8/"},{"name":"神奇数学","slug":"神奇数学","permalink":"http://odalys8191.github.io/tags/%E7%A5%9E%E5%A5%87%E6%95%B0%E5%AD%A6/"},{"name":"数数","slug":"数数","permalink":"http://odalys8191.github.io/tags/%E6%95%B0%E6%95%B0/"},{"name":"最短路","slug":"最短路","permalink":"http://odalys8191.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"图论","slug":"图论","permalink":"http://odalys8191.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"第二类斯特林数","slug":"第二类斯特林数","permalink":"http://odalys8191.github.io/tags/%E7%AC%AC%E4%BA%8C%E7%B1%BB%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"},{"name":"二项式反演","slug":"二项式反演","permalink":"http://odalys8191.github.io/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/"},{"name":"暴力","slug":"暴力","permalink":"http://odalys8191.github.io/tags/%E6%9A%B4%E5%8A%9B/"},{"name":"CDQ","slug":"CDQ","permalink":"http://odalys8191.github.io/tags/CDQ/"},{"name":"期望","slug":"期望","permalink":"http://odalys8191.github.io/tags/%E6%9C%9F%E6%9C%9B/"},{"name":"分治","slug":"分治","permalink":"http://odalys8191.github.io/tags/%E5%88%86%E6%B2%BB/"},{"name":"原根","slug":"原根","permalink":"http://odalys8191.github.io/tags/%E5%8E%9F%E6%A0%B9/"},{"name":"min25","slug":"min25","permalink":"http://odalys8191.github.io/tags/min25/"},{"name":"概率","slug":"概率","permalink":"http://odalys8191.github.io/tags/%E6%A6%82%E7%8E%87/"},{"name":"记忆化","slug":"记忆化","permalink":"http://odalys8191.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96/"},{"name":"高精","slug":"高精","permalink":"http://odalys8191.github.io/tags/%E9%AB%98%E7%B2%BE/"},{"name":"可持久化块状数组","slug":"可持久化块状数组","permalink":"http://odalys8191.github.io/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%9D%97%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"后缀数组","slug":"后缀数组","permalink":"http://odalys8191.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"素数","slug":"素数","permalink":"http://odalys8191.github.io/tags/%E7%B4%A0%E6%95%B0/"},{"name":"博弈论","slug":"博弈论","permalink":"http://odalys8191.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"妙题","slug":"妙题","permalink":"http://odalys8191.github.io/tags/%E5%A6%99%E9%A2%98/"},{"name":"阶梯nim","slug":"阶梯nim","permalink":"http://odalys8191.github.io/tags/%E9%98%B6%E6%A2%AFnim/"},{"name":"小学奥数","slug":"小学奥数","permalink":"http://odalys8191.github.io/tags/%E5%B0%8F%E5%AD%A6%E5%A5%A5%E6%95%B0/"},{"name":"树的直径","slug":"树的直径","permalink":"http://odalys8191.github.io/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"},{"name":"子集卷积系统","slug":"子集卷积系统","permalink":"http://odalys8191.github.io/tags/%E5%AD%90%E9%9B%86%E5%8D%B7%E7%A7%AF%E7%B3%BB%E7%BB%9F/"},{"name":"斯特林相关","slug":"斯特林相关","permalink":"http://odalys8191.github.io/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E7%9B%B8%E5%85%B3/"},{"name":"位运算","slug":"位运算","permalink":"http://odalys8191.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"玄妙","slug":"玄妙","permalink":"http://odalys8191.github.io/tags/%E7%8E%84%E5%A6%99/"},{"name":"自动姬","slug":"自动姬","permalink":"http://odalys8191.github.io/tags/%E8%87%AA%E5%8A%A8%E5%A7%AC/"},{"name":"长链剖分","slug":"长链剖分","permalink":"http://odalys8191.github.io/tags/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"MST","slug":"MST","permalink":"http://odalys8191.github.io/tags/MST/"},{"name":"Boruvka","slug":"Boruvka","permalink":"http://odalys8191.github.io/tags/Boruvka/"},{"name":"计数","slug":"计数","permalink":"http://odalys8191.github.io/tags/%E8%AE%A1%E6%95%B0/"},{"name":"欧拉回路","slug":"欧拉回路","permalink":"http://odalys8191.github.io/tags/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"},{"name":"线性基","slug":"线性基","permalink":"http://odalys8191.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"},{"name":"树上问题","slug":"树上问题","permalink":"http://odalys8191.github.io/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"},{"name":"trick","slug":"trick","permalink":"http://odalys8191.github.io/tags/trick/"},{"name":"树论","slug":"树论","permalink":"http://odalys8191.github.io/tags/%E6%A0%91%E8%AE%BA/"},{"name":"背包","slug":"背包","permalink":"http://odalys8191.github.io/tags/%E8%83%8C%E5%8C%85/"},{"name":"数学","slug":"数学","permalink":"http://odalys8191.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"stl","slug":"stl","permalink":"http://odalys8191.github.io/tags/stl/"},{"name":"思维","slug":"思维","permalink":"http://odalys8191.github.io/tags/%E6%80%9D%E7%BB%B4/"},{"name":"gcd","slug":"gcd","permalink":"http://odalys8191.github.io/tags/gcd/"},{"name":"矩阵","slug":"矩阵","permalink":"http://odalys8191.github.io/tags/%E7%9F%A9%E9%98%B5/"},{"name":"欧拉路","slug":"欧拉路","permalink":"http://odalys8191.github.io/tags/%E6%AC%A7%E6%8B%89%E8%B7%AF/"},{"name":"国庆集训","slug":"国庆集训","permalink":"http://odalys8191.github.io/tags/%E5%9B%BD%E5%BA%86%E9%9B%86%E8%AE%AD/"},{"name":"重链剖分","slug":"重链剖分","permalink":"http://odalys8191.github.io/tags/%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"交互","slug":"交互","permalink":"http://odalys8191.github.io/tags/%E4%BA%A4%E4%BA%92/"},{"name":"格路基础","slug":"格路基础","permalink":"http://odalys8191.github.io/tags/%E6%A0%BC%E8%B7%AF%E5%9F%BA%E7%A1%80/"},{"name":"组合意义","slug":"组合意义","permalink":"http://odalys8191.github.io/tags/%E7%BB%84%E5%90%88%E6%84%8F%E4%B9%89/"},{"name":"Dp","slug":"Dp","permalink":"http://odalys8191.github.io/tags/Dp/"},{"name":"交互题","slug":"交互题","permalink":"http://odalys8191.github.io/tags/%E4%BA%A4%E4%BA%92%E9%A2%98/"},{"name":"tarjan","slug":"tarjan","permalink":"http://odalys8191.github.io/tags/tarjan/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://odalys8191.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"dfn 的相关应用","slug":"dfn-的相关应用","permalink":"http://odalys8191.github.io/tags/dfn-%E7%9A%84%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8/"},{"name":"JOISC","slug":"JOISC","permalink":"http://odalys8191.github.io/tags/JOISC/"},{"name":"Tricks","slug":"Tricks","permalink":"http://odalys8191.github.io/tags/Tricks/"},{"name":"双指针","slug":"双指针","permalink":"http://odalys8191.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"树状数组","slug":"树状数组","permalink":"http://odalys8191.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"LIS","slug":"LIS","permalink":"http://odalys8191.github.io/tags/LIS/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://odalys8191.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"斜率","slug":"斜率","permalink":"http://odalys8191.github.io/tags/%E6%96%9C%E7%8E%87/"},{"name":"高中数学","slug":"高中数学","permalink":"http://odalys8191.github.io/tags/%E9%AB%98%E4%B8%AD%E6%95%B0%E5%AD%A6/"},{"name":"MO","slug":"MO","permalink":"http://odalys8191.github.io/tags/MO/"},{"name":"数位Dp","slug":"数位Dp","permalink":"http://odalys8191.github.io/tags/%E6%95%B0%E4%BD%8DDp/"},{"name":"费用流","slug":"费用流","permalink":"http://odalys8191.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"},{"name":"Vp","slug":"Vp","permalink":"http://odalys8191.github.io/tags/Vp/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://odalys8191.github.io/tags/Codeforces/"},{"name":"单调队列","slug":"单调队列","permalink":"http://odalys8191.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"并查集","slug":"并查集","permalink":"http://odalys8191.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"splay","slug":"splay","permalink":"http://odalys8191.github.io/tags/splay/"},{"name":"Daily","slug":"Daily","permalink":"http://odalys8191.github.io/tags/Daily/"}]}